<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>蓝桥杯省赛真题</title>
    <url>/lan_qiao-provincial_question/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p>准备蓝桥杯时候刷真题的一小部分记录，有几道题在我之前发过的 <a class="link"   href="https://aidanblog.top/2021/08/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%99%AE%E5%8F%8A%E9%A2%98/">蓝桥杯普及题<i class="fas fa-external-link-alt"></i></a> 中，好多复杂的题直接把思路写在代码注释上，也没精力再整理到这了，后来还整理了一部分国赛真题，放在 OneNote 上的，结果在整理 OneDrive 上的文件时一不小心（手贱）给送走了，蓝桥杯的相关题刷过的还蛮丰富的，但记录下来的就只有这些了</p>
<span id="more"></span>
<h2 id="2018- 年"><a class="markdownIt-Anchor" href="#2018- 年"></a> 2018 年</h2>
<h3 id="三角形的面积"><a class="markdownIt-Anchor" href="# 三角形的面积"></a> 三角形的面积</h3>
<p><strong>题目：</strong><br />
已知三角形三个顶点在直角坐标系下的坐标分别为：</p>
<blockquote>
<p>(2.3, 2.5)</p>
</blockquote>
<p>(6.4, 3.1)<br />
(5.1, 7.2)</p>
<p>求该三角形的面积。<br />
注意，要提交的是一个小数形式表示的浮点数。<br />
要求精确到小数后 3 位，如不足 3 位，需要补零。</p>
<p><strong>思路：</strong><br />
可以采用两种算法：图形切割和海伦公式</p>
<ul>
<li>图形切割法：用最外侧两点的坐标减去最靠近圆心坐标的点求出两个正方形的边长，用大正方形的面积减去小正方形的面积就是三角形的两倍</li>
<li>海伦公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><msqrt><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>P</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>P</mi><mo>−</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>P</mi><mo>−</mo><mi>c</mi><mo stretchy="false">)</mo></mrow></msqrt></mrow><annotation encoding="application/x-tex">S=\sqrt{P(P-a)(P-b)(P-c)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30499999999999994em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span><span style="top:-2.8950000000000005em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"style="height:0.30499999999999994em;"><span></span></span></span></span></span></span></span></span>，其中 P 是周长的一半，先根据坐标用勾股定理求出每条边的边长</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 图形切割法</span></span><br><span class="line">    <span class="comment">// 用最外侧两点的坐标减去最靠近圆心坐标的点求出两个正方形的边长</span></span><br><span class="line">    <span class="comment">// 用大正方形的面积减去小正方形的面积就是三角形的两倍</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="number">2.3</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">y1</span> <span class="operator">=</span> <span class="number">2.5</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="number">6.4</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">y2</span> <span class="operator">=</span> <span class="number">3.1</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x3</span> <span class="operator">=</span> <span class="number">5.1</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">y3</span> <span class="operator">=</span> <span class="number">7.2</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">X1</span> <span class="operator">=</span> x2 - x1;</span><br><span class="line">    <span class="type">double</span> <span class="variable">Y1</span> <span class="operator">=</span> y2 - y1;</span><br><span class="line">    <span class="type">double</span> <span class="variable">X2</span> <span class="operator">=</span> x3 - x1;</span><br><span class="line">    <span class="type">double</span> <span class="variable">Y2</span> <span class="operator">=</span> y3 - y1;</span><br><span class="line">    System.out.println((X1 * Y2 - X2 * Y1) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 海伦公式</span></span><br><span class="line">    <span class="comment">// 面积 =sqrt(P(P-a)(P-b)(P-c))；其中 P 是周长的一半</span></span><br><span class="line">    <span class="comment">// 先根据坐标用勾股定理求出每条边的边长</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> Math.sqrt((<span class="number">6.4</span> - <span class="number">2.3</span>) * (<span class="number">6.4</span> - <span class="number">2.3</span>) + (<span class="number">3.1</span> - <span class="number">2.5</span>) * (<span class="number">3.1</span> - <span class="number">2.5</span>));</span><br><span class="line">    <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> Math.sqrt((<span class="number">5.1</span> - <span class="number">2.3</span>) * (<span class="number">5.1</span> - <span class="number">2.3</span>) + (<span class="number">7.2</span> - <span class="number">2.5</span>) * (<span class="number">7.2</span> - <span class="number">2.5</span>));</span><br><span class="line">    <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> Math.sqrt((<span class="number">6.4</span> - <span class="number">5.1</span>) * (<span class="number">6.4</span> - <span class="number">5.1</span>) + (<span class="number">7.2</span> - <span class="number">3.1</span>) * (<span class="number">7.2</span> - <span class="number">3.1</span>));</span><br><span class="line">    <span class="type">double</span> <span class="variable">p</span> <span class="operator">=</span> (a + b + c) / <span class="number">2</span>;</span><br><span class="line">    System.out.println(Math.sqrt(p * (p - a) * (p - b) * (p - c)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大乘积"><a class="markdownIt-Anchor" href="# 最大乘积"></a> 最大乘积</h3>
<p><strong>题目：</strong><br />
把 1~9 位数字分成两组，将其相乘，使得它的乘积也是不重复的九个数字</p>
<blockquote>
<p>984672 * 351=345619872</p>
</blockquote>
<p>9 * 87146325=784316925</p>
<p>符合这种规律的乘式还有很多，求乘积最大的那一个</p>
<p><strong>思路：</strong></p>
<ol>
<li>首先进行全排列，这样就不用考虑重复的问题</li>
<li>将每次全排列的 9 个数字进行拆分相乘，保留符合条件的乘积，最后输出最大值即可</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxProduct</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt;= <span class="number">9</span>) &#123;<span class="comment">// 穷举所有全排列的将其分割相乘，判断乘积是否符合条件</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                    x = <span class="number">10</span> * x + a[j];<span class="comment">// 定义左边的乘数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt; <span class="number">9</span>; k++)</span><br><span class="line">                    y = <span class="number">10</span> * y + a[k];<span class="comment">// 定义右边的乘数</span></span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> x * y;</span><br><span class="line">                <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">                <span class="keyword">while</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt[res % <span class="number">10</span>]++;<span class="comment">// 将乘积分开放到数组中，对应下标的数组设为 1</span></span><br><span class="line">                    res /= <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= <span class="number">9</span>; k++)</span><br><span class="line">                    <span class="keyword">if</span> (cnt[k] != <span class="number">1</span>) &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    ans = Math.max(x * y, ans);<span class="comment">// 将最大的乘积保存下来</span></span><br><span class="line">                    <span class="keyword">if</span> (x * y == ans)</span><br><span class="line">                        System.out.println(x + <span class="string">&quot; * &quot;</span> + y + <span class="string">&quot; == &quot;</span> + ans);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            swap(i, m);</span><br><span class="line">            dfs(m + <span class="number">1</span>);</span><br><span class="line">            swap(i, m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整理玩具"><a class="markdownIt-Anchor" href="# 整理玩具"></a> 整理玩具</h3>
<p><strong>题目：</strong><br />
小明有一套玩具，一共包含 NxM 个部件。这些部件摆放在一个包含 NxM 个小格子的玩具盒中，每个小格子中恰好摆放一个部件。<br />
每一个部件上标记有一个 0~9 的整数，有可能有多个部件标记相同的整数。<br />
小明对玩具的摆放有特殊的要求：标记相同整数的部件必须摆在一起，组成一个矩形形状。<br />
如以下摆放是满足要求的：</p>
<blockquote>
<p>00022</p>
</blockquote>
<p>00033<br />
44444</p>
<blockquote>
<p>12244</p>
</blockquote>
<p>12244<br />
12233</p>
<blockquote>
<p>01234</p>
</blockquote>
<p>56789</p>
<p>以下摆放不满足要求：</p>
<blockquote>
<p>11122</p>
</blockquote>
<p>11122<br />
33311</p>
<blockquote>
<p>111111</p>
</blockquote>
<p>122221<br />
111111</p>
<blockquote>
<p>11122</p>
</blockquote>
<p>11113<br />
33333</p>
<p><em>输入</em><br />
输入包含多组数据。<br />
第一行包含一个整数 T，代表数据组数。 (1 &lt;= T &lt;= 10)<br />
以下包含 T 组数据。<br />
每组数据第一行包含两个整数 N 和 M。 (1 &lt;= N, M &lt;= 10)<br />
以下包含 N 行 M 列的矩阵，代表摆放方式。<br />
<em>输出</em><br />
对于每组数据，输出 YES 或者 NO 代表是否符合小明的要求。<br />
【样例输入】</p>
<blockquote>
<p>3</p>
</blockquote>
<p>3 5<br />
00022<br />
00033<br />
44444<br />
3 5<br />
11122<br />
33311<br />
2 5<br />
01234<br />
56789</p>
<p>【样例输出】</p>
<blockquote>
<p>YES</p>
</blockquote>
<p>NO<br />
YES</p>
<p><strong>思路：</strong></p>
<ol>
<li>将数组中的数放到 HashSet 中去重，仅记录玩具的种类</li>
<li>构造方法，用 Set 中的每一个值去判断，返回 Boolean 型
<ul>
<li>记录当前数据从左上到右下的坐标点，然后再遍历矩阵范围内的所有数字是否相同即可</li>
<li>判断方法可以把矩阵中的所有数字相加，然后根据矩阵下标求出个数，判断 sum==count*num 的值即可</li>
</ul>
</li>
<li>输入的数组没有空格，可以采用 toCharArray() 将其作为字符串存为字符数组，（Char 和 int 的自动转换）</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TidyupToys</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> sc.nextInt();<span class="comment">// 输入组数</span></span><br><span class="line">        <span class="keyword">while</span> (t-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            HashSet&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">// 存放出现的数字（不重复）</span></span><br><span class="line">            <span class="type">char</span>[][] arr = <span class="keyword">new</span> <span class="title class_">char</span>[n][m];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                arr[i] = sc.next().toCharArray();<span class="comment">// 输入数组（按行输入）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                    set.add(arr[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (Character c : set) &#123;<span class="comment">// 判断每一个不同的数据（从左上往右下进行寻找）</span></span><br><span class="line">                <span class="keyword">if</span> (!find(arr, c)) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                System.out.println(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从左上角向右下角寻找，因为数据比较小，每个数字找到他第一次出现 (x1,y1) 和</span></span><br><span class="line">    <span class="comment">// 最后出现的（x2,y2）, 然后遍历再 x1 x2 y1 y2 范围的数，如果符合是矩形</span></span><br><span class="line">    <span class="comment">// 那么遍历的每一个数一定是相同的，如果不相同说明不符合条件。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span>[][] arr, <span class="type">char</span> res)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">miny</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxy</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i][j] == res) &#123;<span class="comment">// 寻找 set 中的字符在数组中的第一次出现</span></span><br><span class="line">                    <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">                        minx = i;</span><br><span class="line">                        miny = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp++;</span><br><span class="line">                    maxx = Math.max(i, maxx);</span><br><span class="line">                    maxy = Math.max(j, maxy);<span class="comment">// 找出它的左上点和右下点下标</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxx == minx &amp;&amp; miny == maxy) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 只出现了一次必然不会出错</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (maxx - minx + <span class="number">1</span>) * (<span class="number">1</span> + maxy - miny);<span class="comment">// 记录应该出现的个数</span></span><br><span class="line">        <span class="comment">// 在判断的时候每个数的大小 * 个数，看是否等于遍历和。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> minx; i &lt;= maxx; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> miny; j &lt;= maxy; j++) &#123;</span><br><span class="line">                sum += arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum != res * count) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="版本分支"><a class="markdownIt-Anchor" href="# 版本分支"></a> 版本分支</h3>
<p><strong>题目：</strong><br />
公司一个奇怪的项目。这个项目的代码一直在不断分支 (branch) 但是从未发生过合并 (merge)。<br />
现在这个项目的代码一共有 N 个版本，编号 1~N，其中 1 号版本是最初的版本。<br />
除了 1 号版本之外，其他版本的代码都恰好有一个直接的父版本；即这 N 个版本形成了一棵以 1 为根的树形结构。<br />
如下图就是一个可能的版本树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    1--&gt;2;</span><br><span class="line">    1--&gt;3;</span><br><span class="line">    2--&gt;5;</span><br><span class="line">    3--&gt;4;</span><br><span class="line">    3--&gt;6;</span><br></pre></td></tr></table></figure>
<p>现在小明需要经常检查版本 x 是不是版本 y 的祖先版本。你能帮助小明吗？</p>
<p><em>输入</em><br />
第一行包含两个整数 N 和 Q，代表版本总数和查询总数。<br />
以下 N-1 行，每行包含 2 个整数 u 和 v，代表版本 u 是版本 v 的直接父版本。<br />
再之后 Q 行，每行包含 2 个整数 x 和 y，代表询问版本 x 是不是版本 y 的祖先版本。<br />
<em>输出</em><br />
对于每个询问，输出 YES 或 NO 代表 x 是否是 y 的祖先。<br />
【样例输入】</p>
<blockquote>
<p>6 5</p>
</blockquote>
<p>1 2<br />
1 3<br />
2 5<br />
3 6<br />
3 4<br />
1 1<br />
1 4<br />
2 6<br />
5 2<br />
6 4</p>
<p>【样例输出】</p>
<blockquote>
<p>YES</p>
</blockquote>
<p>YES<br />
NO</p>
<p><strong>思路：</strong></p>
<ol>
<li>按数组进行关系的存放，每个版本下标中存放它的直接父节点</li>
<li>如果在判断时 arr[y]==x, 那就是对应的直接父节点，如果不是就将它的 arr[y] 的值取出继续向上查找，一直到源点 1 结束</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VersionBranching</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">Q</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];<span class="comment">// 数组从 1 开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            union(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Q; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (find(x, y)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[y] == x)<span class="comment">// 是直接父节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[y];</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="number">1</span>) &#123;<span class="comment">// 没到源点，一直往上寻找</span></span><br><span class="line">            t = arr[t];</span><br><span class="line">            <span class="keyword">if</span> (t == x)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[y] == y) &#123;</span><br><span class="line">            arr[y] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2017- 年"><a class="markdownIt-Anchor" href="#2017- 年"></a> 2017 年</h2>
<h3 id="平方十位数"><a class="markdownIt-Anchor" href="# 平方十位数"></a> 平方十位数</h3>
<p><strong>题目：</strong><br />
由 0~9 这 10 个数字不重复、不遗漏，可以组成很多 10 位数字。<br />
这其中也有很多恰好是平方数（是某个数的平方）。<br />
比如：1026753849，就是其中最小的一个平方数。<br />
请你找出其中最大的一个平方数是多少？</p>
<p><strong>思路：</strong></p>
<ol>
<li>因为十位数的每位各不重复，所以可以采用 DFS 全排列，然后更改递归出口</li>
<li>递归出口的判断条件有十位数和平方数两个</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SquareTen</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;<span class="comment">// 因为求最大值，反向第一</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 平方数的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> m)</span> &#123;<span class="comment">// 用 dfs 全排列枚举</span></span><br><span class="line">        <span class="keyword">if</span> (m &gt;= <span class="number">10</span>) &#123;<span class="comment">// 将递归出口定义为平方数</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                res = <span class="number">10</span> * res + arr[i];</span><br><span class="line">            <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> (<span class="type">long</span>) Math.sqrt(res);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="string">&quot;&quot;</span> + res).length() != <span class="number">10</span>)<span class="comment">// 前边加空格转换为字符串判断长度</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (r * r == res) &#123;<span class="comment">// 是平方数</span></span><br><span class="line">                ans++;</span><br><span class="line">                System.out.println(res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">// 全排列公式</span></span><br><span class="line">            swap(i, m);</span><br><span class="line">            dfs(m + <span class="number">1</span>);</span><br><span class="line">            swap(i, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="comment">// 交换方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="填字母游戏"><a class="markdownIt-Anchor" href="# 填字母游戏"></a> 填字母游戏</h3>
<p><strong>题目：</strong><br />
K 大师在纸上画了一行 n 个格子，要小明和他交替往其中填入字母。</p>
<blockquote>
<ol>
<li>轮到某人填的时候，只能在某个空格中填入 L 或 O</li>
<li>谁先让字母组成了“LOL”的字样，谁获胜。</li>
<li>如果所有格子都填满了，仍无法组成 LOL，则平局。</li>
</ol>
</blockquote>
<p>本题的输入格式为：<br />
第一行，数字 n（n&lt;10），表示下面有 n 个初始局面。<br />
接下来，n 行，每行一个串，表示开始的局面。<br />
比如： <code>******</code> , 表示有 6 个空格。 <code>L****</code> , 表示左边是一个字母 L，它的右边是 4 个空格。</p>
<p>要求输出 n 个数字，表示对每个局面，如果小明先填，当 K 大师总是用最强着法的时候，小明的最好结果。<br />
1 表示能赢<br />
-1 表示必输<br />
0 表示可以逼平</p>
<p><em>输入</em></p>
<blockquote>
<p><code>4</code></p>
</blockquote>
<blockquote>
<p><code>***</code></p>
</blockquote>
<blockquote>
<p><code>L**L</code></p>
</blockquote>
<blockquote>
<p><code>L**L***L</code></p>
</blockquote>
<blockquote>
<p><code>L*****L</code></p>
</blockquote>
<p><em>输出</em></p>
<blockquote>
<p>0</p>
</blockquote>
<p>-1<br />
1</p>
<p><strong>思路：</strong></p>
<ol>
<li>判断方法，首先判断是否拿到时就出现 &quot;LOL&quot;，如果有说明已经输了（此判断还会在递归中判断是否填写成功）</li>
<li>第二次判断是否还有’*' 存在，若没有就是平局</li>
<li>然后模拟填数，将原本的’*' 赋值为’L’或者’O’然后递归到方法中判断</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FillLetters</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span>[] a = sc.next().toCharArray();<span class="comment">// 将字符串转换为字符数组存放</span></span><br><span class="line">            System.out.println(find(a));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span>[] a)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(a);<span class="comment">// 将数组转换为字符串方便查找</span></span><br><span class="line">        <span class="keyword">if</span> (s.contains(<span class="string">&quot;LOL&quot;</span>))<span class="comment">// 当拿到时就有了 &quot;LOL&quot; 直接失败，或者模拟填写时成功填写</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.contains(<span class="string">&quot;*&quot;</span>))<span class="comment">// 没有填写位置也没返回 LOL 说明平局</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;<span class="comment">// 构建循环模拟填写过程</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dogfall</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 平局记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == <span class="string">&#x27;*&#x27;</span>) &#123;<span class="comment">// 如果当前是空格可以填写，进行模拟</span></span><br><span class="line">                <span class="keyword">try</span> &#123;<span class="comment">// 可能出现异常</span></span><br><span class="line">                    a[i] = <span class="string">&#x27;L&#x27;</span>;<span class="comment">// 填入 L</span></span><br><span class="line">                    <span class="keyword">if</span> (find(a) == -<span class="number">1</span>)<span class="comment">// 拿到时出现 LOL</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (find(a) == <span class="number">0</span>)</span><br><span class="line">                        dogfall = <span class="number">1</span>;</span><br><span class="line">                    a[i] = <span class="string">&#x27;O&#x27;</span>;<span class="comment">// 填入 O</span></span><br><span class="line">                    <span class="keyword">if</span> (find(a) == -<span class="number">1</span>)<span class="comment">// 拿到时出现 LOL</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (find(a) == <span class="number">0</span>)</span><br><span class="line">                        dogfall = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;<span class="comment">// 无视异常与否进行执行</span></span><br><span class="line">                    a[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dogfall == <span class="number">1</span>)<span class="comment">// 填写中平局</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">// 没在填数过程中返回 1 则必返回 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2016- 年"><a class="markdownIt-Anchor" href="#2016- 年"></a> 2016 年</h2>
<h3 id="愤怒小鸟"><a class="markdownIt-Anchor" href="# 愤怒小鸟"></a> 愤怒小鸟</h3>
<p><strong>题目：</strong><br />
两辆相对的火车（A、B）以 10/ 秒的速度行驶，初始相距 1000，中间有一只小鸟以时速 50/ 秒的速度进行折返飞行（首先从 A 飞向 B）<br />
最后两辆车在相距 1 的位置停下，求这期间小鸟撞到 B 车多少次</p>
<p><strong>思路：</strong></p>
<ol>
<li>利用距离与速度推导出相遇的时间，然后计数器加一，再用时间更新位置</li>
<li>中间用 flag 变量的正负值确定方向</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AngryBirds</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//A</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1000</span>;<span class="comment">//B</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 计数</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 小鸟</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">// 用来判断飞向那个火车</span></span><br><span class="line">        <span class="type">double</span> t;<span class="comment">// 记录时间</span></span><br><span class="line">        <span class="keyword">while</span> (r - l &gt; <span class="number">1</span>) &#123;<span class="comment">// 两车未停</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;<span class="comment">// 从 A 向 B 飞</span></span><br><span class="line">                t = (r - b) / <span class="number">60.0</span>;<span class="comment">// 鸟和 B 火车相遇所用的时间</span></span><br><span class="line">                count++;<span class="comment">// 只有和 B 相遇的时候才计数加</span></span><br><span class="line">                l += <span class="number">10.0</span> * t;<span class="comment">// 更新 A 这段时间走的</span></span><br><span class="line">                r -= <span class="number">10.0</span> * t;<span class="comment">// 更新 B</span></span><br><span class="line">                b += <span class="number">50.0</span> * t;<span class="comment">// 更新鸟的位置</span></span><br><span class="line">                flag = -<span class="number">1</span>;<span class="comment">// 下次应该向 A 走</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 向火车 A 走</span></span><br><span class="line">                t = (b - l) / <span class="number">60.0</span>;</span><br><span class="line">                l += <span class="number">10.0</span> * t;</span><br><span class="line">                r -= <span class="number">10.0</span> * t;</span><br><span class="line">                b -= <span class="number">50.0</span> * t;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反幻方"><a class="markdownIt-Anchor" href="# 反幻方"></a> 反幻方</h3>
<p><strong>题目：</strong><br />
将 1~9 填入九宫格，求每行每列和两个对角线上的值的和互不相等的情况<br />
旋转镜像算一种</p>
<p><strong>思路：</strong></p>
<ol>
<li>全排列代码，将递归出口改为题意</li>
<li>旋转看边，镜像一般为 2</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Permutation</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        System.out.println(ans/<span class="number">8</span>);<span class="comment">// 旋转看边数，镜像一般为 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt;= <span class="number">9</span>) &#123;<span class="comment">// 一次排列完成，进行判断</span></span><br><span class="line">            <span class="type">int</span> a=arr[<span class="number">0</span>]+arr[<span class="number">1</span>]+arr[<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> b=arr[<span class="number">3</span>]+arr[<span class="number">4</span>]+arr[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> c=arr[<span class="number">6</span>]+arr[<span class="number">7</span>]+arr[<span class="number">8</span>];</span><br><span class="line">            <span class="type">int</span> x=arr[<span class="number">0</span>]+arr[<span class="number">3</span>]+arr[<span class="number">6</span>];</span><br><span class="line">            <span class="type">int</span> y=arr[<span class="number">1</span>]+arr[<span class="number">4</span>]+arr[<span class="number">7</span>];</span><br><span class="line">            <span class="type">int</span> z=arr[<span class="number">2</span>]+arr[<span class="number">5</span>]+arr[<span class="number">8</span>];</span><br><span class="line">            <span class="type">int</span> i=arr[<span class="number">0</span>]+arr[<span class="number">4</span>]+arr[<span class="number">8</span>];</span><br><span class="line">            <span class="type">int</span> j=arr[<span class="number">2</span>]+arr[<span class="number">4</span>]+arr[<span class="number">6</span>];</span><br><span class="line">            <span class="keyword">if</span> (a==b||a==c||a==x||a==y||a==z||a==i||a==j)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (b==c||b==x||b==y||b==z||b==i||b==j)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (c==x||c==y||c==z||c==i||c==j)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (x==y||x==z||x==i||x==j)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (y==z||y==i||y==j)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (z==i||z==j)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (i==j)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[m];</span><br><span class="line">            arr[m] = t;</span><br><span class="line">            dfs(m + <span class="number">1</span>);</span><br><span class="line">            t = arr[i];</span><br><span class="line">            arr[i] = arr[m];</span><br><span class="line">            arr[m] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="路径之谜"><a class="markdownIt-Anchor" href="# 路径之谜"></a> 路径之谜</h3>
<p><strong>题目：</strong><br />
假设城堡地面是 n x n 个方格。<br />
从西北角走到东南角，可以横向或纵向移动，但不能斜着走，也不能跳跃。<br />
每走到一个新方格，就要向正北方和正西方各射一箭（西和北各有 n 个靶子）<br />
同一个方格只允许经过一次。但不必做完所有的方格。<br />
如果只给出靶子上箭的数目，你能推断行走路线吗？<br />
有时是可以的，比如图中的例子。<br />
已知箭靶数字，求行走路径（测试数据保证路径唯一）</p>
<p><em>输入</em><br />
第一行一个整数 N(0&lt;N&lt;20)，表示地面有 N x N 个方格<br />
第二行 N 个整数，空格分开，表示北边的箭靶上的数字（自西向东）<br />
第三行 N 个整数，空格分开，表示西边的箭靶上的数字（自北向南）</p>
<p><em>输出</em><br />
一行若干个整数，表示骑士路径。</p>
<p>为了方便表示，我们约定每个小格子用一个数字代表，从西北角开始编号：0, 1, 2, 3…<br />
比如，图中的方块编号为：</p>
<blockquote>
<p>0  1  2  3</p>
</blockquote>
<p>4  5  6  7<br />
8  9  10 11<br />
12 13 14 15</p>
<p><em>样例输入</em></p>
<blockquote>
<p>4</p>
</blockquote>
<p>2 4 3 4<br />
4 3 3 3</p>
<p><em>样例输出</em></p>
<blockquote>
<p>0 4 5 1 2 3 7 11 10 9 13 14 15</p>
</blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>要想走相同的路线，可以设置为每走一步，拔掉北边和西边靶子上的箭，这样最后所以的靶子都清零，就表示路径是相同的</li>
<li>使用 DFS 搜索</li>
<li>需注意几点
<ul>
<li>入口（0，0）为必经点，在放入方法时就要拔掉对应的箭</li>
<li>路线不能重复，定义 flag 数组进行记录</li>
<li>得到的结果放入 ArrayList 集合中便于模拟失败后删除</li>
</ul>
</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysteryPath</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n;<span class="comment">// 记录格数 n*n</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] west;<span class="comment">// 西边的靶子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] north;<span class="comment">// 北边的靶子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span>[][] flag;<span class="comment">// 标记是否走过</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] dx = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;<span class="comment">// 记录行走的方式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] dy = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        west = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        north = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            north[i] = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            west[i] = in.nextInt();</span><br><span class="line">        west[<span class="number">0</span>]--;<span class="comment">// 左上角的方格为入口，必经</span></span><br><span class="line">        north[<span class="number">0</span>]--;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">        flag[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == n - <span class="number">1</span> &amp;&amp; y == n - <span class="number">1</span>) &#123;<span class="comment">// 到达右下的方格</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                <span class="keyword">if</span> (west[i] &gt; <span class="number">0</span> || north[i] &gt; <span class="number">0</span>)<span class="comment">// 模拟的路径若是相同所有的的靶子应该归零</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//System.out.println(&quot;!&quot;+c[i]+&quot; &quot;+r[i]);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Integer integer : list) <span class="comment">//==for (int i = 0; i &lt; list.size(); i++)// 符合条件将放入集合的路径变量读取出来</span></span><br><span class="line">                System.out.print(integer + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;<span class="comment">// 四个方向</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> x + dx[i];<span class="comment">// 走出之后的行</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">colum</span> <span class="operator">=</span> y + dy[i];<span class="comment">// 走出之后的列</span></span><br><span class="line">            <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; n &amp;&amp; colum &gt;= <span class="number">0</span> &amp;&amp; colum &lt; n &amp;&amp; !flag[row][colum] &amp;&amp; west[row] &gt; <span class="number">0</span> &amp;&amp; north[colum] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 不能越界；不能重复；不能是没射过箭的</span></span><br><span class="line">                west[row]--;<span class="comment">// 按原路走拔掉每一行的箭</span></span><br><span class="line">                north[colum]--;</span><br><span class="line">                list.add(row * n + colum);<span class="comment">// 行号 * N+ 列号就是方格的下标，放入集合中</span></span><br><span class="line">                flag[row][colum] = <span class="literal">true</span>;<span class="comment">// 标记走过</span></span><br><span class="line">                dfs(row, colum, list);<span class="comment">// 继续下一步</span></span><br><span class="line">                <span class="comment">//Reset in trace</span></span><br><span class="line">                flag[row][colum] = <span class="literal">false</span>;</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">                west[row]++;</span><br><span class="line">                north[colum]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2015- 年"><a class="markdownIt-Anchor" href="#2015- 年"></a> 2015 年</h2>
<h3 id="分机号"><a class="markdownIt-Anchor" href="# 分机号"></a> 分机号</h3>
<p><strong>题目：</strong><br />
有一种三位数的号码，符合以下两种条件：<br />
降序排列且每位都不重复<br />
如符合条件的：732；641；520<br />
不符合条件的：<s>660；123；201</s></p>
<p><strong>思路：</strong></p>
<ol>
<li>三重循环嵌套进行枚举</li>
<li>第一层循环的变量从 1 开始，三位数的百位不能为零</li>
<li>降序且重复可以用 <code>i &gt; j &amp;&amp; i &gt; k &amp;&amp; j &gt; k</code> 进行判断</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">// 百位不为零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; j &amp;&amp; i &gt; k &amp;&amp; j &gt; k) &#123;<span class="comment">// 定义降序且不重复条件</span></span><br><span class="line">                    ans++;</span><br><span class="line">                    System.out.println(<span class="string">&quot;&quot;</span> + i + j + k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五星填数"><a class="markdownIt-Anchor" href="# 五星填数"></a> 五星填数</h3>
<p><strong>题目：</strong><br />
五星图案节点填上数字：1~12，除去 7 和 11。<br />
要求每条直线上数字和相等。<br />
请你利用计算机搜索所有可能的填法有多少种。<br />
注意：旋转或镜像后相同的算同一种填法。</p>
<p><strong>思路：</strong></p>
<ol>
<li>将 1~12 进行全排列，五个一组按照相应的下标相加，符合条件 ans++</li>
<li>其中有 5 种旋转，2 种镜像，所以最后的结果 ans/10</li>
<li>dfs 中的循环变量，要从 dfs 变量开始，否则越界</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FiveStars</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        System.out.println(ans / <span class="number">10</span>);<span class="comment">// 最后的结果去掉旋转和镜像 5*2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">10</span>) &#123;<span class="comment">// 完成一次全排列</span></span><br><span class="line">            <span class="keyword">if</span> (arr[<span class="number">1</span>] + arr[<span class="number">2</span>] + arr[<span class="number">3</span>] + arr[<span class="number">4</span>] != arr[<span class="number">0</span>] + arr[<span class="number">2</span>] + arr[<span class="number">5</span>] + arr[<span class="number">8</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[<span class="number">1</span>] + arr[<span class="number">2</span>] + arr[<span class="number">3</span>] + arr[<span class="number">4</span>] != arr[<span class="number">0</span>] + arr[<span class="number">3</span>] + arr[<span class="number">6</span>] + arr[<span class="number">9</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[<span class="number">1</span>] + arr[<span class="number">2</span>] + arr[<span class="number">3</span>] + arr[<span class="number">4</span>] != arr[<span class="number">1</span>] + arr[<span class="number">5</span>] + arr[<span class="number">7</span>] + arr[<span class="number">9</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[<span class="number">1</span>] + arr[<span class="number">2</span>] + arr[<span class="number">3</span>] + arr[<span class="number">4</span>] != arr[<span class="number">4</span>] + arr[<span class="number">6</span>] + arr[<span class="number">7</span>] + arr[<span class="number">8</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            ans++;<span class="comment">// 符合就答案加一</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//i 从 m 开始</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[m];</span><br><span class="line">            arr[m] = t;</span><br><span class="line">            dfs(m + <span class="number">1</span>);</span><br><span class="line">            t = arr[i];</span><br><span class="line">            arr[i] = arr[m];</span><br><span class="line">            arr[m] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="立方变自身"><a class="markdownIt-Anchor" href="# 立方变自身"></a> 立方变自身</h3>
<p>有一个数 N，若它的各位相加等于它本身</p>
<blockquote>
<p>8<sup>3</sup>=512  5+1+2=8</p>
</blockquote>
<p>求总共有多少个这样的数</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">30</span>; i++) &#123;<span class="comment">// 最大到 27，实际运算中将范围扩大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pow</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(i, <span class="number">3</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pow != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += pow % <span class="number">10</span>;</span><br><span class="line">            pow /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == i)</span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加法变乘法"><a class="markdownIt-Anchor" href="# 加法变乘法"></a> 加法变乘法</h3>
<p><strong>题目：</strong><br />
1+2+3+4+···+49=1225<br />
将其中两个不相邻的加号变为乘号，使得结果变为 2015</p>
<blockquote>
<p>1+2+3+···+10<em>11+12+···+27</em>28+29+···+49=2015</p>
</blockquote>
<p>寻找另一个符合条件的答案，将左边的数进行提交</p>
<p><strong>思路：</strong></p>
<ol>
<li>两个乘号也就是改变四个数，那可以设置两层循环进行控制</li>
<li>首先定义 sum=1225，让 sum 减去第一层循环的 i 和 i+1，然后减去第二层的 j 和 j+1，得到的值再加上 i*(i+1) 和 j*(j+1)，若最后的结果 ==2015，输出 i 即可</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">49</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt;= <span class="number">49</span>; j++) &#123;<span class="comment">//i 要与后边的数相乘，所以 j 从 i+1 开始</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1225</span>;</span><br><span class="line">            ans -= i + (i + <span class="number">1</span>);</span><br><span class="line">            ans -= j + (j + <span class="number">1</span>);</span><br><span class="line">            ans += i * (i + <span class="number">1</span>) + j * (j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">2015</span>)</span><br><span class="line">                System.out.println(i + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="穿越雷区"><a class="markdownIt-Anchor" href="# 穿越雷区"></a> 穿越雷区</h3>
<p><strong>题目：</strong><br />
坦克必须交替地穿越正能量辐射区和负能量辐射区才能保持正常运转，否则将报废。<br />
某坦克需要从 A 区到 B 区去（A，B 区本身是安全区，没有正能量或负能量特征），怎样走才能路径最短？</p>
<p>已知的地图是一个方阵，上面用字母标出了 A，B 区，其它区都标了正号或负号分别表示正负能量辐射区。<br />
例如：</p>
<blockquote>
<p><code>A + - + -</code></p>
</blockquote>
<blockquote>
<p><code>- + - - +</code></p>
</blockquote>
<blockquote>
<p><code>- + + + -</code></p>
</blockquote>
<blockquote>
<p><code>+ - + - +</code></p>
</blockquote>
<blockquote>
<p><code>B + - + -</code></p>
</blockquote>
<p>坦克车只能水平或垂直方向上移动到相邻的区。<br />
数据格式要求：<br />
输入第一行是一个整数 n，表示方阵的大小， 4&lt;=n&lt;100<br />
接下来是 n 行，每行有 n 个数据，可能是 A，B，+，- 中的某一个，中间用空格分开。<br />
A，B 都只出现一次。<br />
要求输出一个整数，表示坦克从 A 区到 B 区的最少移动步数。<br />
如果没有方案，则输出 -1</p>
<p><em>样例输入</em></p>
<blockquote>
<p><code>5</code></p>
</blockquote>
<blockquote>
<p><code>A + - + -</code></p>
</blockquote>
<blockquote>
<p><code>- + - - +</code></p>
</blockquote>
<blockquote>
<p><code>- + + + -</code></p>
</blockquote>
<blockquote>
<p><code>+ - + - +</code></p>
</blockquote>
<blockquote>
<p><code>B + - + -</code></p>
</blockquote>
<p><em>样例输出</em><br />
10</p>
<p><strong>思路：</strong></p>
<ol>
<li>最短路径用 BFS 较好，但需要考虑优先队列的使用，这里采用 DFS+ 最大值比较的方式</li>
<li>需要设置的有，标记数组 flag 和前进数组 next</li>
<li>dfs 出口可以采用 String 自带的。equals 比较，判断当前数组的内容是否为 &quot;B&quot;，寻找所有的路径进行比较，只保留最小值</li>
<li>DFS 体，需要考虑越界和是否正负极连续以及标记数组是否为零</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AcrossMinefield</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] next = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;<span class="comment">// 下一步的方向，分别为：上，下，左，右</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">// 取最小，先赋予一个较大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        String[][] map = <span class="keyword">new</span> <span class="title class_">String</span>[n][n];<span class="comment">// 记录地图</span></span><br><span class="line">        <span class="type">int</span>[][] flag = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];<span class="comment">// 1 代表访问过，0 代表未访问过</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 入口坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; map[i].length; j++) &#123;</span><br><span class="line">                map[i][j] = sc.next();<span class="comment">// 用空格分割，按字符串存储</span></span><br><span class="line">                <span class="keyword">if</span> (map[i][j].equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">                    x = i;</span><br><span class="line">                    y = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(map, flag, x, y, <span class="number">0</span>);</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String[][] map, <span class="type">int</span>[][] visit, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> step)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[row][col].equals(<span class="string">&quot;B&quot;</span>)) &#123;<span class="comment">// 到达 B 为出口</span></span><br><span class="line">            <span class="keyword">if</span> (step &lt; ans)</span><br><span class="line">                ans = step;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[row][col] = <span class="number">1</span>;<span class="comment">// 将走过的点标记</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; next.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextRow</span> <span class="operator">=</span> row + next[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextCol</span> <span class="operator">=</span> col + next[i][<span class="number">1</span>];<span class="comment">// 下一步</span></span><br><span class="line">            <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= map.length || nextCol &lt; <span class="number">0</span> || nextCol &gt;= map.length)</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">// 越界直接进入下一层循环</span></span><br><span class="line">            <span class="keyword">if</span> (visit[nextRow][nextCol] == <span class="number">0</span>) &#123;<span class="comment">// 没有走过</span></span><br><span class="line">                visit[nextRow][nextCol] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!map[nextRow][nextCol].equals(map[row][col]))<span class="comment">// 不能相等，必须 +- 交替</span></span><br><span class="line">                    dfs(map, visit, nextRow, nextCol, step + <span class="number">1</span>);</span><br><span class="line">                visit[nextRow][nextCol] = <span class="number">0</span>;<span class="comment">// Reset in trace</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="表格计算"><a class="markdownIt-Anchor" href="# 表格计算"></a> 表格计算</h3>
<p><strong>题目：</strong><br />
某次无聊中， atm 发现了一个很老的程序。这个程序的功能类似于 Excel ，它对一个表格进行操作。<br />
不妨设表格有 n 行，每行有 m 个格子。<br />
每个格子的内容可以是一个正整数，也可以是一个公式。<br />
公式包括三种：</p>
<ol>
<li>SUM(x1,y1:x2,y2) 表示求左上角是第 x1 行第 y1 个格子，右下角是第 x2 行第 y2 个格子这个矩形内所有格子的值的和。</li>
<li>AVG(x1,y1:x2,y2) 表示求左上角是第 x1 行第 y1 个格子，右下角是第 x2 行第 y2 个格子这个矩形内所有格子的值的平均数。</li>
<li>STD(x1,y1:x2,y2) 表示求左上角是第 x1 行第 y1 个格子，右下角是第 x2 行第 y2 个格子这个矩形内所有格子的值的标准差。</li>
</ol>
<blockquote>
<p>标准差即为方差的平方根。</p>
</blockquote>
<p>方差就是：每个数据与平均值的差的平方的平均值，用来衡量单个数据离开平均数的程度。</p>
<p>公式都不会出现嵌套。<br />
如果这个格子内是一个数，则这个格子的值等于这个数，否则这个格子的值等于格子公式求值结果。<br />
输入这个表格后，程序会输出每个格子的值</p>
<p><em>输入格式</em><br />
第一行两个数 n, m 。<br />
接下来 n 行输入一个表格。每行 m 个由空格隔开的字符串，分别表示对应格子的内容。<br />
输入保证不会出现循环依赖的情况，即不会出现两个格子 a 和 b 使得 a 的值依赖 b 的值且 b 的值依赖 a 的值。</p>
<p><em>输出格式</em><br />
输出一个表格，共 n 行，每行 m 个保留两位小数的实数。<br />
数据保证不会有格子的值超过 1e6 。</p>
<p><em>样例输入</em></p>
<blockquote>
<p>3 2</p>
</blockquote>
<p>1 SUM(2, 1:3, 1)<br />
2 AVG(1, 1:1, 2)<br />
SUM(1, 1:2, 1) STD(1, 1:2, 2)</p>
<p><em>样例输出</em></p>
<blockquote>
<p>1.00 5.00</p>
</blockquote>
<p>2.00 3.00<br />
3.00 1.48</p>
<p><strong>思路：</strong></p>
<ol>
<li>因为有 <code>SUM(2,1:3,1)</code> 这种形式的输入，所以必须用字符串进行存储，定义一个<code>string[][]</code></li>
<li>存储完成后进行遍历，对每个数组的第一位进行检查，不是数字则放入方法中进行检查</li>
<li>检查方法，首先要将括号中的坐标进行记录，可以用 int[] 记录对下标为 4、6、8、10 进行 -'0’处理转换为整型</li>
<li>然后截取前三位进行字母比较判断其是哪种方法，然后分情况进行处理</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TableCalculation</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n, m;<span class="comment">// 表格规模</span></span><br><span class="line">    <span class="keyword">static</span> String[][] s = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span>[][] val = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        m = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                s[i][j] = sc.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i][j].charAt(<span class="number">0</span>) &lt; <span class="string">&#x27;0&#x27;</span> || s[i][j].charAt(<span class="number">0</span>) &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    val[i][j] = convert(s[i][j]);<span class="comment">// 如果数组中存放的不是正常数字，就放到转换方法中</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    val[i][j] = Double.parseDouble(s[i][j]);<span class="comment">// 是的话转换为 double 型</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%.2f &quot;</span>, val[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%.2f\n&quot;</span>, val[i][m]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] sub(String s) &#123;<span class="comment">// 找到方法中坐标的值，放入 c[1]~c[4]</span></span><br><span class="line">        <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++)</span><br><span class="line">            c[i] = <span class="number">0</span>;</span><br><span class="line">        c[<span class="number">1</span>] = s.charAt(<span class="number">4</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c[<span class="number">2</span>] = s.charAt(<span class="number">6</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c[<span class="number">3</span>] = s.charAt(<span class="number">8</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c[<span class="number">4</span>] = s.charAt(<span class="number">10</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">convert</span><span class="params">(String string)</span> &#123;<span class="comment">// 将公式进行判断转换</span></span><br><span class="line">        <span class="type">int</span> c[] = sub(string);</span><br><span class="line">        <span class="keyword">if</span> (string.substring(<span class="number">0</span>, <span class="number">3</span>).equals(<span class="string">&quot;SUM&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (string.substring(<span class="number">0</span>, <span class="number">3</span>).equals(<span class="string">&quot;STD&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> std(c);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> avg(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a[<span class="number">1</span>]; i &lt;= a[<span class="number">3</span>]; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> a[<span class="number">2</span>]; j &lt;= a[<span class="number">4</span>]; j++) &#123;<span class="comment">// 根据坐标范围就所有的集合</span></span><br><span class="line">                <span class="keyword">if</span> (s[i][j].charAt(<span class="number">0</span>) &lt; <span class="string">&#x27;0&#x27;</span> || s[i][j].charAt(<span class="number">0</span>) &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    ans += convert(s[i][j]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ans += Double.parseDouble(s[i][j]);<span class="comment">// 转换为 double 型</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> sum(a);</span><br><span class="line">        <span class="type">double</span> <span class="variable">cnt</span> <span class="operator">=</span> (a[<span class="number">3</span>] - a[<span class="number">1</span>] + <span class="number">1</span>) * (a[<span class="number">4</span>] - a[<span class="number">2</span>] + <span class="number">1</span>);<span class="comment">// 根据方格数求出个数</span></span><br><span class="line">        <span class="keyword">return</span> ans / cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">std</span><span class="params">(<span class="type">int</span> a[])</span> &#123;<span class="comment">// 求方差</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ave</span> <span class="operator">=</span> avg(a);</span><br><span class="line">        <span class="type">double</span> <span class="variable">cnt</span> <span class="operator">=</span> (a[<span class="number">3</span>] - a[<span class="number">1</span>] + <span class="number">1</span>) * (a[<span class="number">4</span>] - a[<span class="number">2</span>] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a[<span class="number">1</span>]; i &lt;= a[<span class="number">3</span>]; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> a[<span class="number">2</span>]; j &lt;= a[<span class="number">4</span>]; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i][j].charAt(<span class="number">0</span>) &lt; <span class="string">&#x27;0&#x27;</span> || s[i][j].charAt(<span class="number">0</span>) &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    ans += (convert(s[i][j]) - ave) * (convert(s[i][j]) - ave);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ans += (Double.parseDouble(s[i][j]) - ave) * (Double.parseDouble(s[i][j]) - ave);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(ans / cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2014- 年"><a class="markdownIt-Anchor" href="#2014- 年"></a> 2014 年</h2>
<h3 id="国王的遗产"><a class="markdownIt-Anchor" href="# 国王的遗产"></a> 国王的遗产</h3>
<p><strong>题目：</strong><br />
国王 K 有 6 个儿子。在临终前，K 国王立下遗嘱：国王的一批牛作为遗产要分给他的 6 个儿子。<br />
其中，大儿子分 1/4，二儿子 1/5，三儿子 1/6，…<br />
直到小儿子分 1/9。<br />
牛是活的，不能把一头牛切开分。<br />
最后还剩下 11 头牛，分给管家。<br />
请计算国王这批遗产中一共有多少头牛。</p>
<p><strong>思路：</strong></p>
<ol>
<li>首先牛必须是整只，所以用最后的数取整，但比例必须用双精度存储</li>
<li>用 1 减去每个儿子所占的比例，就是最后 11 头牛剩余的，用<code>11/ 所占比 = 总数</code></li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span> - <span class="number">1</span> / <span class="number">4.0</span> - <span class="number">1</span> / <span class="number">5.0</span> - <span class="number">1</span> / <span class="number">6.0</span> - <span class="number">1</span> / <span class="number">7.0</span> - <span class="number">1</span> / <span class="number">8.0</span> - <span class="number">1</span> / <span class="number">9.0</span>;<span class="comment">//11 头牛所占的比例</span></span><br><span class="line">    System.out.println(<span class="number">11</span> / m);<span class="comment">//11 除以自身的比例等于全部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六角幻方"><a class="markdownIt-Anchor" href="# 六角幻方"></a> 六角幻方</h3>
<p><strong>题目：</strong><br />
把 1 2 3 … 19 共 19 个整数排列成六角形状，如下：<br />
要求每个直线上的数字之和必须相等。共有 15 条直线哦！<br />
预先填好了 2 个数字，第一行的头两个数字是：15 13。<br />
请你填写出中间一行的 5 个数字。数字间用空格分开</p>
<p><strong>思路：</strong></p>
<ol>
<li>在不改变前两个数字的情况下进行全排列</li>
<li>剪枝，每遍历完一行，就进行横向和斜向的对比</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MagicHexagon</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">15</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        dfs(<span class="number">2</span>);</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] != a[<span class="number">3</span>] + a[<span class="number">4</span>] + a[<span class="number">5</span>] + a[<span class="number">6</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">12</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] != a[<span class="number">7</span>] + a[<span class="number">8</span>] + a[<span class="number">9</span>] + a[<span class="number">10</span>] + a[<span class="number">11</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] != a[<span class="number">0</span>] + a[<span class="number">3</span>] + a[<span class="number">7</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] != a[<span class="number">2</span>] + a[<span class="number">6</span>] + a[<span class="number">11</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] != a[<span class="number">12</span>] + a[<span class="number">13</span>] + a[<span class="number">14</span>] + a[<span class="number">15</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] != a[<span class="number">1</span>] + a[<span class="number">4</span>] + a[<span class="number">8</span>] + a[<span class="number">12</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] != a[<span class="number">1</span>] + a[<span class="number">5</span>] + a[<span class="number">10</span>] + a[<span class="number">15</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">19</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] != a[<span class="number">16</span>] + a[<span class="number">17</span>] + a[<span class="number">18</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] != a[<span class="number">7</span>] + a[<span class="number">12</span>] + a[<span class="number">16</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] != a[<span class="number">3</span>] + a[<span class="number">8</span>] + a[<span class="number">13</span>] + a[<span class="number">17</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] != a[<span class="number">0</span>] + a[<span class="number">4</span>] + a[<span class="number">9</span>] + a[<span class="number">14</span>] + a[<span class="number">18</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] != a[<span class="number">11</span>] + a[<span class="number">15</span>] + a[<span class="number">18</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] != a[<span class="number">6</span>] + a[<span class="number">10</span>] + a[<span class="number">14</span>] + a[<span class="number">17</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] != a[<span class="number">2</span>] + a[<span class="number">5</span>] + a[<span class="number">9</span>] + a[<span class="number">13</span>] + a[<span class="number">16</span>])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">7</span>; i &lt;= <span class="number">11</span>; i++)</span><br><span class="line">                System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &lt; <span class="number">19</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">            a[i] = a[m];</span><br><span class="line">            a[m] = t;</span><br><span class="line">            dfs(m + <span class="number">1</span>);</span><br><span class="line">            t = a[i];</span><br><span class="line">            a[i] = a[m];</span><br><span class="line">            a[m] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排列序数"><a class="markdownIt-Anchor" href="# 排列序数"></a> 排列序数</h3>
<p><strong>题目：</strong><br />
如果用 a b c d 这 4 个字母组成一个串，有 4!=24 种，如果把它们排个序，每个串都对应一个序号：</p>
<blockquote>
<p>abcd 0</p>
</blockquote>
<p>abdc 1<br />
acbd 2<br />
acdb 3<br />
adbc 4<br />
adcb 5<br />
bacd 6<br />
badc 7<br />
bcad 8<br />
bcda 9<br />
bdac 10<br />
bdca 11<br />
cabd 12<br />
cadb 13<br />
cbad 14<br />
cbda 15<br />
cdab 16<br />
cdba 17</p>
<p>现在有不多于 10 个两两不同的小写字母，给出它们组成的串，你能求出该串在所有排列中的序号吗？<br />
【输入格式】<br />
一行，一个串。<br />
【输出格式】<br />
一行，一个整数，表示该串在其字母所有排列生成的串中的序号。注意：最小的序号是 0。<br />
输入：<br />
bdca<br />
程序应该输出：<br />
11<br />
输入：<br />
cedab<br />
程序应该输出：<br />
70</p>
<p><strong>思路：</strong></p>
<ol>
<li>先用递归进行模拟，从 ACSII 码 97（全小写字母）开始遍历，记录 97+length 的 n 个字符，然后与输入的字符串进行比对</li>
<li>先模拟再放入递归中，以便于反向调换不至于影响顺序</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrangeNumber</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] mark = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">150</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">// 序号从零开始，所以计数初始值为 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        len = str.length();<span class="comment">// 记录字符串的长度</span></span><br><span class="line">        dfs(<span class="number">0</span>, str);</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, String end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (len == n) &#123;</span><br><span class="line">            count++;<span class="comment">// 序号 +1</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(res).trim();<span class="comment">// 将字符数组转换为字符串，没有 trim 会错误</span></span><br><span class="line">            <span class="keyword">if</span> (str.equals(end)) &#123;<span class="comment">// 等于输入的值说明模拟成功</span></span><br><span class="line">                System.out.println(count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">97</span>; i &lt; <span class="number">97</span> + len; i++) &#123;<span class="comment">// 字母全小写，从 ASCII 值 97 开始</span></span><br><span class="line">            <span class="keyword">if</span> (mark[i] == <span class="number">0</span>) &#123;<span class="comment">// 标记是否使用，防止一串字符中出现相同的字母</span></span><br><span class="line">                res[n] = ((<span class="type">char</span>) i);</span><br><span class="line">                mark[i] = <span class="number">1</span>;</span><br><span class="line">                dfs(n + <span class="number">1</span>, end);<span class="comment">// 先模拟后递归，到达出口后反向调换</span></span><br><span class="line">                mark[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2013- 年"><a class="markdownIt-Anchor" href="#2013- 年"></a> 2013 年</h2>
<h3 id="猜灯谜"><a class="markdownIt-Anchor" href="# 猜灯谜"></a> 猜灯谜</h3>
<p><strong>题目：</strong><br />
有一个灯谜公式：</p>
<blockquote>
<p>请猜谜 * 请猜谜 = 请边赏灯边猜</p>
</blockquote>
<p>若是用数字代替汉字，那么符合公式条件的“请猜谜”的三位数字是哪一个</p>
<p><strong>思路：</strong></p>
<ol>
<li>读入数字可以采用每位分开多层循环嵌套，方便后续的计算</li>
<li>枚举法对范围的判定：请猜谜的平方是一个六位数，所以从 317 开始至 999</li>
<li>取余法将六位数的所需判断位保存下来（取 X 位，就用 N%(X+1)/X）</li>
<li>在输出语句前加上双引号，使得整型直接按字符串输出<code>System.out.println(&quot;&quot; + a + b + c);</code></li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>; a &lt;= <span class="number">9</span>; a++) &#123;<span class="comment">// 从 317 开始结果才可能为六位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>; b &lt;= <span class="number">9</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != b) &#123;<span class="comment">//&quot; 请 &quot; 和 &quot; 猜 &quot; 必须不相同</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt;= <span class="number">9</span>; c++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> a * <span class="number">100</span> + b * <span class="number">10</span> + c;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">pownum</span> <span class="operator">=</span> num * num;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">shiwan</span> <span class="operator">=</span> pownum / <span class="number">100000</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">wan</span> <span class="operator">=</span> pownum % <span class="number">100000</span> / <span class="number">10000</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">shi</span> <span class="operator">=</span> pownum % <span class="number">100</span> / <span class="number">10</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> pownum % <span class="number">10</span>;<span class="comment">// 取 X 位，就用 N%(X+1)/X</span></span><br><span class="line">                    <span class="keyword">if</span> (a == shiwan &amp;&amp; b == ge &amp;&amp; wan == shi)</span><br><span class="line">                        System.out.println(<span class="string">&quot;&quot;</span> + a + b + c);<span class="comment">// 通过加 &quot;&quot; 使 int 型输出为 String</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连续奇数的和"><a class="markdownIt-Anchor" href="# 连续奇数的和"></a> 连续奇数的和</h3>
<p><strong>题目：</strong><br />
任何数的立方都可以表示为连续奇数的和</p>
<blockquote>
<p>2<sup>3</sup>=8=3+5</p>
</blockquote>
<p>3<sup>3</sup>=27=7+9+11<br />
4<sup>3</sup>=64=1+3+···+15</p>
<p>那么 111<sup>3</sup>的连续奇数和表示法的第一个数字为？</p>
<p><strong>思路：</strong></p>
<ol>
<li>设立双循环嵌套，每个循环的变量为<code>i+=2</code>，这样确保每次的都是奇数，定义 sum 将第二层循环的变量全部相加，当与 pow(111,3) 相等时，便输出第一层循环的变量值</li>
<li>采用等差数列的思维，奇数的求和公式为<code>Sn=n*n</code>，当全部的数列和减去前 N 项数列和的值与 pow(111,3) 相等时，就可以确定 N 为第几项，然后用奇数等差数列的求项公式<code>An=2*n-1</code>, 将起始项（第 N 项）的值求出</li>
<li>循环中进行判断当输出之后就可结束程序：<code>System.exit(0);</code></li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">111</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 方法一：枚举所有奇数项</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;<span class="comment">//i 每次加 2 确保为奇数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt;= n; j += <span class="number">2</span>) &#123;<span class="comment">// 让 j 的初始值等于 i</span></span><br><span class="line">            sum += j;<span class="comment">// 只要 sum&lt;=n 便一直加后边的奇数</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum == n) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                System.exit(<span class="number">0</span>);<span class="comment">// 直接退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 方法二：利用奇数等差数列</span></span><br><span class="line">    <span class="comment">// 奇数等差数列的求和公式：Sn=n*n; 求项：An=2*n-1;</span></span><br><span class="line">    <span class="comment">// 将所有的奇数排列在一起：1，3，5，7···，end</span></span><br><span class="line">    <span class="comment">// 从第 n 位开始一直到 end 的和 ==pow(111,3)，也就是 sum(1-end)-sum(1-(n-1))==pow(111,3)</span></span><br><span class="line">    <span class="comment">// 由此可以确定第 n 项的值，根据 An=2*n-1 得出具体的数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; <span class="number">3000</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j * j - (i - <span class="number">1</span>) * (i - <span class="number">1</span>) == n) &#123;</span><br><span class="line">                System.out.println(<span class="number">2</span> * i - <span class="number">1</span>);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迷宫"><a class="markdownIt-Anchor" href="# 迷宫"></a> 迷宫</h2>
<p><strong>题目：</strong><br />
定义一个 x*y 的地图，其中 0 表示通路，1 表示死路<br />
<strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * DFS 算法解决走迷宫问题</span></span><br><span class="line"><span class="comment">    * 0: 表示通路</span></span><br><span class="line"><span class="comment">    * 1: 表示死路</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">String</span> <span class="variable">shortestPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个迷宫地图</span></span><br><span class="line">    <span class="comment">// 0: 表示通路</span></span><br><span class="line">    <span class="comment">// 1: 表示死路</span></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[x][y];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; y; j++)</span><br><span class="line">            map[i][j] = sc.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 从矩阵的左上角位置开始搜索</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, map);</span><br><span class="line">    <span class="keyword">if</span> (shortestPath.length() != <span class="number">0</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot; 最短路线为：&quot;</span> + shortestPath);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">&quot; 没有找到路线！&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] s = shortestPath.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>[][] map)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 获得矩阵的大小</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> map.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> map[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// 设置结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果坐标越界，或者 maze[x][y]==1 表示遇到障碍</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; m - <span class="number">1</span> || y &gt; n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 表示遇到障碍</span></span><br><span class="line">    <span class="keyword">if</span> (map[x][y] == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 判断是否通路和越界</span></span><br><span class="line">    <span class="keyword">if</span> (x == m - <span class="number">1</span> &amp;&amp; y == n - <span class="number">1</span>) &#123; <span class="comment">// 判断是否抵达出口</span></span><br><span class="line">        path = path + <span class="string">&quot;(&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (shortestPath.length() == <span class="number">0</span> || shortestPath.length() &gt; path.length())</span><br><span class="line">            shortestPath = path;</span><br><span class="line">        System.out.println(<span class="string">&quot; 找到路线：&quot;</span> + path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> path;</span><br><span class="line">    path = path + <span class="string">&quot;(&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;)&quot;</span> + <span class="string">&quot;-&quot;</span>; <span class="comment">// 记录路线</span></span><br><span class="line">    map[x][y] = <span class="number">1</span>; <span class="comment">// 将走过的路标记</span></span><br><span class="line">    <span class="comment">// 向四个方向搜索</span></span><br><span class="line">    dfs(x + <span class="number">1</span>, y, map);  <span class="comment">// 向右搜索</span></span><br><span class="line">    dfs(x, y + <span class="number">1</span>, map);  <span class="comment">// 向下搜索</span></span><br><span class="line">    dfs(x, y - <span class="number">1</span>, map);  <span class="comment">// 向上搜索</span></span><br><span class="line">    dfs(x - <span class="number">1</span>, y, map);  <span class="comment">// 向左搜索</span></span><br><span class="line">    <span class="comment">// 将路线和标记恢复成上一次的状态</span></span><br><span class="line">    map[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 清除</span></span><br><span class="line">    path = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="背包"><a class="markdownIt-Anchor" href="# 背包"></a> 背包</h2>
<h3 id="0-1- 背包"><a class="markdownIt-Anchor" href="#0-1- 背包"></a> 0-1 背包</h3>
<p><strong>题目：</strong><br />
有 N 件物品和一个容量是 V 的背包。<font color="red">每件物品只能使用一次</font>。<br />
第 i 件物品的体积是 U<sub>i</sub>，价值是 W<sub>i</sub>。<br />
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。<br />
<em>输入格式</em><br />
第一行两个整数，N， V，用空格隔开，分别表示物品数量和背包容积。<br />
接下来 N 行，每行两个整数 u, w; ，用空格隔开，分别表示第 i 件物品的体积和价值。<br />
<em>输出格式</em><br />
输出一个整数，表示最大价值。<br />
<em>输入样例</em></p>
<blockquote>
<p>4 5</p>
</blockquote>
<p>1 2<br />
2 4<br />
3 4<br />
4 5</p>
<p><em>输出样例</em></p>
<blockquote>
<p>8</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> N=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> V=sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] v=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="type">int</span>[] w=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            v[i]=sc.nextInt();</span><br><span class="line">            w[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int[][] dp=new int[N+1][V+1];</span></span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=N;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j=0;j&lt;=V;j++)&#123;</span></span><br><span class="line">        <span class="comment">//         dp[i][j]=dp[i-1][j];</span></span><br><span class="line">        <span class="comment">//         if(j-v[i-1]&gt;=0)&#123;</span></span><br><span class="line">        <span class="comment">//             dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-v[i-1]]+w[i-1]);</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//  System.out.println(dp[N][V]);</span></span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[V+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            <span class="comment">// 从大到小遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[j]=Math.max(dp[j],dp[j-v[i-<span class="number">1</span>]]+w[i-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[V]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完全背包"><a class="markdownIt-Anchor" href="# 完全背包"></a> 完全背包</h3>
<p><strong>题目：</strong><br />
有 N 件物品和一个容量是 V 的背包。<font color="red">每件物品有无数件</font>。<br />
第 i 件物品的体积是 U<sub>i</sub>，价值是 W<sub>i</sub>。<br />
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。<br />
<em>输入格式</em><br />
第一行两个整数，N， V，用空格隔开，分别表示物品数量和背包容积。<br />
接下来 N 行，每行两个整数 u, w; ，用空格隔开，分别表示第 i 件物品的体积和价值。<br />
<em>输出格式</em><br />
输出一个整数，表示最大价值。<br />
<em>输入样例</em></p>
<blockquote>
<p>4 5</p>
</blockquote>
<p>1 2<br />
2 4<br />
3 4<br />
4 5</p>
<p><em>输出样例</em></p>
<blockquote>
<p>10</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> N=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> V=sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] v=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="type">int</span>[] w=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            v[i]=sc.nextInt();</span><br><span class="line">            w[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[V+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="comment">// 代码与 01 背包的区别，从小到大遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i])&#123;</span><br><span class="line">                    dp[j]=Math.max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[V]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重背包普通"><a class="markdownIt-Anchor" href="# 多重背包普通"></a> 多重背包（普通）</h3>
<p>每件物品有了个数，输入时输入三个值：体积、价值、数量</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> N=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> V=sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] v=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="type">int</span>[] w=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="type">int</span>[] s=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            v[i]=sc.nextInt();</span><br><span class="line">            w[i]=sc.nextInt();</span><br><span class="line">            s[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int[][] dp=new int[N+1][V+1];</span></span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=N;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j=0;j&lt;=V;j++)&#123;</span></span><br><span class="line">        <span class="comment">//         for(int k=0;k&lt;=s[i-1];k++)&#123;</span></span><br><span class="line">        <span class="comment">//             if(j&gt;=k*v[i-1])&#123;</span></span><br><span class="line">        <span class="comment">//                 dp[i][j]=Math.max(dp[i][j],dp[i-1][j-k*v[i-1]]+k*w[i-1]);</span></span><br><span class="line">        <span class="comment">//             &#125;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// System.out.println(dp[N][V]);</span></span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[V+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            <span class="comment">// 01 背包扩展，体积从大到小遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="comment">// 对物品数量进行遍历</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=s[i-<span class="number">1</span>];k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=k*v[i-<span class="number">1</span>])&#123;</span><br><span class="line">                        dp[j]=Math.max(dp[j],dp[j-k*v[i-<span class="number">1</span>]]+k*w[i-<span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[V]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重背包大型数据"><a class="markdownIt-Anchor" href="# 多重背包大型数据"></a> 多重背包（大型数据）</h3>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> N=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> V=sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] v=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="type">int</span>[] w=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="type">int</span>[] s=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            v[i]=sc.nextInt();</span><br><span class="line">            w[i]=sc.nextInt();</span><br><span class="line">            s[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;good&gt; goods=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 转化为 01 背包问题，把物品数量拆成二进制组合，组合数能取到 0~s 中任意一个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s[i];k=k*<span class="number">2</span>)&#123;</span><br><span class="line">                s[i]=s[i]-k;</span><br><span class="line">                goods.add(<span class="keyword">new</span> <span class="title class_">good</span>(k*v[i],k*w[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                goods.add(<span class="keyword">new</span> <span class="title class_">good</span>(s[i]*v[i],s[i]*w[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[V+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=goods.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=goods.get(i-<span class="number">1</span>).v)&#123;</span><br><span class="line">                    dp[j]=Math.max(dp[j],dp[j-goods.get(i-<span class="number">1</span>).v]+goods.get(i-<span class="number">1</span>).w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[V]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">good</span>&#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">good</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.v=v;</span><br><span class="line">        <span class="built_in">this</span>.w=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="混合背包"><a class="markdownIt-Anchor" href="# 混合背包"></a> 混合背包</h3>
<p><strong>题目：</strong><br />
有 N 件物品和一个容量是 V 的背包。<br />
物品一共有三类</p>
<ol>
<li>第一类物品只能用一次</li>
<li>第二类物品可以用无限次</li>
<li>第三类物品可以用 i 次</li>
</ol>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。<br />
<em>输入格式</em><br />
第一行两个整数，N， V，用空格隔开，分别表示物品数量和背包容积。<br />
接下来 N 行，每行两个整数 u, w, s; ，用空格隔开，分别表示第 i 件物品的体积、价值和数量。</p>
<ul>
<li>s==-1, 表示物品只能用一次</li>
<li>s==0, 表示物品可以用无限次</li>
<li>s&gt;0, 表示物品可以使用 s 次</li>
</ul>
<p><em>输出格式</em><br />
输出一个整数，表示最大价值。<br />
<em>输入样例</em></p>
<blockquote>
<p>4 5</p>
</blockquote>
<p>1 2 -1<br />
2 4 1<br />
3 4 0<br />
4 5 2</p>
<p><em>输出样例</em></p>
<blockquote>
<p>8</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> N=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> V=sc.nextInt();</span><br><span class="line">        List&lt;Thing&gt; things=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="type">int</span> v=sc.nextInt();</span><br><span class="line">            <span class="type">int</span> w=sc.nextInt();</span><br><span class="line">            <span class="type">int</span> s=sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(s&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                things.add(<span class="keyword">new</span> <span class="title class_">Thing</span>(-<span class="number">1</span>,v,w));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="number">0</span>)&#123;</span><br><span class="line">                things.add(<span class="keyword">new</span> <span class="title class_">Thing</span>(<span class="number">0</span>,v,w));</span><br><span class="line">            <span class="comment">// 多重背包转化为 01 背包</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s;k=k*<span class="number">2</span>)&#123;</span><br><span class="line">                    s=s-k;</span><br><span class="line">                    things.add(<span class="keyword">new</span> <span class="title class_">Thing</span>(-<span class="number">1</span>,k*v,k*w));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    things.add(<span class="keyword">new</span> <span class="title class_">Thing</span>(-<span class="number">1</span>,s*v,s*w));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[V+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=things.size();i++)&#123;</span><br><span class="line">            <span class="type">int</span> kind=things.get(i-<span class="number">1</span>).kind;</span><br><span class="line">            <span class="keyword">if</span>(kind&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 01 背包，体积从大到小遍历</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=things.get(i-<span class="number">1</span>).v;j--)&#123;</span><br><span class="line">                    dp[j]=Math.max(dp[j],dp[j-things.get(i-<span class="number">1</span>).v]+things.get(i-<span class="number">1</span>).w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 完全背包，体积从小到大遍历</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=things.get(i-<span class="number">1</span>).v;j&lt;=V;j++)&#123;</span><br><span class="line">                    dp[j]=Math.max(dp[j],dp[j-things.get(i-<span class="number">1</span>).v]+things.get(i-<span class="number">1</span>).w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[V]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span>&#123;</span><br><span class="line">    <span class="type">int</span> kind;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thing</span><span class="params">(<span class="type">int</span> kind,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.kind=kind;</span><br><span class="line">        <span class="built_in">this</span>.v=v;</span><br><span class="line">        <span class="built_in">this</span>.w=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT 甲级 - 数学问题</title>
    <url>/pat_level_a-math_problem/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p> 数学可以提高思维能力，而算法最需要的就是思维能力，所以数学和算法题总是绕不开的，PAT 中就有专门的数学类型题但只是将需要大量计算的数学题用算法的方式进行解答，但还是有一部分题做到了很好的结合。举个不恰当的例子：圆的面积就是将其不断分割成可以用来计算的矩形和三角形，按照数学的思路就是用圆周率，而算法就是模拟切割的过程不断计算（当然实际肯定不是这样），不过计算机被创造出来的初衷好像就是做这种事 </p>
<span id="more"></span>
<h3 id="思想解释"><a class="markdownIt-Anchor" href="# 思想解释"></a> 思想解释 </h3>
<h4 id="简单数学"><a class="markdownIt-Anchor" href="# 简单数学"></a> 简单数学 </h4>
<p> 一些不需要算法，仅仅使用基础数学知识的问题，一般考察的逻辑数理能力 </p>
<h4 id="公约公倍数"><a class="markdownIt-Anchor" href="# 公约公倍数"></a> 公约公倍数 </h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 求最大公约数 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 最小公倍数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>×</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a×b)/gcd(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></p>
<h4 id="分数"><a class="markdownIt-Anchor" href="# 分数"></a> 分数 </h4>
<p> 分数的存储一般使用结构体的方式 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> up,down;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 至于其运算也是使用不同的公式对分数的分子分母进行操作 </p>
<p> 分数许多情况下需要化简，其化简过程有三个：</p>
<ol>
<li>
<p> 判断 down 是否为负数，是则使分子和分母都变为其相反数 </p>
</li>
<li>
<p> 判断分子是否为 0，是则分母化为 1</p>
</li>
<li>
<p> 求分子和分母的绝对值是否有最大公约数，有则转换为除公约数的情况 </p>
</li>
</ol>
<p> 分数的输出有多种情况，输出前必须化简 </p>
<ul>
<li>
<p> 需要判断分母是否为 1，是则输出整数 </p>
</li>
<li>
<p> 分子的绝对值大于分母，则是一个假分数，输出带分数的形式 </p>
</li>
</ul>
<h4 id="素数"><a class="markdownIt-Anchor" href="# 素数"></a> 素数 </h4>
<p> 判断代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sqr = (<span class="type">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span> * a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= sqr; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 手动表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prime</span><span class="params">(<span class="number">50000</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt; <span class="number">50000</span>; i++)</span><br><span class="line">&#123; <span class="comment">// 根据特性，将不是素数的置为 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j * i &lt; <span class="number">50000</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        prime[j * i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="质因子"><a class="markdownIt-Anchor" href="# 质因子"></a> 质因子 </h4>
<p> 一个整数被分解成一个或多个质数的乘积，但是质因子相乘到 29 时 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>3</mn><mo>×</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>×</mo><mn>29</mn></mrow><annotation encoding="application/x-tex">2×3×···×29</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">×</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">×</span><span class="mord">2</span><span class="mord">9</span></span></span></span>) 就已经超过了 int 型的范围，所以保存因子的数组大小为 10 即可 </p>
<h4 id="大数存储与运算"><a class="markdownIt-Anchor" href="# 大数存储与运算"></a> 大数存储与运算 </h4>
<p> 大数使用读入字符串，反向存储到 int 数组中，运算根据规则定义即可 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bign</span> <span class="comment">// 定义大数结构体 </span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num[<span class="number">1000</span>], len;</span><br><span class="line">    <span class="built_in">bign</span>() <span class="comment">// 析构函数，使每次定义时初始化 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in">sizeof</span>(num));</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">change</span><span class="params">(string str)</span> <span class="comment">// 输入转换为大数形式 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    bign temp;</span><br><span class="line">    temp.len = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; temp.len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp.num[i] = str[temp.len - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 逆向非零赋值 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(bign a, bign b)</span> <span class="comment">// 比较大小，A 大返回 1，B 大返回 -1，相等返回 0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.len &gt; b.len) <span class="comment">//A 的长度大于 B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.len &gt; b.len) <span class="comment">//A.length&lt;B.length</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 长度相同 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;                            <span class="comment">// 从高位到低位比较 </span></span><br><span class="line">            <span class="keyword">if</span> (a.num[i] &gt; b.num[i]) <span class="comment">// 只要有一个大就是大 </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.num[i] &lt; b.num[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 全部排除为相等 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(bign bignum)</span> <span class="comment">// 输出 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = bignum.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; bignum.num[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">multi</span><span class="params">(bign a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    bign c;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = a.num[i] * b + carry;</span><br><span class="line">        c.num[c.len++] = temp % <span class="number">10</span>;</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (carry != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c.num[c.len++] = carry % <span class="number">10</span>;</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    bign bigtemp = <span class="built_in">change</span>(str);</span><br><span class="line">    <span class="built_in">show</span>(bigtemp);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="类型练习"><a class="markdownIt-Anchor" href="# 类型练习"></a> 类型练习 </h3>
<h4 id="1069"><a class="markdownIt-Anchor" href="#1069"></a> 1069</h4>
<p><strong> 题目：The Black Hole of Numbers</strong></p>
<p>For any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number <code>6174</code> – the <strong>black hole</strong> of 4-digit numbers. This number is named Kaprekar Constant.</p>
<p>For example, start from <code>6767</code>, we’ll get:</p>
<blockquote>
<p>7766 - 6677 = 1089<br />
9810 - 0189 = 9621<br />
9621 - 1269 = 8352<br />
8532 - 2358 = 6174<br />
7641 - 1467 = 6174<br />
… …</p>
</blockquote>
<p>Given any 4-digit number, you are supposed to illustrate the way it gets into the black hole.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case which gives a positive integer N in the range <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,10^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p><em>Output Specification:</em></p>
<p>If all the 4 digits of N are the same, print in one line the equation <code>N - N = 0000</code>. Else print each step of calculation in a line until <code>6174</code> comes out as the difference. All the numbers must be printed as 4-digit numbers.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>6767</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>7766 - 6677 = 1089<br />
9810 - 0189 = 9621<br />
9621 - 1269 = 8352<br />
8532 - 2358 = 6174</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>2222</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>2222 - 2222 = 0000</p>
</blockquote>
<p><strong> 思路：</strong> 使用字符串的形式进行输入，对字符串进行升序和降序排序，转换为整数求结果，再将结果转换为字符串判断是否为 6174 或 0000</p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">// 递减排序 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    str.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">4</span> - str.<span class="built_in">length</span>(), <span class="string">&#x27;0&#x27;</span>);<span class="comment">// 不足 4 位前面补 0</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        string a = str, b = str;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), cmp);<span class="comment">// 降序排序 </span></span><br><span class="line">        <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());<span class="comment">// 升序排序 </span></span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">stoi</span>(a) - <span class="built_in">stoi</span>(b);<span class="comment">// 转换求值 </span></span><br><span class="line">        str = <span class="built_in">to_string</span>(result);<span class="comment">// 再转为字符串 </span></span><br><span class="line">        str.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">4</span> - str.<span class="built_in">length</span>(), <span class="string">&#x27;0&#x27;</span>);<span class="comment">// 补零 </span></span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (str != <span class="string">&quot;6174&quot;</span> &amp;&amp; str != <span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    <span class="built_in">syste</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1104"><a class="markdownIt-Anchor" href="#1104"></a> 1104</h4>
<p><strong> 题目：Sum of Number Segments</strong></p>
<p>Given a sequence of positive numbers, a segment is defined to be a consecutive subsequence. For example, given the sequence {0.1, 0.2, 0.3, 0.4}, we have 10 segments: (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) and (0.4).</p>
<p>Now given a sequence, you are supposed to find the sum of all the numbers in all the segments. For the previous example, the sum of all the 10 segments is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.1</mn><mo>+</mo><mn>0.3</mn><mo>+</mo><mn>0.6</mn><mo>+</mo><mn>1.0</mn><mo>+</mo><mn>0.2</mn><mo>+</mo><mn>0.5</mn><mo>+</mo><mn>0.9</mn><mo>+</mo><mn>0.3</mn><mo>+</mo><mn>0.7</mn><mo>+</mo><mn>0.4</mn><mo>=</mo><mn>5.0</mn></mrow><annotation encoding="application/x-tex">0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">.</span><span class="mord">0</span></span></span></span>.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N, the size of the sequence which is no more than 105. The next line contains N positive numbers in the sequence, each no more than 1.0, separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in one line the sum of all the numbers in all the segments, accurate up to 2 decimal places.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>4<br />
0.1 0.2 0.3 0.4</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>5.00</p>
</blockquote>
<p><strong> 思路：</strong>  找出每个数字在不同片段出现的次数，规律为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i×(n+1-i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>，注意精度可能不足 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; </span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        sum += (<span class="type">long</span> <span class="type">long</span>)(temp * <span class="number">1000</span>) * i * (n - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>, sum / <span class="number">1000.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1008"><a class="markdownIt-Anchor" href="#1008"></a> 1008</h4>
<p><strong> 题目：Elevator</strong></p>
<p>The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.</p>
<p>For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print the total time on a single line.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>3 2 3 1</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>41</p>
</blockquote>
<p><strong> 思路：</strong> 循环处理，根据大小关系处理上楼下楼，每次更新 now 代表的楼层 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>, ans = <span class="number">0</span>, temp;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= now)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="number">6</span> * (temp - now) + <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; now)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="number">4</span> * (now - temp) + <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="1049"><a class="markdownIt-Anchor" href="#1049"></a> 1049</h4>
<p><strong> 题目：Counting Ones</strong></p>
<p>The task is simple: given any positive integer N, you are supposed to count the total number of 1’s in the decimal form of the integers from 1 to N. For example, given N being 12, there are five 1’s in 1, 10, 11, and 12.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case which gives the positive <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><msup><mn>2</mn><mn>30</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤2^{30})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print the number of 1’s in one line.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>12</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>5</p>
</blockquote>
<p><strong> 思路：</strong> 直接循环必然超时，总结规律：从第一位（个位）到最高位，设 now 为当前位的数字，left 为 now 左边的所有数字构成的数字，right 是 now 右边的所有数字构成的数字。只需要一次次累加对于当前位 now 来说可能出现 1 的个数，然后把它们累加即可。a 表示当前的个位为 1，十位为 10，百位为 100 类推。</p>
<p> 对于 now，有三种情况：</p>
<ol>
<li>
<p>now == 0 : 那么 ans += left * a; // 因为 now==0 说明 now 位只有在 left 从 0~left-1 的时候会产生 1，所以会产生 left 次，但是又因为右边会重复从 0~999… 出现 a 次 </p>
</li>
<li>
<p>now == 1 : ans += left * a + right + 1;//now = 1 的时候就要比上一步多加一个当 now 为 1 的时候右边出现 0~right 个数导致的 now 为 1 的次数 </p>
</li>
<li>
<p>now &gt;= 2 : ans += (left + 1) * a;//now 大于等于 2 就左边 0~left 的时候会在 now 位置产生 1，所以会产生 left 次，但是又因为右边会重复从 0~999… 出现 a 次 </p>
</li>
</ol>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, a = <span class="number">1</span>, now = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n / a)</span><br><span class="line">    &#123;</span><br><span class="line">        left = n / (a * <span class="number">10</span>), now = n / a % <span class="number">10</span>, right = n % a;</span><br><span class="line">        <span class="keyword">if</span> (now == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += left * a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (now == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += left * a + right + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans += (left + <span class="number">1</span>) * a;</span><br><span class="line">        &#125;</span><br><span class="line">        a *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1081"><a class="markdownIt-Anchor" href="#1081"></a> 1081</h4>
<p><strong> 题目：Rational Sum</strong></p>
<p>Given N rational numbers in the form <code>numerator/denominator</code>, you are supposed to calculate their sum.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case starts with a positive integer N (≤100), followed in the next line N rational numbers <code>a1/b1 a2/b2 ...</code> where all the numerators and denominators are in the range of <strong>long int</strong>. If there is a negative number, then the sign must appear in front of the numerator.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, output the sum in the simplest form <code>integer numerator/denominator</code> where <code>integer</code> is the integer part of the sum, <code>numerator</code> &lt; <code>denominator</code>, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>5<br />
2/5 4/15 1/30 -2/60 8/3</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>3 1/3</p>
</blockquote>
<p><strong> 思路：</strong> 根据文首分数的处理思路，对其进行处理即可 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? <span class="built_in">abs</span>(a) : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n, a, b, suma = <span class="number">0</span>, sumb = <span class="number">1</span>, gcdvalue;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld/%lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        gcdvalue = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">        a = a / gcdvalue;</span><br><span class="line">        b = b / gcdvalue;</span><br><span class="line">        suma = a * sumb + suma * b;</span><br><span class="line">        sumb = b * sumb;</span><br><span class="line">        gcdvalue = <span class="built_in">gcd</span>(suma, sumb);</span><br><span class="line">        sumb = sumb / gcdvalue;</span><br><span class="line">        suma = suma / gcdvalue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> integer = suma / sumb;</span><br><span class="line">    suma = suma - (sumb * integer);</span><br><span class="line">    <span class="keyword">if</span> (integer != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, integer);</span><br><span class="line">        <span class="keyword">if</span> (suma != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (suma != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>, suma, sumb);</span><br><span class="line">    <span class="keyword">if</span> (integer == <span class="number">0</span> &amp;&amp; suma == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1088"><a class="markdownIt-Anchor" href="#1088"></a> 1088</h4>
<p><strong> 题目：Rational Arithmetic</strong></p>
<p>For two rational numbers, your task is to implement the basic arithmetics, that is, to calculate their sum, difference, product and quotient.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case, which gives in one line the two rational numbers in the format <code>a1/b1 a2/b2</code> . The numerators and the denominators are all in the range of long int. If there is a negative sign, it must appear only in front of the numerator. The denominators are guaranteed to be non-zero numbers.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in 4 lines the sum, difference, product and quotient of the two rational numbers, respectively. The format of each line is <code>number1 operator number2 = result</code> . Notice that all the rational numbers must be in their simplest form <code>k a/b</code> , where <code>k</code> is the integer part, and <code>a/b</code> is the simplest fraction part. If the number is negative, it must be included in a pair of parentheses. If the denominator in the division is zero, output <code>Inf</code> as the result. It is guaranteed that all the output integers are in the range of <strong>long int</strong>.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>2/3 -4/2</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>2/3 + (-2) = (-1 1/3)<br />
2/3 - (-2) = 2 2/3<br />
2/3 * (-2) = (-1 1/3)<br />
2/3 / (-2) = (-1/3)</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>5/3 0/6</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>1 2/3 + 0 = 1 2/3<br />
1 2/3 - 0 = 1 2/3<br />
1 2/3 * 0 = 0<br />
1 2/3 / 0 = Inf</p>
</blockquote>
<p><strong> 思路：</strong> 使用上方分数思想编写不同的算法函数进行运算即可，这里采用的是柳神代码 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a, b, c, d; </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> t1, <span class="type">long</span> <span class="type">long</span> t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t2 == <span class="number">0</span> ? t1 : <span class="built_in">gcd</span>(t2, t1 % t2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">long</span> <span class="type">long</span> m, <span class="type">long</span> <span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m * n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, n == <span class="number">0</span> ? <span class="string">&quot;Inf&quot;</span> : <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> flag = ((m &lt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span>) || (m &gt; <span class="number">0</span> &amp;&amp; n &lt; <span class="number">0</span>));</span><br><span class="line">    m = <span class="built_in">abs</span>(m);</span><br><span class="line">    n = <span class="built_in">abs</span>(n);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x = m / n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, flag ? <span class="string">&quot;(-&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, x);</span><br><span class="line">    <span class="keyword">if</span> (m % n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    m = m - x * n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> t = <span class="built_in">gcd</span>(m, n);</span><br><span class="line">    m = m / t;</span><br><span class="line">    n = n / t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld%s&quot;</span>, m, n, flag ? <span class="string">&quot;)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld/%lld %lld/%lld&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">    <span class="built_in">func</span>(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; + &quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>(c, d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>(a * d + b * c, b * d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; - &quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>(c, d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>(a * d - b * c, b * d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; * &quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>(c, d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>(a * c, b * d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; / &quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>(c, d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>(a * d, b * c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1078"><a class="markdownIt-Anchor" href="#1078"></a> <strong>1078</strong></h4>
<p><strong> 题目：Hashing</strong></p>
<p>The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">H(key)=key%TSize</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> where TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.</p>
<p>Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains two positive numbers: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">MSize (≤10^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mi>M</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤MSize)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span> which are the user-defined table size and the number of input numbers, respectively. Then N distinct positive integers are given in the next line. All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print “-” instead.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>4 4<br />
10 6 4 15</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>0 1 4  -</p>
</blockquote>
<p><strong> 思路：</strong> 找到大于 Tsize 的最小的素数，然后使用二次探查法 </p>
<p> 如果 hashTable 里面 key % size 的下标对应的 hashTable 为 false, 说明这个下标没有被使用过，直接输出。否则 step 步长从 1 加到 size-1，一次次尝试是否能使 index = (key + step * step) % size; 所对应的位置没有元素，如果都没有找到就输出“-”，否则就输出这个找到的元素的位置 <br />
注意 是 (key + step * step) % size 而不是 ** (key % size + step * step)</p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size, n, hashTable[<span class="number">10100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> num)</span> <span class="comment">// 判断素数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= num; i++)</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span> <span class="comment">// 插入方法 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> step = <span class="number">0</span>; step &lt; size; step++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = (key + step * step) % size;</span><br><span class="line">        <span class="keyword">if</span> (hashTable[index] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hashTable[index] = <span class="number">1</span>;</span><br><span class="line">            cout &lt;&lt; index;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; size &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isprime</span>(size)) <span class="comment">// 找到第一个比 Tsize 大的素数 </span></span><br><span class="line">    &#123;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        cin &gt;&gt; key;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">insert</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1096"><a class="markdownIt-Anchor" href="#1096"></a> 1096</h4>
<p><strong> 题目：Consecutive Factors</strong></p>
<p>Among all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>5</mn><mo>×</mo><mn>6</mn><mo>×</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">3×5×6×7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>, where 5, 6, and 7 are the three consecutive numbers. Now given any positive N, you are supposed to find the maximum number of consecutive factors, and list the smallest sequence of the consecutive factors.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case, which gives the integer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&lt;</mo><mi>N</mi><mo>&lt;</mo><msup><mn>2</mn><mn>31</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(1&lt;N&lt;2^{31})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in the first line the maximum number of consecutive factors. Then in the second line, print the smallest sequence of the consecutive factors in the format <code>factor[1]*factor[2]*...*factor[k]</code> , where the factors are listed in increasing order, and 1 is NOT included.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>630</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>3<br />
5×6×7</p>
</blockquote>
<p><strong> 思路：</strong> 使用双重循环嵌套，模拟连续的长度，不论长度多少，当前乘积不能被 num 整除就不符合条件，相反，只要能够整除不论其他因子为多少都符合条件 </p>
<ul>
<li>
<p> 数据规模为 int 型的范围，但中间计算乘积时可能导致溢出，所以存储为 long long</p>
</li>
<li>
<p> 因子 1 不包含在范围中，第一层循环从 2 开始，然后将第一层的变量 i 作为第二层循环的起始因子，不断自增模拟 </p>
</li>
<li>
<p> 使用临时变量 temp（每次初始为 1）相乘第二层的循环变量 j，若 num 对 temp 不能整除，表示不符合条件跳出 </p>
</li>
</ul>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> num, temp; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    <span class="type">int</span> first = <span class="number">0</span>, len = <span class="number">0</span>, maxn = <span class="built_in">sqrt</span>(num) + <span class="number">1</span>; <span class="comment">// 乘积因子的最大值为 n 的开根 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxn; i++)               <span class="comment">// 控制起始因子 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;= maxn; j++) <span class="comment">// 控制连续因子 </span></span><br><span class="line">        &#123;</span><br><span class="line">            temp *= j;</span><br><span class="line">            <span class="keyword">if</span> (num % temp != <span class="number">0</span>) <span class="comment">// 不再符合跳出 </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j - i &gt; len) <span class="comment">// 每次更新最长长度 </span></span><br><span class="line">        &#123;</span><br><span class="line">            len = j - i;</span><br><span class="line">            first = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl</span><br><span class="line">             &lt;&lt; num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; first + i;</span><br><span class="line">            <span class="keyword">if</span> (i != len - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1059"><a class="markdownIt-Anchor" href="#1059"></a> 1059</h4>
<p><strong> 题目：Prime Factors</strong></p>
<p>Given any positive integer N, you are supposed to find all of its prime factors, and write them in the format <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mi>p</mi><msup><mn>1</mn><mrow><mi>k</mi><mn>1</mn></mrow></msup><mo>×</mo><mi>p</mi><msup><mn>2</mn><mrow><mi>k</mi><mn>2</mn></mrow></msup><mo>×</mo><mo>⋯</mo><mo>×</mo><mi>p</mi><msup><mi>m</mi><mrow><mi>k</mi><mi>m</mi></mrow></msup></mrow><annotation encoding="application/x-tex">N= p1^{k1}×p2^{k2}×⋯×pm^{km}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case which gives a positive integer N in the range of <strong>long int</strong>.</p>
<p><em>Output Specification:</em></p>
<p>Factor N in the format N <code>=</code> p1<code>^</code>k1<code>*</code>p2<code>^</code>k2<code>*</code>…<code>*</code>pm<code>^</code>km, where pi’s are prime factors of N in increasing order, and the exponent ki is the number of pi – hence when there is only one pi, ki is 1 and must <strong>NOT</strong> be printed out.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>97532468</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>97532468=2^2<em>11</em>17<em>101</em>1291</p>
</blockquote>
<p><strong> 思路：</strong> 建立素数表，遍历判断，符合条件整除当前因子后继续判断 </p>
<ul>
<li>
<p> 建立素数表：long int 的 sqrt 最大不超过 50000，也就是说因子只会在这里边产生，将数组初始值为 1，不符合条件的赋值为 0</p>
</li>
<li>
<p> 循环遍历，然后对每一个变量 i 进行素数判断，是素数就判断能否整除，能够整除在判断一次，判断当前因子出现了几次 </p>
</li>
</ul>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prime</span><span class="params">(<span class="number">50000</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 乘积因子不会大于 50000，建立素数表，初始为 1</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> num;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt; <span class="number">50000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j * i &lt; <span class="number">50000</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            prime[i * j] = <span class="number">0</span>; <span class="comment">// 将不是素数的标记为 0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> state = <span class="literal">false</span>; <span class="comment">// 有无因子输出标志 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">50000</span> &amp;&amp; num &gt;= <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;                          <span class="comment">// 指数 </span></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;                    <span class="comment">// 条件符合 </span></span><br><span class="line">        <span class="keyword">while</span> (prime[i] == <span class="number">1</span> &amp;&amp; num % i == <span class="number">0</span>) <span class="comment">// 是素数而且可以整除 </span></span><br><span class="line">        &#123;</span><br><span class="line">            num /= i;</span><br><span class="line">            cnt++;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (state)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; i;</span><br><span class="line">            state = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;^&#x27;</span> &lt;&lt; cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1023"><a class="markdownIt-Anchor" href="#1023"></a> 1023</h4>
<p><strong> 题目：Have Fun with Numbers</strong></p>
<p>Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again!</p>
<p>Now you are suppose to check if there are more numbers with this property. That is, double a given number with k digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.</p>
<p><em>Input Specification:</em></p>
<p>Each input contains one test case. Each case contains one positive integer with no more than 20 digits.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, first print in a line “Yes” if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or “No” if not. Then in the next line, print the doubled number.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>1234567899</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>Yes<br />
2469135798</p>
</blockquote>
<p><strong> 思路：</strong> 大数类的转换和乘法，使用标记数组进行每个字符次数的判断 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bignum</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num[<span class="number">25</span>], len;</span><br><span class="line">    <span class="built_in">bignum</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in">sizeof</span>(num));</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function">bignum <span class="title">add</span><span class="params">(bignum a, bignum b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    bignum c;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len || i &lt; b.len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = a.num[i] + b.num[i] + carry;</span><br><span class="line">        c.num[c.len++] = temp % <span class="number">10</span>;</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c.num[c.len++] = carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bignum <span class="title">multi</span><span class="params">(bignum a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    bignum c;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = a.num[i] * b + carry;</span><br><span class="line">        c.num[c.len++] = temp % <span class="number">10</span>;</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (carry != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c.num[c.len++] = carry % <span class="number">10</span>;</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">bool</span> p = <span class="literal">true</span>;</span><br><span class="line">    bignum bign;</span><br><span class="line">    bign.len = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bign.num[i] = str[bign.len - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        flag[bign.num[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    bignum result = <span class="built_in">multi</span>(bign, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; result.len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag[result.num[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bign.len != result.len)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[i])</span><br><span class="line">            &#123;</span><br><span class="line">                p = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = result.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; result.num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1024"><a class="markdownIt-Anchor" href="#1024"></a> 1024</h4>
<p><strong> 题目：Palindromic Number</strong></p>
<p>A number that will be the same when it is written forwards or backwards is known as a <strong>Palindromic Number</strong>. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.</p>
<p>Non-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. For example, if we start from 67, we can obtain a palindromic number in 2 steps: 67 + 76 = 143, and 143 + 341 = 484.</p>
<p>Given any positive integer N, you are supposed to find its paired palindromic number and the number of steps taken to find it.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case consists of two positive numbers N and K, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤10^{10})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is the initial numer and K (≤100) is the maximum number of steps. The numbers are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, output two numbers, one in each line. The first number is the paired palindromic number of N, and the second number is the number of steps taken to find the palindromic number. If the palindromic number is not found after K steps, just output the number obtained at the Kth step and K instead.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>67 3</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>484<br />
2</p>
</blockquote>
<p><strong> 思路：</strong> 将操作的方法独立编写，使用次数和是否回文作为循环终止条件进行 while 循环，最后输出 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bign</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">1000</span>], len;</span><br><span class="line">    <span class="built_in">bign</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in">sizeof</span>(num));</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">change</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign temp;</span><br><span class="line">    temp.len = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp.num[i] = str[temp.len - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a, bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len || i &lt; b.len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = a.num[i] + b.num[i] + carry;</span><br><span class="line">        c.num[c.len++] = temp % <span class="number">10</span>;</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c.num[c.len++] = carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(bign a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.num[i] != a.num[a.len - <span class="number">1</span> - i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; str &gt;&gt; n;</span><br><span class="line">    bign a = <span class="built_in">change</span>(str);</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; n &amp;&amp; <span class="built_in">judge</span>(a) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bign b = a;</span><br><span class="line">        <span class="built_in">reverse</span>(b.num, b.num + b.len);</span><br><span class="line">        a = <span class="built_in">add</span>(a, b);</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; k;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT 甲级 - 搜索和动规</title>
    <url>/pat_level_a-search_and_dp/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p> 因为当时备考比较匆忙，图和树的题只是粗略写了一下并没有整理，包括搜索中的 BFS 也没整理，搜索和动态规划这两部分的内容较少，便直接整合到一起了，后续就没了，当时参加 PAT 是在大三，那时候总觉得时间用不完，写了几个没什么技术含量的小东西之后就觉得没意思了，当时刷知乎看到陈越姥姥说 PAT 就等于计算机的托福啊，便一头扎进去准备了，中间因为自身原因放下了一段时间，导致后来成绩不理想（当时还收到 58 同城的面试邀请），但功不唐捐感觉还是学到了不少东西 </p>
<span id="more"></span>
<h2 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h2>
<h4 id="1103"><a class="markdownIt-Anchor" href="#1103"></a> 1103</h4>
<p><strong> 题目：Integer Factorization</strong></p>
<p>The K−P factorization of a positive integer N is to write N as the sum of the P-th power of K positive integers. You are supposed to write a program to find the K−P factorization of N for any positive integers N, K and P.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case which gives in a line the three positive integers N (≤400), K (≤N) and P (1&lt;P≤7). The numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each case, if the solution exists, output in the format:</p>
<blockquote>
<p>N = n[1]^P + … n[K]^P</p>
</blockquote>
<p>where <code>n[i]</code> (<code>i</code> = 1, …, <code>K</code> ) is the <code>i</code> -th factor. All the factors must be printed in non-increasing order.</p>
<p>Note: the solution may not be unique. For example, the 5-2 factorization of 169 has 9 solutions, such as 122+42+22+22+12, or 112+62+22+22+22, or more. You must output the one with the maximum sum of the factors. If there is a tie, the largest factor sequence must be chosen – sequence {a1, a2, ⋯, aK} is said to be <strong>larger</strong> than {b1, b2, ⋯, bK} if there exists 1≤L≤K such that ai=bi for i<L and aL>bL.</p>
<p>If there is no solution, simple output <code>Impossible</code> .</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>169 5 2</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>169 = 6^2 + 6^2 + 6^2 + 6^2 + 5^2</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>169 167 3</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>Impossible</p>
</blockquote>
<p><strong> 思路：</strong> 输入初始数据之后，就将所有能够符合条件的因子放入数组中，然后搜索模拟 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, K, P, maxsum = <span class="number">-1</span>; <span class="comment">// 定义一个底数和用来判断底数最大的序列 </span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; factor, ans, temp; <span class="comment">//factor 用来保存所有不超过 N 的因子，下标为底数，数据为 pow(index, P)</span></span><br><span class="line"><span class="comment">//ans 存储答案，temp 为 DFS 搜索过程中的临时序列存储 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">// 将所有小于 N 的因子存放到数组中 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp &lt;= N)</span><br><span class="line">    &#123;</span><br><span class="line">        factor.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        temp = (<span class="type">int</span>)<span class="built_in">pow</span>((<span class="type">double</span>)++i, (<span class="type">double</span>)P);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> nowK, <span class="type">int</span> sum, <span class="type">int</span> facsum)</span> <span class="comment">// 参数为下标，当前步，数据和与底数和 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum == N &amp;&amp; nowK == K) <span class="comment">// 当和与步数到达目标数值时判断 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (facsum &gt; maxsum) <span class="comment">// 输出底数和最大的一个 </span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = temp;</span><br><span class="line">            maxsum = facsum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; N || nowK &gt; K) <span class="comment">// 和或步数超过目标数值，表示不符合条件 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index - <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="comment">//factor[0]=0; 只是为了数据存储的条理性，不必参与运算 </span></span><br><span class="line">    &#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(index); <span class="comment">// 将当前下标放入后进行下一步搜索 </span></span><br><span class="line">        <span class="built_in">DFS</span>(index, nowK + <span class="number">1</span>, sum + factor[index], facsum + index);</span><br><span class="line">        temp.<span class="built_in">pop_back</span>(); <span class="comment">// 成功或失败后，回溯，在进行搜索 </span></span><br><span class="line">        <span class="built_in">DFS</span>(index - <span class="number">1</span>, nowK, sum, facsum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K &gt;&gt; P;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">DFS</span>(factor.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (maxsum == <span class="number">-1</span>) <span class="comment">// 只要不为 -1 说明有答案 </span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; N &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ans[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;^&quot;</span> &lt;&lt; P;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ans.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot;^&quot;</span> &lt;&lt; P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="最大子序列和"><a class="markdownIt-Anchor" href="# 最大子序列和"></a> 最大子序列和 </h2>
<h4 id="1007"><a class="markdownIt-Anchor" href="#1007"></a> 1007</h4>
<p><strong> 题目：Maximum Subsequence Sum</strong></p>
<p>Given a sequence of K integers {N1, N2, …, NK}. A continuous subsequence is defined to be {Ni, Ni+1, …, Nj} where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">1≤i≤j≤K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence {-2, 11, -4, 13, -5, -2}, its maximum subsequence is {11, -4, 13} with the largest sum being 20.</p>
<p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (≤10000). The second line contains K numbers, separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>10<br />
-10 1 2 3 4 -5 -23 3 7 -21</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>10 1 4</p>
</blockquote>
<p><strong> 思路：</strong>   使用动态规划的思想，将所有的子串和找出，求最大的即可 </p>
<ul>
<li>
<p> 需要判断输入的数据是否为全负数，如果全是负数，就是从头到尾的输出 </p>
</li>
<li>
<p> 保留最大子串时需要判断前面的子串和与当前数相加是否更大，如果没有，保留当前数字即可，否者将其继续放入子串序列后 </p>
</li>
<li>
<p> 还需保存起始与结束位置，位置的存储也分情况判断，如果当前数加到子序列后，那么这条子串的起始下标还是之前 <code>begin[i]=begin[i-1]</code>，如果从当前数开始开辟另一条子序列那么，当前的起始就是现在数字的下标 <code>begin[i]=i</code></p>
</li>
</ul>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> data[maxn], dp[maxn]; <span class="comment">// 存储数据和子串和 </span></span><br><span class="line"><span class="type">int</span> beg[maxn] = &#123;<span class="number">0</span>&#125;;      <span class="comment">// 记录当前以 i 为结尾的子串的起始下标 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; data[i];</span><br><span class="line">        <span class="keyword">if</span> (data[i] &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>; <span class="comment">// 只要有一个正数就可以进行运算 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="comment">// 如果全是负数 </span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0 &quot;</span> &lt;&lt; data[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; data[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="comment">// 状态转移方程 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i - <span class="number">1</span>] + data[i] &gt; data[i])</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + data[i];</span><br><span class="line">            beg[i] = beg[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = data[i];</span><br><span class="line">            beg[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> end = <span class="number">0</span>; <span class="comment">// 结束节点 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; dp[end])</span><br><span class="line">        &#123;</span><br><span class="line">            end = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[end] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; data[beg[end]] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; data[end];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="背包问题"><a class="markdownIt-Anchor" href="# 背包问题"></a> 背包问题 </h2>
<h4 id="1068"><a class="markdownIt-Anchor" href="#1068"></a> 1068</h4>
<p><strong> 题目：Find More Coins</strong></p>
<p>Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she must pay the exact amount. Since she has as many as 104 coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find some coins to pay for it.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains 2 positive numbers: <code>N</code> (≤ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>, the total number of coins) and <code>M</code> (≤ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">10^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>, the amount of money Eva has to pay). The second line contains <code>N</code> face values of the coins, which are all positive numbers. All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in one line the face values V1≤V2≤⋯≤Vk such that V1+V2+⋯+Vk= <code>M</code> . All the numbers must be separated by a space, and there must be no extra space at the end of the line. If such a solution is not unique, output the smallest sequence. If there is no solution, output “No Solution” instead.</p>
<p>Note: sequence {A[1], A[2], …} is said to be “smaller” than sequence {B[1], B[2], …} if there exists k≥1 such that A[i]=B[i] for all i&lt;k, and A[k] &lt; B[k].</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>8 9<br />
5 9 8 7 2 3 4 1</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>1 3 5</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>4 8<br />
7 2 4 3</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>No Solution</p>
</blockquote>
<p><strong> 思路：</strong>  最后输出字典序最小的结果，先将其从大到小进行排序，将正确的值反向进行查找，跳转放入数组输出 <br />
<strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M, coins[<span class="number">10010</span>]; </span><br><span class="line"><span class="type">int</span> dp[<span class="number">10010</span>], choice[<span class="number">10010</span>][<span class="number">110</span>]; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; coins[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(coins + <span class="number">1</span>, coins + N + <span class="number">1</span>, cmp); <span class="comment">// 将硬币从大到小排序 </span></span><br><span class="line">    <span class="comment">// 背包模板 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = M; j &gt;= coins[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &lt;= dp[j - coins[i]] + coins[i])</span><br><span class="line">            &#123;</span><br><span class="line">                choice[i][j] = <span class="literal">true</span>;</span><br><span class="line">                dp[j] = dp[j - coins[i]] + coins[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[M] != M)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="type">int</span> v = M, index = N;</span><br><span class="line">        <span class="keyword">while</span> (v &gt; <span class="number">0</span>) <span class="comment">// 反向查找，保证字典序最小 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (choice[index][v])</span><br><span class="line">            &#123;</span><br><span class="line">                arr.<span class="built_in">push_back</span>(coins[index]);</span><br><span class="line">                v -= coins[index];</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯普及题</title>
    <url>/lan_qiao-common_question/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p>之前参加蓝桥杯竞赛时候刷的算法题，蓝桥杯虽然一年比一年难，但是每年的题多少都有往届真题的影子，这些题不说是精华吧，但因为不是按类型刷的，所以题型涵盖度，知识点广度都是有的，我当时刷完之后就感觉有点进门槛了</p>
<span id="more"></span>
<h3 id="判断素数"><a class="markdownIt-Anchor" href="# 判断素数"></a> 判断素数</h3>
<p><strong>题目：</strong><br />
用筛选法求 0~N 之间的素数</p>
<p><em>输入：</em></p>
<blockquote>
<p>N</p>
</blockquote>
<p><em>输出：</em></p>
<blockquote>
<p>0~N 之间的所有素数，用回车进行分割</p>
</blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>直接使用 for() 循环在遍历每一个数，使用封装好的判断方法进行判断即可</li>
<li>使用素数打表的方式根据数据规模建立一个素数表，直接通过下标的进行输出即可</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> x)</span> &#123;<span class="comment">// 素数判断函数</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">// 使用单一出口</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= (<span class="type">int</span>) Math.sqrt((<span class="type">double</span>) x); i++) &#123;<span class="comment">// 因子在 2 到其开根之间</span></span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (judge(i)) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串 -io"><a class="markdownIt-Anchor" href="# 字符串 -io"></a> 字符串 I/O</h3>
<p><strong>题目：</strong></p>
<p><em>输入：</em><br />
首先输入一个不大于 100 的整数 N；<br />
之后输入大于 N 行的字符串，字符串可以包含空格；<br />
字符串个数不大于 1000。</p>
<p><em>输出：</em><br />
前 N 行按原样输出；后边的字符串按空格或回车以每行的形式输出且每行之间输出一个空行</p>
<p><strong>思路：</strong><br />
按行输入那就要用到<code>nextline()</code>, nextline 不同于 next 的一点就是：next 读取到空格就结束；nextline 读取到换行结束<br />
输出的字符串大于 N, 所以还需要使用 <code>hasnext()</code> 方法来判断不明确的输入</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        scanner.nextLine();<span class="comment">// 截取输入 N 之后的换行符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            System.out.println(str);<span class="comment">// 获取整行直接输出</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;<span class="comment">// 还有输入在进行</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="蛇形矩阵"><a class="markdownIt-Anchor" href="# 蛇形矩阵"></a> 蛇形矩阵</h3>
<p><strong>题目：</strong><br />
蛇形矩阵是由 1 开始的自然数依次排列成的一个矩阵上三角形。</p>
<p><em>输入：</em><br />
本题有多组数据，每组数据由一个正整数 N 组成 (N&lt;=100)</p>
<p><em>输出：</em><br />
对于每一组数据，输出一个 N 行的蛇形矩阵<br />
两组输出之间不要额外的空行，行尾不要多余的空格<br />
矩阵三角中同一行的数字用一个空格分开</p>
<p><em>输入样例：</em></p>
<blockquote>
<p>5</p>
</blockquote>
<p><em>输出样例：</em></p>
<blockquote>
<p>1 3 6 10 15<br />
2 5 9 14<br />
4 8 13<br />
7 12<br />
11</p>
</blockquote>
<p><strong>思路：</strong><br />
首先要搞清楚输出的规律：</p>
<ol>
<li>输出每行的列数以 N-1 递减</li>
<li>每列第一个数为 1 开始差为 +1 的等差数列</li>
<li>每行为 2 开始差为 +1 的等差数列</li>
<li>根据 2、3 条可以将行差与列差关联起来，然后双重循环嵌套</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">1</span>, subR = <span class="number">1</span>;<span class="comment">//row 为每行的首元素，subR 为每行首元素的差</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">// 反向遍历方便控制列数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">column</span> <span class="operator">=</span> row, subC = subR + <span class="number">1</span>;<span class="comment">// 每列首元素为每行的首元素，列差为行差 +1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                System.out.print(column);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j != i - <span class="number">1</span>) &#123;<span class="comment">// 注意行尾空格</span></span><br><span class="line">                    System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                column += subC;</span><br><span class="line">                subC++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            row += subR;</span><br><span class="line">            subR++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dna"><a class="markdownIt-Anchor" href="#dna"></a> DNA</h3>
<p><strong>题目：</strong><br />
输入包含多组测试数据，根据输入的组数和每组的数据打印出目标图形</p>
<p><em>输入：</em><br />
第一个整数 N(N&lt;=15) 表示组数，每组数据包含两个整数 a,b; 其中 a(3&lt;=a&lt;=39) 表示一个单位的 DNA 串的行数，恒为奇数。b(1&lt;=b&lt;=20) 表示重复度</p>
<p><em>输出：</em><br />
输出 DNA 的形状，每组输出间有空行，行尾没有多余的空格</p>
<p><em>样例输入：</em></p>
<blockquote>
<p>２<br />
3 1<br />
5 4</p>
</blockquote>
<p><em>样例输出：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">X X</span><br><span class="line"> X</span><br><span class="line">X X</span><br><span class="line"></span><br><span class="line">X   X</span><br><span class="line"> X X</span><br><span class="line">  X</span><br><span class="line"> X X</span><br><span class="line">X   X</span><br><span class="line"> X X</span><br><span class="line">  X</span><br><span class="line"> X X</span><br><span class="line">X   X</span><br><span class="line"> X X</span><br><span class="line">  X</span><br><span class="line"> X X</span><br><span class="line">X   X</span><br><span class="line"> X X</span><br><span class="line">  X</span><br><span class="line"> X X</span><br><span class="line">X   X</span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<ul>
<li>每组分布是有规律的：
<ul>
<li>X 的分布：<code>row == column || row == a - column - 1</code></li>
<li>空格的分布：<code>row &gt; column || row &lt; a - column - 1</code></li>
</ul>
</li>
<li>根据分布规律将每个字符存入 a 行 a 列的字符数组中，然后根据组数进行输出</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();<span class="comment">// 读取组数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != N--) &#123;<span class="comment">// 设置 N 组数据的循环</span></span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            a = scanner.nextInt();</span><br><span class="line">            b = scanner.nextInt();</span><br><span class="line">            <span class="type">char</span>[][] map = <span class="keyword">new</span> <span class="title class_">char</span>[a][a];<span class="comment">// 建立一个 a 行 a 列的字符数组</span></span><br><span class="line">            <span class="comment">// 根据分布规则进行赋值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == j || i == a - j - <span class="number">1</span>) &#123;</span><br><span class="line">                        map[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; j || i &lt; a - j - <span class="number">1</span>) &#123;</span><br><span class="line">                        map[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 出现两个 X 之后的字符赋予 N，这样的目的是输出时有所判断不会输出多余的空格</span></span><br><span class="line">                        map[i][j] = <span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : map[<span class="number">0</span>]) &#123;<span class="comment">// 输出第一行，第一行只可能为 X 或空格</span></span><br><span class="line">                System.out.print(c);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b; i++) &#123;<span class="comment">// 根据重复度从第二行开始输出</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; a; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">char</span> tempC : map[j]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (tempC != <span class="string">&#x27;N&#x27;</span>) &#123;<span class="comment">// 输出每行不为 N 的字符</span></span><br><span class="line">                            System.out.print(tempC);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ip- 判断"><a class="markdownIt-Anchor" href="#ip- 判断"></a> IP 判断</h3>
<p><strong>题目：</strong><br />
判断一个 IP 字符串的合法性。合法的 IP 是这样的形式：A.B.C.D，其中 A、B、C、D 均为位于 [0, 255] 中的整数<br />
为了简单起见，我们规定这四个整数中不允许有前导零存在，如 001 这种情况</p>
<p><em>输入：</em><br />
输入由多行组成，每行是一个字符串，输入由“End of file”结束</p>
<p><em>输出：</em><br />
对于每一个输入，单独输出一行，如果该字符串是合法的 IP，输出 Y，否则，输出 N</p>
<p><em>样例输入：</em></p>
<blockquote>
<p>1.2.3.4<br />
a.b.c.d<br />
267.43.64.12<br />
<a class="link"   href="http://12.34.56.bb">12.34.56.bb<i class="fas fa-external-link-alt"></i></a><br />
210.43.64.129<br />
-123.4.5.6</p>
</blockquote>
<p><em>样例输出：</em></p>
<blockquote>
<p>Y<br />
N<br />
Y<br />
N</p>
</blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>通过字符串获取一行用 <code>split()</code> 方法根据 ‘.’ 进行分割成字符串数组</li>
<li>判断时需要将字符串转换为 <code>Int</code> 型，可以使用 <code>Integer.parseInt(String s)</code> 的方法，但如果不全是数字会报错，加一个异常抛出，如果捕获到异常说明不符合 IP 规范，无异常进行范围的判断</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;End of file&quot;</span>.equals(str)) &#123;<span class="comment">// 遇到 End of file 程序结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] arr = str.split(<span class="string">&quot;\\.&quot;</span>);<span class="comment">// 分割使用转义字符的方式</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Integer.parseInt(s) &gt; <span class="number">255</span> || Integer.parseInt(s) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="comment">// 非数字转换出错，令 flag 为 false</span></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&#x27;N&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tom- 数"><a class="markdownIt-Anchor" href="#tom- 数"></a> Tom 数</h3>
<p><strong>题目：</strong><br />
正整数的各位数字之和被 Tom 称为 Tom 数<br />
输入一个数 N(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>&lt;</mo><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">N&lt;2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>)，求 N 的 Tom 数</p>
<p><em>输入：</em><br />
每行输入一个整数 N</p>
<p><em>输出：</em><br />
每行一个输出，对应 N 的各位数之和</p>
<p><em>样例输入：</em></p>
<blockquote>
<p>12345<br />
56123<br />
82</p>
</blockquote>
<p><em>样例输出：</em></p>
<blockquote>
<p>15<br />
17<br />
10</p>
</blockquote>
<p><strong>思路：</strong><br />
使用字符串获取每行输入的 N，使用 <code>charAt()</code> 的方式进行字符的遍历，遍历出的每个数字减去 0 的 ASCII 码获得这个数字本身的值相加即可</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">                sum += str.charAt(i)-<span class="string">&#x27;0&#x27;</span>;<span class="comment">// 这里的 -&#x27;0&#x27; 是减去 0 的 ASCII 码得到数字</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分糖果"><a class="markdownIt-Anchor" href="# 分糖果"></a> 分糖果</h3>
<p><strong>题目：</strong><br />
有 n 个小朋友围坐成一圈，老师给每个小朋友随机发偶数个糖果，然后进行下面的游戏：<br />
每个小朋友都把自己的糖果分一半给左手边的孩子。<br />
一轮分糖后，拥有奇数颗糖的孩子由老师补给 1 个糖果，从而变成偶数<br />
反复进行这个游戏，直到所有小朋友的糖果数都相同为止<br />
你的任务是预测在已知的初始糖果情形下，老师一共需要补发多少个糖果</p>
<p><em>输入：</em><br />
首先读入一个整数 N(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>&lt;</mo><mi>N</mi><mo>&lt;</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">2&lt;N&lt;100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>)，表示小朋友的人数<br />
接着是一行用空格分开的 N 个偶数（每个偶数不大于 1000，不小于 2)</p>
<p><em>输出：</em><br />
要求程序输出一个整数，表示老师需要补发的糖果数。</p>
<p><em>样例输入：</em></p>
<blockquote>
<p>3<br />
2 2 4</p>
</blockquote>
<p><em>样例输出：</em></p>
<blockquote>
<p>4</p>
</blockquote>
<p><strong>思路：</strong></p>
<ul>
<li>用数组的方式进行存储每人的糖果，分糖果时可以采用每人减半加后边人的一半，注意运算前先保存第一人的值</li>
<li>每个人手中的糖果数更新后进行奇数判断，进行相应操作</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            arr[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (judge(arr) != <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">frist</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                arr[i] = arr[i] / <span class="number">2</span> + arr[i + <span class="number">1</span>] / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    arr[i]++;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[N - <span class="number">1</span>] = arr[N - <span class="number">1</span>] / <span class="number">2</span> + frist / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[N - <span class="number">1</span>] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                arr[N - <span class="number">1</span>]++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[i] != temp[<span class="number">0</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断回文数"><a class="markdownIt-Anchor" href="# 判断回文数"></a> 判断回文数</h3>
<p><strong>题目：</strong><br />
本题要求你找到一些 5 位或 6 位的十进制回文数字<br />
满足要求：该数字的各个数位之和等于输入的整数</p>
<p><em>输入：</em><br />
一个正整数 n(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mo>&lt;</mo><mi>n</mi><mo>&lt;</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">10&lt;n&lt;100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>)，表示要求满足的数位和</p>
<p><em>输出：</em><br />
若干行，每行包含一个满足要求的 5 位或 6 位整数<br />
数字按从小到大的顺序排列<br />
如果没有满足条件的，输出：-1</p>
<p><strong>思路：</strong></p>
<ul>
<li>因为要对每位进行相加判断，用遍历的方式就效率太低了，要求的值为 5/6 位，可以嵌套三重循环，每层遍历 1~9，若能够达到以下条件就输出
<ul>
<li>五位：<code>2*a+2*b+c==n</code>那么就可以输出<code>a+b+c+b+a</code></li>
<li>六位同理</li>
</ul>
</li>
<li>从 1~9 进行遍历，自然满足从小到大的排列</li>
<li>设置一个计数器，在没有符合条件的值出现时输出 &quot;-1&quot;</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">2</span> * j + k == N) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;&quot;</span> + i + j + k + j + i);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">2</span> * j + <span class="number">2</span> * k == N) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;&quot;</span> + i + j + k + k + j + i);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数字游戏"><a class="markdownIt-Anchor" href="# 数字游戏"></a> 数字游戏</h3>
<p><strong>题目：</strong><br />
游戏的规则是这样的：栋栋和同学们一共 n 个人围坐在一圈。栋栋首先说出数字 1。接下来，坐在栋栋左手边的同学要说下一个数字 2。再下面的一个同学要从上一个同学说的数字往下数两个数说出来，也就是说 4。下一个同学要往下数三个数，说 7。依次类推。<br />
为了使数字不至于太大，栋栋和同学们约定，当在心中数到 k-1 时，下一个数字从 0 开始数。例如，当 k=13 时，栋栋和同学们报出的前几个数依次为：</p>
<blockquote>
<p>1、2、4、7、11、3、9、3、11</p>
</blockquote>
<p>游戏进行了一会儿，栋栋想知道，到目前为止，他所有说出的数字的总和是多少。<br />
栋栋说出的数依次为 1、7、9，和为 17</p>
<p><em>输入：</em><br />
输入的第一行包含三个整数 N、K、T，其中 N 和 K 的意义如上面所述，T 表示到目前为止栋栋一共说出的数字个数</p>
<p><em>输出：</em><br />
输出一行，包含一个整数，表示栋栋说出所有数的和</p>
<p><strong>思路：</strong></p>
<ul>
<li>栋栋一共说了 T 个数，所以只要把这 T 个数相加即可，无需管其他的数，已知 T1 为 1，这样只需 <code>for(i=1;i&lt;t;i++)</code> 执行 T-1 次即可</li>
<li>数字之间的差为 +1 的等差数列，这样可以找出规律求 T2、T3···
<ul>
<li>可以将所有的数看成 N 个人一组，总共 T 组，每组的指定报数就是就是上一组的指定数加当前组等差数列的和</li>
<li>公式为<code>T(m)=(((a+a+n-1)*n/2)+T(m-1))%k;</code></li>
</ul>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">K</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, An = <span class="number">1</span>, sum = An;<span class="comment">// 注意 int 型会溢出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; T - <span class="number">1</span>; i++) &#123;<span class="comment">// 已将首项加入 sum 中</span></span><br><span class="line">            An = (((a + a + N - <span class="number">1</span>) * N / <span class="number">2</span>) + An) % K;<span class="comment">// 按组加差</span></span><br><span class="line">            sum += An;</span><br><span class="line">            a += N;<span class="comment">// 将首项值加 N 作为下一组的首项</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分核桃"><a class="markdownIt-Anchor" href="# 分核桃"></a> 分核桃</h3>
<p><strong>题目：</strong><br />
有 3 个开发组，打算给每个组发一袋核桃要求是：</p>
<blockquote>
<ul>
<li>各组的核桃数量必须相同</li>
<li>各组内必须能平分核桃</li>
<li>尽量提供满足 1,2 条件的最小数量</li>
</ul>
</blockquote>
<p><em>输入：</em><br />
输入包含三个正整数 a、b、c 表示每个组正在加班的人数，用空格分开 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo>&lt;</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">a,b,c&lt;30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span>)</p>
<p><em>输出；</em><br />
输出一个正整数，表示每袋核桃的数量</p>
<p><strong>思路：</strong><br />
其实就是求最小公倍数，因为 a,b,c&lt;30，所以核桃数量最多不会超过<code>Math.pow(30,3)</code></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.pow(<span class="number">30</span>, <span class="number">3</span>); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= a &amp;&amp; i &gt;= b &amp;&amp; i &gt;= c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % a == <span class="number">0</span> &amp;&amp; i % b == <span class="number">0</span> &amp;&amp; i % c == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="蚂蚁感冒"><a class="markdownIt-Anchor" href="# 蚂蚁感冒"></a> 蚂蚁感冒</h3>
<p><strong>题目：</strong><br />
长 100 厘米的细长直杆子上有 n 蚂蚁。它们的头有的朝左，有的朝右<br />
每只蚂蚁都只能沿着杆子向前爬，速度是每秒 1cm<br />
当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行<br />
这些蚂蚁中，有 1 只蚂蚁感冒了，并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁<br />
请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒</p>
<p><em>输入：</em><br />
第一行输入一个整数 n(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><mi>n</mi><mo>&lt;</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">1&lt;n&lt;50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>)，表示蚂蚁的总数<br />
接着的一行是 n 个用空格分开的整数 Xi(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>&lt;</mo><msub><mi>X</mi><mi>i</mi></msub><mo>&lt;</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">-100&lt;X_i&lt;100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>)，Xi 的绝对值，表示蚂蚁离开杆子左边端点的距离。正值表示头朝右，负值表示头朝左，数据中不会出现 0 值，也不会出现两只蚂蚁占用同一位置。其中，第一个数据代表的蚂蚁感冒了</p>
<p><em>输出：</em><br />
要求输出 1 个整数，表示最后感冒蚂蚁的数目</p>
<p><em>样例输入：</em></p>
<blockquote>
<p>5<br />
-10 8 -20 12 25</p>
</blockquote>
<p><em>样例输出：</em></p>
<blockquote>
<p>3</p>
</blockquote>
<p><strong>思路：</strong></p>
<ul>
<li>每个蚂蚁速度相同，所以不存在后边的蚂蚁感冒追上前边蚂蚁的情况发生，而且与感冒的蚂蚁（叫做 X）相对的一定会被感染</li>
<li>被感染的蚂蚁与 X 没有任何区别，那么掉头可以看作两只蚂蚁碰头后穿过继续走</li>
<li>当 X 传染给相对蚂蚁后，被传染的蚂蚁继续走的情况下就又会传染给与他相对的其他蚂蚁，反之也相同</li>
<li>那么可以分左右进行判断，对 X 以外的蚂蚁依次读入，判断是否与 X 相对，除了相对会被传染外还有跟随在 X 后边的蚂蚁，当有被 X 传染的蚂蚁就表示跟随 X 的蚂蚁也会被传染，需要将跟随的蚂蚁数量记录下来，最后判断是否需要添加</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>, next = <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (--N != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (first &gt; <span class="number">0</span>) &#123;<span class="comment">// 当感冒的蚂蚁朝右</span></span><br><span class="line">                <span class="keyword">if</span> (Math.abs(temp) &gt; first &amp;&amp; temp &lt; <span class="number">0</span>) &#123;<span class="comment">// 与其相对时必感冒</span></span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; first &amp;&amp; temp &gt; <span class="number">0</span>) &#123;<span class="comment">// 在其后边跟随的</span></span><br><span class="line">                    next++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (first &lt; <span class="number">0</span>) &#123;<span class="comment">// 感冒蚂蚁朝左</span></span><br><span class="line">                <span class="keyword">if</span> (Math.abs(temp) &lt; Math.abs(first) &amp;&amp; temp &gt; <span class="number">0</span>) &#123;<span class="comment">// 与其相对时必感冒</span></span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; first) &#123;</span><br><span class="line">                    next++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += flag ? next : <span class="number">0</span>;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误票据"><a class="markdownIt-Anchor" href="# 错误票据"></a> 错误票据</h3>
<p><strong>题目：</strong><br />
某涉密单位下发了某种票据，并要在年终全部收回。每张票据有唯一的 ID 号，所有票据的 ID 号是连续的，但 ID 的开始数码是随机选定的。因为工作人员疏忽，在录入 ID 号的时候发生了一处错误，造成了某个 ID 断号，另外一个 ID 重号。通过编程，找出断号的 ID 和重号的 ID<br />
假设断号不可能发生在最大和最小号</p>
<p><em>输入：</em><br />
要求程序首先输入一个整数 N(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>&lt;</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">N&lt;100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>) 表示后面数据行数<br />
接着读入 N 行数据，每行数据长度不等，是用空格分开的若干个（不大于 100 个）正整数（不大于 100000)，请注意行内和行末可能有多余的空格，你的程序需要能处理这些空格<br />
每个整数代表一个 ID 号。</p>
<p><em>输出：</em><br />
要求程序输出 1 行，含两个整数 m 表示断号，n 表示重号</p>
<p><em>样例输入：</em></p>
<blockquote>
<p>2<br />
5 6 8 11 9<br />
10 12 9</p>
</blockquote>
<p><em>样例输出：</em></p>
<blockquote>
<p>7 9</p>
</blockquote>
<p><strong>思路：</strong><br />
主要解决的输入格式，因为是输入不同行，所以可以实例化 A、B 两个 <code>Scanner</code> 对象，用 A 获取每行，用 B 拆解 A 的每行数据，然后排序判断即可</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        scanner.nextLine();<span class="comment">// 抵消 N 后面的换行符</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10000</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, interrupt = <span class="number">0</span>, repeat = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(scanner.nextLine());<span class="comment">// 获取每行</span></span><br><span class="line">            <span class="keyword">while</span> (input.hasNext()) &#123;<span class="comment">// 遍历每行数据</span></span><br><span class="line">                arr[count++] = input.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr, <span class="number">0</span>, count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> arr[<span class="number">0</span>], i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (begin != arr[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] - arr[i - <span class="number">1</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">                    interrupt = arr[i] - <span class="number">1</span>;</span><br><span class="line">                    begin = arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    repeat = arr[i];</span><br><span class="line">                    begin = arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(interrupt + <span class="string">&quot; &quot;</span> + repeat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fj- 的字符串"><a class="markdownIt-Anchor" href="#fj- 的字符串"></a> FJ 的字符串</h3>
<p><strong>题目：</strong><br />
FJ 在沙盘上写了这样一些字符串：</p>
<blockquote>
<p>A1  =  “A”<br />
A2  =  “ABA”<br />
A3  =  “ABACABA”<br />
A4  =  “ABACABADABACABA”<br />
··· ···</p>
</blockquote>
<p><em>输入：</em><br />
仅有一个数：N(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>≤</mo><mn>26</mn></mrow><annotation encoding="application/x-tex">N≤26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">6</span></span></span></span>)</p>
<p><em>输出：</em><br />
请输出相应的字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">A_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，以一个换行符结束</p>
<p><em>样例输入：</em></p>
<blockquote>
<p>3</p>
</blockquote>
<p><em>样例输出：</em></p>
<blockquote>
<p>ABACABA</p>
</blockquote>
<p><strong>思路：</strong><br />
字符串变长，避免内存冗余的情况使用 <code>StringBuilder</code> 比较好，使用循环配合 ASCII 码即可，注意 <code>StringBuilder</code> 每次拼接返回的都是自身所以每次循环时保存一下之前的字符串（使用 <code>char[]</code> 数组节约空间）</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="type">char</span>[] temp = sb.toString().toCharArray();<span class="comment">//StringBuilder 每次拼接返回自身，先保存一下</span></span><br><span class="line">            sb.append((<span class="type">char</span>) (<span class="number">65</span> + i)).append(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分解质因数"><a class="markdownIt-Anchor" href="# 分解质因数"></a> 分解质因数</h3>
<p><strong>题目：</strong><br />
求出区间 a,b(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo><mi>a</mi><mo>≤</mo><mi>b</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">2≤a≤b≤10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>) 中所有整数的质因数分解</p>
<p><em>输入：</em><br />
输入两个整数 a,b</p>
<p><em>输出：</em><br />
每行输出一个数的分解，形如 k=a1<em>a2</em>a3···</p>
<p><em>样例输入：</em></p>
<blockquote>
<p>3 10</p>
</blockquote>
<p><em>样例输出：</em></p>
<blockquote>
<p>3=3<br />
4=2<em>2<br />
5=5<br />
6=2</em>3<br />
7=7<br />
8=2<em>2</em>2<br />
9=3<em>3<br />
10=2</em>5</p>
</blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>质因数分解，就是最后的因子全部变为质数，那这样还需要判断质数本身</li>
<li>创建从 a-&gt;b 的循环，赋值于临时变量 t，t 可能重复分解，所以这里用 while 循环</li>
<li>如果 while 循环判断不能进行时继续 fori 循环，直至 <code>t==i</code> 时说明最大的素数因子已然出现</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a; i &lt;= b; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            System.out.print(temp + <span class="string">&quot;=&quot;</span>);<span class="comment">// 输出开头</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= temp; j++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (temp % j == <span class="number">0</span> &amp;&amp; temp != j) &#123;<span class="comment">// 防止除数和被除数相等进入死循环</span></span><br><span class="line">                    System.out.print(j + <span class="string">&quot;*&quot;</span>);</span><br><span class="line">                    temp /= j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp == j) &#123;<span class="comment">// 相等表示分解完毕</span></span><br><span class="line">                    System.out.println(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并链表"><a class="markdownIt-Anchor" href="# 合并链表"></a> 合并链表</h3>
<p><strong>题目：</strong><br />
给出两个有序链表，将其合并为一个链表后仍然有序</p>
<p><strong>思路：</strong><br />
使用递归对每一个节点进行比对总是返回较小值</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">head1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">head2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h1Next1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h2Next1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h1Next2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">7</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h2Next2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h1Next3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">10</span>);</span><br><span class="line">        head1.next = h1Next1;</span><br><span class="line">        h1Next1.next = h1Next2;</span><br><span class="line">        h1Next2.next = h1Next3;</span><br><span class="line">        head2.next = h2Next1;</span><br><span class="line">        h2Next1.next = h2Next2;</span><br><span class="line">        merTwoList(head1, head2);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> head1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            System.out.print(temp.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Node <span class="title function_">merTwoList</span><span class="params">(Node one, Node two)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (one == <span class="literal">null</span> &amp;&amp; two == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (one == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> two;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (two == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> one;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node head;</span><br><span class="line">        <span class="keyword">if</span> (one.data &gt; two.data) &#123;</span><br><span class="line">            head = two;</span><br><span class="line">            head.next = merTwoList(one, two.next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = one;</span><br><span class="line">            head.next = merTwoList(two, one.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打乱数组"><a class="markdownIt-Anchor" href="# 打乱数组"></a> 打乱数组</h3>
<p><strong>题目：</strong><br />
编写一个程序，将数据中的所有数据随机打乱，确保每一个数据都被更换过</p>
<p><strong>思路：</strong><br />
在循环中，使用生成随机数与当前所剩未打乱数据的个数相乘，找出一个符合数组范围的随机数作为下标，将其与当前循环变量的值做下标的数据相调换</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * len--);<span class="comment">// 长度乘随机数确保每个值都被更换到</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[t];</span><br><span class="line">            arr[t] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> each : arr) &#123;</span><br><span class="line">            System.out.println(each);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="等差公式吗"><a class="markdownIt-Anchor" href="# 等差公式吗"></a> 等差公式吗？</h3>
<p><strong>题目：</strong><br />
给定一个无序数组，判断其是否是一个等差数列（要求时间复杂度为 O<sub>n</sub>)</p>
<p><strong>思路：</strong><br />
有时间复杂度的约束可以使用公式来考虑，遍历一遍找出其中的最大最小值然后求出差 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>d</mi><mo>=</mo><mfrac><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi></mrow><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d(d=\frac{max-min}{length-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3367719999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>，再遍历一遍判断每个值减去 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span></span></span></span> 后是否能整除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="type">var</span> <span class="variable">min</span> <span class="operator">=</span> (<span class="type">int</span>)Math.floor(Collections.min(Arrays.asList(arr)));</span><br><span class="line">        <span class="type">var</span> <span class="variable">max</span> <span class="operator">=</span> (<span class="type">int</span>)Math.floor(Collections.max(Arrays.asList(arr)));</span><br><span class="line">        <span class="type">var</span> <span class="variable">d</span> <span class="operator">=</span> (max - min) / (arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer each : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != (each - min) % d) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串对比"><a class="markdownIt-Anchor" href="# 字符串对比"></a> 字符串对比</h3>
<p><strong>题目：</strong><br />
给定两个仅由大写字母或小写字母组成的字符串（长度介于 1 到 10 之间），它们之间的关系是以下四种情况之一：</p>
<blockquote>
<ol>
<li>两个字符串长度不等。比如 Beijing 和 Hebei</li>
<li>两个字符串不仅长度相等，而且相应位置上的字符完全一致（区分大小写），比如 Beijing 和 Beijing</li>
<li>两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完全一致（也就是说，它并不满足情况 2)，比如  beijing 和 BEIjing</li>
<li>两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比如 Beijing 和 Nanjing</li>
</ol>
</blockquote>
<p>编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号</p>
<p><em>输入：</em><br />
包括两行，每行都是一个字符串</p>
<p><em>输出：</em><br />
仅有一个数字，表明这两个字符串的关系编号</p>
<p><em>样例输入：</em></p>
<blockquote>
<p>BEIjing<br />
beiJing</p>
</blockquote>
<p><em>样例输出：</em></p>
<blockquote>
<p>3</p>
</blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>四个条件相加就是全集，所以最后的条件 4 无需判断</li>
<li>引用 <code>String</code> 类中的实用方法 <code>.equals()</code> 和<code>.compareToIgnoreCase()</code></li>
<li>定义一个 num 变量用来记录符合的条件，先判断长度，长度相同直接将 num 赋值为 4，然后进行 2、3 的判断</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">if</span> (str1.length() != str2.length()) &#123;</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> (str1.equals(str2)) &#123;</span><br><span class="line">                num = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == str1.compareToIgnoreCase(str2)) &#123;</span><br><span class="line">                num = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完美的代价"><a class="markdownIt-Anchor" href="# 完美的代价"></a> 完美的代价</h3>
<p><strong>题目：</strong><br />
回文串才是完美的<br />
现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串<br />
交换的定义是：交换两个相邻的字符</p>
<blockquote>
<p>例如 mamad<br />
第一次交换 ad : mamda<br />
第二次交换 md : madma<br />
第三次交换 ma : madam （回文！完美！)</p>
</blockquote>
<p><em>输入：</em><br />
第一行是一个整数 N，表示接下来的字符串的长度 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>≤</mo><mn>8000</mn></mrow><annotation encoding="application/x-tex">N≤8000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>)<br />
第二行是一个字符串，只包含小写字母</p>
<p><em>输出：</em><br />
如果可能，输出最少的交换次数<br />
否则输出<code>Impossible</code></p>
<p><em>样例输入：</em></p>
<blockquote>
<p>5<br />
mamad</p>
</blockquote>
<p><em>样例输出：</em></p>
<blockquote>
<p>3</p>
</blockquote>
<p><strong>思路：</strong></p>
<ul>
<li>分支判断，先判断什么情况下不可能组成回文数：当出现奇数次字符的个数超过 2 次</li>
<li>剩下的情况一定能够组成回文数，模拟的时间复杂度太高，直接用字符串删除的方式判断
<ul>
<li>判断第一个出现的字符最后一次出现是在什么位置，将二者直接删除，计算出字符从最后出现的位置到串尾需要换几次，累加后继续递归判断</li>
<li>如果有个字符出现了奇数次，在几次删除后（也可能初始时）就只有这一个字符处于串首，这种情况直接舍掉，累加其对换到串中需要的次数</li>
<li>最后字符串的长度小于等于 2 时无需调换，以此为递归出口</li>
</ul>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">char</span>[N];</span><br><span class="line">        arr = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">oddCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] flagArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : arr) &#123;</span><br><span class="line">            flagArr[c - <span class="string">&#x27;a&#x27;</span>]++;<span class="comment">// 记录每个字符出现的次数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k : flagArr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                oddCount++;<span class="comment">// 记录出现奇数次字符的个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (oddCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(getCount(str));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">(String str)</span> &#123;<span class="comment">// 使用递归进行判断</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (str.length() == <span class="number">1</span> || str.length() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> count;<span class="comment">// 长度小于等于 2 时，无需移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取字符串第一个字符最后一次出现的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> str.lastIndexOf(str.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 恰好第一个数就是奇数，截取后面的继续判断</span></span><br><span class="line">            count = (str.length() / <span class="number">2</span>) + getCount(str.substring(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 假设将首位的唯一奇数放到中间了</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//0 号位字符和已找到 temp 位置的字符都移除，然后进行递归</span></span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">strBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str);</span><br><span class="line">            strBuilder.deleteCharAt(temp);</span><br><span class="line">            strBuilder.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">            count = str.length() - <span class="number">1</span> - temp + getCount(strBuilder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="报时助手"><a class="markdownIt-Anchor" href="# 报时助手"></a> 报时助手</h3>
<p><strong>题目：</strong><br />
给定当前的时间，请用英文的读法将它读出来<br />
时间用时 h 和分 m 表示，在英文的读法中，读一个时间的方法是：<br />
如果 m 为 0，则将时读出来，然后加上 “o’clock”，如 3:00 读作 “three  o’clock”<br />
如果 m 不为 0，则将时读出来，然后将分读出来，如 5:30 读作 “five thirty”<br />
时和分的读法使用的是英文数字的读法，其中 0~20 读作：</p>
<blockquote>
<p>0:zero,  1:  one,  2:two,  3:three,  4:four,  5:five,  6:six,  7:seven,  8:eight,  9:nine,  10:ten,  11:eleven,  12:twelve,  13:thirteen,  14:fourteen,  15:fifteen,  16:sixteen,  17:seventeen,  18:eighteen,  19:nineteen,  20:twenty, 30:thirty, 40:forty, 50:fifty<br />
对于大于 20 小于 60 的数字，首先读整十的数，然后再加上个位数，如 31 首先读 30 再加 1 的读法，读作 “thirty one”<br />
按上面的规则 21:54 读作 “twenty one fifty four”，9:07 读作 “nine seven”，0:15 读作 “zero fifteen”</p>
</blockquote>
<p><em>输入：</em><br />
输入包含两个非负整数 h 和 m，表示时间的时和分。非零的数字前没有前导 0。h 小于 24，m 小于 60。</p>
<p><em>输出：</em><br />
输出时间时刻的英文</p>
<p><em>样例输入：</em></p>
<blockquote>
<p>0 15</p>
</blockquote>
<p><em>样例输出：</em></p>
<blockquote>
<p>zero fifteen</p>
</blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>先定义一个字符串数组存储既定输出（0~20）；两个变量：h,m 将两个分开判断
<ul>
<li>无论 m 的值为任何数，h 并不会受影响（只是输出 <code>o'clock</code> 的不同）</li>
<li>h 在 0 和 24 之间，但其实字符串数组的大小只有 21，所以判断 h 是否小于 21，小于输出对应下标的字符串，否则先输出 <code>twenty</code> 然后 h-20，再输出 <code>s[h]</code></li>
</ul>
</li>
<li>然后判断 m，当 <code>m==0</code> 时输出 <code>o'clock</code>，否则跟 h 一样同理判断，但 m 在 0~60 之间，所以在 20 之后进行每次 + 10 的区间判断</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        String[] s = &#123;<span class="string">&quot;zero&quot;</span>, <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;six&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;eight&quot;</span>,</span><br><span class="line">                <span class="string">&quot;nine&quot;</span>, <span class="string">&quot;ten&quot;</span>, <span class="string">&quot;eleven&quot;</span>, <span class="string">&quot;twelve&quot;</span>, <span class="string">&quot;thirteen&quot;</span>, <span class="string">&quot;fourteen&quot;</span>, <span class="string">&quot;fifteen&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sixteen&quot;</span>, <span class="string">&quot;seventeen&quot;</span>, <span class="string">&quot;eighteen&quot;</span>, <span class="string">&quot;nineteen&quot;</span>, <span class="string">&quot;twenty&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 处理时的输出</span></span><br><span class="line">        <span class="keyword">if</span> (h &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;twenty&quot;</span>);</span><br><span class="line">            h = h - <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(s[h] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// 处理分的输出</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;o&#x27;clock&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; <span class="number">21</span>) &#123;</span><br><span class="line">            System.out.print(s[m]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;twenty&quot;</span>);</span><br><span class="line">            m = m - <span class="number">20</span>;</span><br><span class="line">            System.out.print(s[m]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;thirty&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; <span class="number">40</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;thirty&quot;</span>);</span><br><span class="line">            m = m - <span class="number">30</span>;</span><br><span class="line">            System.out.print(s[m]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">40</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;forty&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; <span class="number">50</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;forty&quot;</span>);</span><br><span class="line">            m = m - <span class="number">40</span>;</span><br><span class="line">            System.out.print(s[m]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">50</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;fifty&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; <span class="number">60</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;fifty&quot;</span>);</span><br><span class="line">            m = m - <span class="number">50</span>;</span><br><span class="line">            System.out.print(s[m]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="龟兔赛跑预测"><a class="markdownIt-Anchor" href="# 龟兔赛跑预测"></a> 龟兔赛跑预测</h3>
<p><strong>题目：</strong><br />
一旦任意秒结束后兔子发现自己领先 t 米或以上，它们就会停下来休息 s 秒，对于不同的兔子，t，s 的数值是不同的，但是所有的乌龟却是不到终点不停止<br />
然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子的速度 v1/ 秒，乌龟的速度 v2/ 秒，以及兔子对应的 t、s 值，以及赛道的长度 l，就能预测出比赛的结果</p>
<p><em>输入：</em><br />
输入只有一行，包含用空格隔开的五个正整数 v1、v2、t、s、l，其中数据范围为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mn>2</mn><mo>≤</mo><mn>100</mn><mo separator="true">;</mo><mi>t</mi><mo>≤</mo><mn>300</mn><mo separator="true">;</mo><mi>s</mi><mo>≤</mo><mn>10</mn><mo separator="true">;</mo><mi>l</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">v1,v2≤100;t≤300;s≤10;l≤10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>且为 v1、v2 的公倍数</p>
<p><em>输出：</em><br />
输出包含两行，第一行输出比赛结果：“T” 或 “R” 或 “D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点<br />
第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）</p>
<p><em>样例输入：</em></p>
<blockquote>
<p>10 5 5 2 20</p>
</blockquote>
<p><em>样例输出：</em></p>
<blockquote>
<p>D<br />
4</p>
</blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>分别为兔子和乌龟设置属性：当前时间和当前路程，只要二者都未到达终点便一直循环模拟</li>
<li>当兔子超过乌龟 t 米时直接进行时间跳转到 s 秒之后的处理，可能存在不需 s 秒乌龟就到达终点，判断一下</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> v1, v2, t, s, l;</span><br><span class="line">        v1 = scanner.nextInt();</span><br><span class="line">        v2 = scanner.nextInt();</span><br><span class="line">        t = scanner.nextInt();</span><br><span class="line">        s = scanner.nextInt();</span><br><span class="line">        l = scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">timeT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">timeR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (sT &lt; l &amp;&amp; sR &lt; l) &#123;<span class="comment">// 只要没有到达终点就一直循环</span></span><br><span class="line">            <span class="keyword">if</span> (sR - sT &lt; t) &#123;<span class="comment">// 兔子没超过位置就按秒模拟</span></span><br><span class="line">                timeR++;</span><br><span class="line">                timeT++;</span><br><span class="line">                sR += v1;</span><br><span class="line">                sT += v2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 按 s 的时长相加</span></span><br><span class="line">                timeR += s;</span><br><span class="line">                timeT += s;</span><br><span class="line">                sT += s * v2;</span><br><span class="line">                <span class="keyword">if</span> ((sT &gt; l) &amp;&amp; ((sT - l) / v2 &gt; <span class="number">0</span>)) &#123;<span class="comment">// 存在乌龟过线不需要 s 秒的情况</span></span><br><span class="line">                    timeT -= (sT - l) / v2;</span><br><span class="line">                    sT = timeT * v2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sT == sR) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;D\n&quot;</span> + timeR);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sT &gt; sR) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T\n&quot;</span> + timeT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;R\n&quot;</span> + timeR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组替换"><a class="markdownIt-Anchor" href="# 数组替换"></a> 数组替换</h3>
<p><strong>题目：</strong><br />
该函数将数组 b 的前 n 个元素追加到数组 a 的前 m 个元素后，假定数组 a 具有至少存放 m+n 个元素的空间<br />
例如，如果数组 a 为{22,33,44,55,66,77,88,99}，数组 b 为{20,30,40,50,60,70,80,90}，则调用 Add(a,5,b,3) 后，将把数组 a 变为{22,33,44,55,66,20,30,40}<br />
注意数组 b 并没有改变，而且数组 a 中只需改变 n 个元素。</p>
<p><em>输入：</em><br />
第一行输入 a、b 数组的长度，第二、三行输入数组的元素，最后输入 m、n 表示 a 数组的 m 元素后替换为 b 数组的前 n 个元素</p>
<p><em>输出：</em><br />
最后数组 a 中的元素，两个元素之间以逗号隔开</p>
<ul>
<li>样例输入 *</li>
</ul>
<blockquote>
<p>8 8<br />
1 2 3 4 5 6 7 8<br />
9 10 11 12 13 14 15 16<br />
4 5</p>
</blockquote>
<p><em>样例输出：</em></p>
<blockquote>
<p>1,2,3,4,9,10,11,12,13</p>
</blockquote>
<p><strong>思路：</strong><br />
将 a 数组长度设置为两数组长度的总和，操作后根据长度判断输出即可</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span> b[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[m + n];<span class="comment">// 注意数组大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            a[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            b[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> m1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">            a[temp++] = b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m - m1 &lt; n1)</span><br><span class="line">            m = m1 + n1;<span class="comment">// 改变之后 a 数组的大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(a[m - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="质数的积"><a class="markdownIt-Anchor" href="# 质数的积"></a> 质数的积</h3>
<p><em>此题考查模除公式的应用</em></p>
<blockquote>
<p>(a+b) mod n=((a mod n)+(b mod n)) mod n;<br />
(a - b) mod n=((a mod n)-(b mod n)+ n) mod n;<br />
ab mod n =(a mod n)(b mod n) mod n;</p>
</blockquote>
<p><strong>题目：</strong><br />
算出前 n 个质数的乘积（只要算出这个数模上 50000 的值）</p>
<p><em>输入：</em><br />
仅包含一个正整数 n，其中 n&lt; =100000</p>
<p><em>输出：</em><br />
输出一行，即前 n 个质数的乘积模 50000 的值</p>
<p><em>样例输入</em></p>
<blockquote>
<p>1</p>
</blockquote>
<p><em>样例输出：</em></p>
<blockquote>
<p>2</p>
</blockquote>
<p><strong>思路：</strong><br />
使用计数器进行 N 个数的判断，是质数与积相乘取余即可</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">product</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; N) &#123;<span class="comment">// 从 2 开始遍历，等计数器到 N 时停止循环</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j * j &lt;= i; j++) &#123;<span class="comment">// 判断质数的另一种方式</span></span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                product = product * i % <span class="number">50000</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="乘法运算"><a class="markdownIt-Anchor" href="# 乘法运算"></a> 乘法运算</h3>
<p><strong>题目：</strong><br />
从键盘读入 2 个 100 以内的正整数，进行乘法运算并以竖式输出<br />
<em>样例输入：</em><br />
16  8<br />
<em>样例输出：</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  16</span><br><span class="line">×  8</span><br><span class="line">━━━━</span><br><span class="line"> 128</span><br></pre></td></tr></table></figure>
<p>8×16=128，则第四行 128 右侧对准个位输出<br />
再例如：87x76</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  87</span><br><span class="line">× 76</span><br><span class="line">━━━━</span><br><span class="line"> 522</span><br><span class="line">609</span><br><span class="line">━━━━</span><br><span class="line">6612</span><br></pre></td></tr></table></figure>
<p><em>输入：</em><br />
输入只有一行，是两个用空格隔开的数字，均在 1~99 之间</p>
<p><em>输出：</em><br />
输出为 4 行或 7 行，符合乘法的竖式运算格式（乘号和下划线为特殊符号）</p>
<p><strong>思路：</strong></p>
<ol>
<li>首先输出 “x” 和 “━━━” 此类的特殊字符，都应该从题目中复制，要不然出错</li>
<li>因为输出需要对齐，空格不能适用于多种状况，所以采用 “%nd” 的方式输出</li>
<li>输出为 4 或 7 行，主要是根据乘数是否为两位数决定，所以要设置一个 b&gt;=10 的判断语句</li>
<li>如果乘数的个位是 0 那么直接输出 “00” 即可</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.printf(<span class="string">&quot;%4d\n×%3d\n&quot;</span>, a, b);</span><br><span class="line">        System.out.println(<span class="string">&quot;━━━&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (b &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;00&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%4d\n&quot;</span>, (b % <span class="number">10</span>) * a);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%3d\n━━━\n%4d\n&quot;</span>, (b / <span class="number">10</span>) * a, a * b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五次方数"><a class="markdownIt-Anchor" href="# 五次方数"></a> 五次方数</h3>
<p><strong>题目：</strong><br />
对一个数十进制表示时的每一位数字乘五次方再求和，会得到一个数的五次方数<br />
例如：1024 的五次方数为 1+0+32+1024=1057<br />
有这样一些神奇的数，它的五次方数就是它自己，而且这样的数竟然只有有限多个<br />
从小到大输出所有这样的数</p>
<p><strong>思路：</strong><br />
因为是有限数，所以首先要判断它的边界</p>
<ul>
<li>上边界：十进制数中最大的是 9，而 9<sup>5</sup>=59049, 是一个五位数，那最大不会超过每一位都为 9 时的五次方数，也就是 5*9<sup>5</sup>=295245，而当位数是 6 或者大于 6 的时候，不论每一位的数是几，它本身的五次方数永远不会超过这个数本身，就没有了相等的可能，所以 295245 是理论上的最大值，这里的边界用实际上最大的六位数 999999 来表示</li>
<li>下边界：0，1 不符合条件，所以可以直接从两位数开始，下边界为 10</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &lt; <span class="number">999999</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t1</span> <span class="operator">=</span> i % <span class="number">10</span>, t2 = i / <span class="number">10</span> % <span class="number">10</span>, t3 = i / <span class="number">100</span> % <span class="number">10</span>, t4 = i / <span class="number">1000</span> % <span class="number">10</span>, t5 = i / <span class="number">10000</span> % <span class="number">10</span>, t6 = i / <span class="number">100000</span>;</span><br><span class="line">            <span class="keyword">if</span> (Math.pow(t1, <span class="number">5</span>) + Math.pow(t2, <span class="number">5</span>) + Math.pow(t3, <span class="number">5</span>)</span><br><span class="line">                    + Math.pow(t4, <span class="number">5</span>) + Math.pow(t5, <span class="number">5</span>) + Math.pow(t6, <span class="number">5</span>) == i) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分发口罩"><a class="markdownIt-Anchor" href="# 分发口罩"></a> 分发口罩</h3>
<p><strong>题目：</strong><br />
某市市长获得了若干批口罩，每一批口罩的数目如下：</p>
<blockquote>
<p>9090400<br />
8499400<br />
5926800<br />
8547000<br />
4958200<br />
4422600<br />
5751200<br />
4175600<br />
6309600<br />
5865200<br />
6604400<br />
4635000<br />
10663400<br />
8087200<br />
4554000</p>
</blockquote>
<p>现在市长要把口罩分配给市内的 2 所医院。由于物流限制，每一批口罩只<br />
能全部分配给其中一家医院。市长希望 2 所医院获得的口罩总数之差越小越好。<br />
请你计算这个差最小是多少？</p>
<p><strong>思路：</strong><br />
对于这种需要多次分情况进行判断每种组合的题目使用双重循环是无法进行的，每次分给谁又会引出不同的分支，如二叉树<br />
这样到达第十五次的时候，的得到的结果是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup></mrow><annotation encoding="application/x-tex">2^{14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span> 种<br />
所以使用分支型 DFS 进行判断，当达到相应层数时，判断当前的差与之前求出的最小值比较<br />
差的判断：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>s</mi><mo stretchy="false">(</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>b</mi><mi>s</mi><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>−</mo><mn>2</mn><mo>×</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">abs(a-b)=abs(a+b-2×a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 定义在静态空间方便 DFS 方法调用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> Integer.MAX_VALUE, sum = <span class="number">0</span>, value[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            sum += value[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">14</span>, <span class="number">0</span>);</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> next, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; <span class="number">0</span>) &#123;<span class="comment">// 到达层数判断</span></span><br><span class="line">            cnt = Math.min(cnt, Math.abs(sum - v - v));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 每次分支模拟</span></span><br><span class="line">            dfs(next - <span class="number">1</span>, v + value[next]);</span><br><span class="line">            dfs(next - <span class="number">1</span>, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT 甲级 - 算法初步</title>
    <url>/pat_level_a-elementary_algorithm/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p>接上一篇 <a class="link"   href="https://aidanblog.top/2021/08/08/PAT-A-GettingStarted/">PAT 甲级 - 入门模拟<i class="fas fa-external-link-alt"></i></a> ，自我感觉这部分才是真正的算法入门，对基础的数据结构提供了很好的类型题进行匹配练习</p>
<p>包括分类：<a href="#%E6%8E%92%E5%BA%8F">排序 </a>、<a href="#%E6%95%A3%E5%88%97"> 散列 </a>、<a href="#%E8%B4%AA%E5%BF%83"> 贪心 </a>、<a href="#%E4%BA%8C%E5%88%86"> 二分 </a>、<a href="#%E5%8F%8C%E6%8C%87%E9%92%88"> 双指针 </a>、<a href="#%E5%85%B6%E4%BB%96"> 打表、递推</a></p>
<span id="more"></span>
<h2 id="排序"><a class="markdownIt-Anchor" href="# 排序"></a> 排序</h2>
<h3 id="思想解释"><a class="markdownIt-Anchor" href="# 思想解释"></a> 思想解释</h3>
<p>排序题主要是获取排序后的结果而不是过程，大部分代码可以使用 <code>sort()</code> 函数进行直接处理，要熟练编写 cmp 排序规则（包括结构体形式的多变量规则）</p>
<p>有些题需要获取排名，只需在已经排序好的数组或容器中遍历全部的数据，如果和上一个数据相同，则排名相同，否则排名加 1</p>
<h3 id="类型练习"><a class="markdownIt-Anchor" href="# 类型练习"></a> 类型练习</h3>
<h4 id="1062"><a class="markdownIt-Anchor" href="#1062"></a> 1062</h4>
<p><strong>题目：Talent and Virtue</strong></p>
<p>About 900 years ago, a Chinese philosopher Sima Guang wrote a history book in which he talked about people’s talent and virtue. According to his theory, a man being outstanding in both talent and virtue must be a “sage（圣人）”; being less excellent but with one’s virtue outweighs talent can be called a “nobleman（君子）”; being good in neither is a “fool man（愚人）”; yet a fool man is better than a “small man（小人）” who prefers talent than virtue.</p>
<p>Now given the grades of talent and virtue of a group of people, you are supposed to rank them according to Sima Guang’s theory.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case first gives 3 positive integers in a line: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>105</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤105)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">5</span><span class="mclose">)</span></span></span></span>, the total number of people to be ranked; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mo>≥</mo><mn>60</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L (≥60)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the lower bound of the qualified grades – that is, only the ones whose grades of talent and virtue are both not below this line will be ranked; and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mo>&lt;</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(&lt;100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the higher line of qualification – that is, those with both grades not below this line are considered as the “sages”, and will be ranked in non-increasing order according to their total grades. Those with talent grades below H but virtue grades not are cosidered as the “noblemen”, and are also ranked in non-increasing order according to their total grades, but they are listed after the “sages”. Those with both grades below H, but with virtue not lower than talent are considered as the “fool men”. They are ranked in the same way but after the “noblemen”. The rest of people whose grades both pass the L line are ranked after the “fool men”.</p>
<p>Then N lines follow, each gives the information of a person in the format:</p>
<p><code>ID_Number Virtue_Grade Talent_Grade</code></p>
<p>where <code>ID_Number</code> is an 8-digit number, and both grades are integers in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>. All the numbers are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>The first line of output must give <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mo>≤</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(≤N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>, the total number of people that are actually ranked. Then M lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output in increasing order of their ID’s.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>14 60 80<br />
10000001 64 90<br />
10000002 90 60<br />
10000011 85 80<br />
10000003 85 80<br />
10000004 80 85<br />
10000005 82 77<br />
10000006 83 76<br />
10000007 90 78<br />
10000008 75 79<br />
10000009 59 90<br />
10000010 88 45<br />
10000012 80 100<br />
10000013 90 99<br />
10000014 66 60</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>12<br />
10000013 90 99<br />
10000012 80 100<br />
10000003 85 80<br />
10000011 85 80<br />
10000004 80 85<br />
10000007 90 78<br />
10000006 83 76<br />
10000005 82 77<br />
10000002 90 60<br />
10000014 66 60<br />
10000008 75 79<br />
10000001 64 90</p>
</blockquote>
<p><strong>思路：</strong> 使用结构体对每个学生的信息进行存储，根据题意编写排序规则</p>
<ul>
<li>
<p>存储学生信息的结构体除了基本信息外还应包含总成绩 (total) 与类别 (rank)</p>
</li>
<li>
<p>编写排序规则，升序用小于号 &quot;&lt;&quot;，降序反之</p>
</li>
<li>
<p>使用动态容器 vector 创建一个结构体数组，处理时将及格的放入数组，最后输出 size</p>
</li>
<li>
<p>在循环中创建一个临时结构体变量进行数据的处理，符合哪种条件就将 rank 置于相应的等级</p>
</li>
<li>
<p>需要注意读题， <code>not lower than</code>就代表 <code>&gt;=</code></p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> Id, virtue, talent, total;</span><br><span class="line">    <span class="type">int</span> rank; <span class="comment">// 表示类别，1~4</span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Student a, Student b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 排序规则</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.rank != b.rank)</span><br><span class="line">    &#123; <span class="comment">// 类别不同，按类别从小到大</span></span><br><span class="line">        <span class="keyword">return</span> a.rank &lt; b.rank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.total != b.total)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.total &gt; b.total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.virtue != b.virtue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.virtue &gt; b.virtue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">// 全部相同，按学号</span></span><br><span class="line">        <span class="keyword">return</span> a.Id &lt; b.Id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, low, height;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; low &gt;&gt; height;</span><br><span class="line">    vector&lt;Student&gt; stu; <span class="comment">// 建立一个结构体的动态数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Student temp; <span class="comment">// 临时结构体变量</span></span><br><span class="line">        cin &gt;&gt; temp.Id &gt;&gt; temp.virtue &gt;&gt; temp.talent;</span><br><span class="line">        temp.total = temp.virtue + temp.talent; <span class="comment">// 对每一个数据都计算它的总成绩</span></span><br><span class="line">        <span class="keyword">if</span> (temp.virtue &lt; low || temp.talent &lt; low)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 如果不符合条件直接处理下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp.virtue &gt;= height &amp;&amp; temp.talent &gt;= height) <span class="comment">// 这里可以是等于</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp.rank = <span class="number">1</span>;</span><br><span class="line">            stu.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp.virtue &gt;= height &amp;&amp; temp.talent &lt; height)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.rank = <span class="number">2</span>;</span><br><span class="line">            stu.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp.virtue &lt; height &amp;&amp; temp.talent &lt; height &amp;&amp; temp.virtue &gt;= temp.talent) <span class="comment">// 不小于</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp.rank = <span class="number">3</span>;</span><br><span class="line">            stu.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp.rank = <span class="number">4</span>;</span><br><span class="line">            stu.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(stu.<span class="built_in">begin</span>(), stu.<span class="built_in">end</span>(), cmp); <span class="comment">// 根据规则排序</span></span><br><span class="line">    cout &lt;&lt; stu.<span class="built_in">size</span>() &lt;&lt; endl;        <span class="comment">// 输出符合条件的人数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stu.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123; <span class="comment">// 按规则循环输出</span></span><br><span class="line">        cout &lt;&lt; stu[i].Id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; stu[i].virtue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; stu[i].talent &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1012"><a class="markdownIt-Anchor" href="#1012"></a> 1012</h4>
<p><strong>题目：The Best Rank</strong></p>
<p>To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: <code>C</code> - C Programming Language, <code>M</code> - Mathematics (Calculus or Linear Algrbra), and <code>E</code> - English. At the mean time, we encourage students by emphasizing on their best ranks – that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.</p>
<p>For example, The grades of <code>C</code>, <code>M</code>, <code>E</code> and <code>A</code> - Average of 4 students are given as the following:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">StudentID   C  M  E  A</span><br><span class="line"> <span class="number">310101</span>     <span class="number">98</span> <span class="number">85</span> <span class="number">88</span> <span class="number">90</span></span><br><span class="line"> <span class="number">310102</span>     <span class="number">70</span> <span class="number">95</span> <span class="number">88</span> <span class="number">84</span></span><br><span class="line"> <span class="number">310103</span>     <span class="number">82</span> <span class="number">87</span> <span class="number">94</span> <span class="number">88</span></span><br><span class="line"> <span class="number">310104</span>     <span class="number">91</span> <span class="number">91</span> <span class="number">91</span> <span class="number">91</span></span><br></pre></td></tr></table></figure>
<p>Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case starts with a line containing 2 numbers N and M (≤2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of <code>C</code> , <code>M</code> and <code>E</code> . Then there are M lines, each containing a student ID.</p>
<p><em>Output Specification:</em></p>
<p>For each of the M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space.</p>
<p>The priorities of the ranking methods are ordered as <code>A</code> &gt; <code>C</code> &gt; <code>M</code> &gt; <code>E</code> . Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.</p>
<p>If a student is not on the grading list, simply output <code>N/A</code> .</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>5 6<br />
310101 98 85 88<br />
310102 70 95 88<br />
310103 82 87 94<br />
310104 91 91 91<br />
310105 85 90 90<br />
310101<br />
310102<br />
310103<br />
310104<br />
310105<br />
999999</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>1 C<br />
1 M<br />
1 E<br />
1 A<br />
3 A<br />
N/A</p>
</blockquote>
<p><strong>思路：</strong> 编写排序规则对每一科进行排序将排名放到结构体相应位置，使用 Map 集合创建索引，进行查询</p>
<ul>
<li>
<p>使用结构体对每个学生进行存储，成绩和排名用数组的方式创建</p>
</li>
<li>
<p>循环输入，平均分要四舍五入，使用 <code>answer+0.5</code>的方式实现</p>
</li>
<li>
<p>对每一科进行排序，编写循环式排序规则时，下标变量必须提前定义，处理并列排名的情况</p>
</li>
<li>
<p>将最后一轮排序（数据全部处理完）后的顺序，以 ID 为键，下标为值的方式放入 Map 集合方便查询 (unordered_map 时间更短）</p>
</li>
<li>
<p>对每一个被查询学生查找排名最小的一项，返回其值并获得课程下标，按格式输出</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> <span class="comment">// 学生结构体</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    string Id;</span><br><span class="line">    <span class="type">int</span> grades[<span class="number">4</span>], ranks[<span class="number">4</span>];           <span class="comment">// 对应的成绩和排名</span></span><br><span class="line"></span><br><span class="line">&#125; stu[<span class="number">2000</span>]; <span class="comment">// 不会超过 2000 人</span></span><br><span class="line"><span class="type">char</span> course[<span class="number">5</span>] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;; <span class="comment">// 对应的课程，方便输出（这里的构造顺序要和处理时的顺序必须一致，顺序用题目给出的优先级即可）</span></span><br><span class="line"><span class="type">int</span> now, r; <span class="comment">// 表示课程和排名的处理</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Student a, Student b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.grades[now] &gt; b.grades[now];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; Map; <span class="comment">// 用于存储 ID 对应的下标，方便查询</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; stu[i].Id &gt;&gt; stu[i].grades[<span class="number">1</span>] &gt;&gt; stu[i].grades[<span class="number">2</span>] &gt;&gt; stu[i].grades[<span class="number">3</span>];</span><br><span class="line">        stu[i].grades[<span class="number">0</span>] = (stu[i].grades[<span class="number">1</span>] + stu[i].grades[<span class="number">2</span>] + stu[i].grades[<span class="number">3</span>]) / <span class="number">3</span> + <span class="number">0.5</span>; <span class="comment">// 平均值四舍五入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (now = <span class="number">0</span>; now &lt; <span class="number">4</span>; now++) <span class="comment">// 按每科成绩进行排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(stu, stu + n, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (stu[i].grades[now] != stu[i - <span class="number">1</span>].grades[now] || i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r = i + <span class="number">1</span>; <span class="comment">// 处理排名并列的情况</span></span><br><span class="line">            &#125;</span><br><span class="line">            stu[i].ranks[now] = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Map[stu[i].Id] = i; <span class="comment">// 数据处理完成后将 ID 和下标对应存储，方便查询</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        string query;</span><br><span class="line">        cin &gt;&gt; query;</span><br><span class="line">        <span class="keyword">if</span> (!Map.<span class="built_in">count</span>(query)) <span class="comment">// 没查询到元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;N/A\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index = Map[query], minRank = <span class="number">2001</span>, cour; <span class="comment">// 查询到了，获取其下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (stu[index].ranks[i] &lt; minRank)</span><br><span class="line">                &#123;</span><br><span class="line">                    minRank = stu[index].ranks[i]; <span class="comment">// 寻找这个学生的最小排名</span></span><br><span class="line">                    cour = i;                      <span class="comment">// 获取最小排名的课程下标</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; minRank &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; course[cour] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1016"><a class="markdownIt-Anchor" href="#1016"></a> 1016</h4>
<p><strong>题目：Phone Bills</strong></p>
<p>A long-distance telephone company charges its customers by the following rules:</p>
<blockquote>
<p>Making a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records.</p>
</blockquote>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records.<br />
The rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>00</mn><mo>:</mo><mn>00</mn><mo>−</mo><mn>01</mn><mo>:</mo><mn>00</mn></mrow><annotation encoding="application/x-tex">00:00 - 01:00</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span></span></span></span>, the toll from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>01</mn><mo>:</mo><mn>00</mn><mo>−</mo><mn>02</mn><mo>:</mo><mn>00</mn></mrow><annotation encoding="application/x-tex">01:00 - 02:00</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span></span></span></span>, and so on for each hour in the day.<br />
The next line contains a positive number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤1000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, followed by N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (<code>MM:dd:HH:mm</code>), and the word <code>on-line</code> or <code>off-line</code>.<br />
For each test case, all dates will be within a single month. Each <code>on-line</code> record is paired with the chronologically next record for the same customer provided it is an <code>off-line</code> record. Any <code>on-line</code> records that are not paired with an <code>off-line</code> record are ignored, as are <code>off-line</code> records not paired with an <code>on-line</code> record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, you must print a phone bill for each customer.<br />
Bills must be printed in alphabetical order of customers’ names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (<code>dd:HH:mm</code>), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 10<br />
10<br />
CYLL 01:01:06:01 on-line<br />
CYLL 01:28:16:05 off-line<br />
CYJJ 01:01:07:00 off-line<br />
CYLL 01:01:08:03 off-line<br />
CYJJ 01:01:05:59 on-line<br />
aaa 01:01:01:03 on-line<br />
aaa 01:02:00:01 on-line<br />
CYLL 01:28:15:41 on-line<br />
aaa 01:05:02:24 on-line<br />
aaa 01:04:23:59 off-line</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>CYJJ 01<br />
01:05:59 01:07:00 61 $12.10<br />
Total amount: $12.10<br />
CYLL 01<br />
01:06:01 01:08:03 122 $24.40<br />
28:15:41 28:16:05 24 $3.85<br />
Total amount: $28.25<br />
aaa 01<br />
02:00:01 04:23:59 4318 $638.80<br />
Total amount: $638.80</p>
</blockquote>
<p><strong>思路：</strong> 使用 Map 集合对名字自动排序，集合值为通话记录结构体组成的动态数组</p>
<ul>
<li>
<p>使用结构体存储通话记录，定义一个 time 用来记录开年零点到记录的时间（分钟为单位）方便后续比较和处理</p>
</li>
<li>
<p>使用 Map 集合存储姓名对应的结构体数组，Map 自动排序，处理时遍历取出即可</p>
</li>
<li>
<p>对取出的数组中对所有的通话记录进行排序，判断每两条记录的状态进行话费的计算</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Record</span> <span class="comment">// 结构体记录每条通话记录的信息，名字是公共的所以无需放入</span></span><br><span class="line">&#123;</span><br><span class="line">    string status;</span><br><span class="line">    <span class="type">int</span> month, day, hour, minute, time; <span class="comment">//time 表示的是开年零点到现在的时间（分钟为单位）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Record a, Record b)</span> <span class="comment">// 定义一个时间的排序规则</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.time &lt; b.time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> rate[<span class="number">24</span>]; <span class="comment">// 输入收费标准，时间也是从 0 开始，无需进行下标的增减</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; rate[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">getchar</span>();                          <span class="comment">// 后边输入字符串，截获换行符</span></span><br><span class="line">    map&lt;string, vector&lt;Record&gt;&gt; custom; <span class="comment">// 用名字作为键值，直接对其进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Record temp;</span><br><span class="line">        string temp_name; <span class="comment">// 作为键放入 Map，临时变量即可</span></span><br><span class="line">        cin &gt;&gt; temp_name;</span><br><span class="line">        <span class="comment">//cin&gt;&gt; temp.month &gt;&gt; temp.day &gt;&gt; temp.hour &gt;&gt; temp.minute;</span></span><br><span class="line">        <span class="comment">// 这种输出对有 &quot;:&quot; 间隔的数据无法处理，可以加一个 char c 截获，或使用下面 scanf 的方式输入</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d:%d&quot;</span>, &amp;temp.month, &amp;temp.day, &amp;temp.hour, &amp;temp.minute);</span><br><span class="line">        cin &gt;&gt; temp.status;</span><br><span class="line">        temp.time = temp.day * <span class="number">1440</span> + temp.hour * <span class="number">60</span> + temp.minute; <span class="comment">// 统一转换成分钟方便运算</span></span><br><span class="line">        custom[temp_name].<span class="built_in">push_back</span>(temp);                          <span class="comment">// 以姓名为键，记录数组为值放入集合</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : custom)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp_V = it.second;                 <span class="comment">// 将每个人的通话记录数组拿出来，对每个数组进行处理</span></span><br><span class="line">        <span class="built_in">sort</span>(temp_V.<span class="built_in">begin</span>(), temp_V.<span class="built_in">end</span>(), cmp); <span class="comment">// 对所有的通话记录进行排序</span></span><br><span class="line">        <span class="type">double</span> total_bill = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; temp_V.<span class="built_in">size</span>();) <span class="comment">// 分组判断，不直接递增</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; temp_V.<span class="built_in">size</span>() &amp;&amp; temp_V[i].status &gt; temp_V[i + <span class="number">1</span>].status) <span class="comment">//on 按字典序高于 off，一组符合规则的数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!total_bill) <span class="comment">// 使用非的方式只输出一次姓名，后续 total 有值便为 0</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; it.first;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; %02d\n&quot;</span>, temp_V[i].month);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">double</span> per_bill = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> time1 = temp_V[i].time, time2 = temp_V[i + <span class="number">1</span>].time;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = time1; j &lt; time2; j++) <span class="comment">// 模拟时间</span></span><br><span class="line">                &#123;</span><br><span class="line">                    per_bill += rate[j % <span class="number">1440</span> / <span class="number">60</span>]; <span class="comment">// 每分钟的单价相加</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d &quot;</span>, temp_V[i].day, temp_V[i].hour, temp_V[i].minute);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d &quot;</span>, temp_V[i + <span class="number">1</span>].day, temp_V[i + <span class="number">1</span>].hour, temp_V[i + <span class="number">1</span>].minute);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d $%.2f\n&quot;</span>, temp_V[i + <span class="number">1</span>].time - temp_V[i].time, per_bill / <span class="number">100</span>);</span><br><span class="line">                total_bill += per_bill;</span><br><span class="line">                i += <span class="number">2</span>; <span class="comment">// 一组成功下一组</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++; <span class="comment">// 一组不成功，以结束时间作为下一组的开始时间</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (total_bill) <span class="comment">// 这个是在人物之外，还需判断一次，防止有人存在的账单都不符合条件但还是输出了 total_bill</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Total amount: $%.2f\n&quot;</span>, total_bill / <span class="number">100</span>); <span class="comment">// 账单以时间为单位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1025"><a class="markdownIt-Anchor" href="#1025"></a> 1025</h4>
<p><strong>题目：PAT Ranking</strong></p>
<p>Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains a positive number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the number of test locations. Then N ranklists follow, each starts with a line containing a positive integer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>300</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K (≤300)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the number of testees, and then K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format:</p>
<p><code>registration_number final_rank location_number local_rank</code></p>
<p>The locations are numbered from 1 to N. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>2<br />
5<br />
1234567890001 95<br />
1234567890005 100<br />
1234567890003 95<br />
1234567890002 77<br />
1234567890004 85<br />
4<br />
1234567890013 65<br />
1234567890011 25<br />
1234567890014 100<br />
1234567890012 85</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>9<br />
1234567890005 1 1 1<br />
1234567890014 1 2 1<br />
1234567890001 3 1 2<br />
1234567890003 3 1 2<br />
1234567890004 5 1 4<br />
1234567890012 5 2 2<br />
1234567890002 7 1 5<br />
1234567890013 8 2 3<br />
1234567890011 9 2 4</p>
</blockquote>
<p><strong>思路：</strong> 结构体 + 动态数组存储，分情况处理排名，考场内排名的处理用临时数组每输入完一个考场处理一次的形式</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    string num;</span><br><span class="line">    <span class="type">int</span> score, ranks[<span class="number">2</span>], room; <span class="comment">//ranks[0] 代表总排名，1 代表考场排名</span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Student a, Student b)</span> <span class="comment">// 排序规则</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.score == b.score ? a.num &lt; b.num : a.score &gt; b.score;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> r; <span class="comment">// 处理并列排名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;Student&gt; stu; <span class="comment">// 所有成员的结构体动态数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="built_in">getchar</span>(); <span class="comment">// 捕捉换行符</span></span><br><span class="line">        Student temp_stu[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; temp_stu[j].num &gt;&gt; temp_stu[j].score;</span><br><span class="line">            temp_stu[j].room = i + <span class="number">1</span>; <span class="comment">// 考场号就等于组数 +1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(temp_stu, temp_stu + m, cmp); <span class="comment">// 对一个考场的所有成员进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span> || temp_stu[k].score != temp_stu[k - <span class="number">1</span>].score)</span><br><span class="line">            &#123;</span><br><span class="line">                r = k + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp_stu[k].ranks[<span class="number">1</span>] = r;   <span class="comment">// 赋值考场排名</span></span><br><span class="line">            stu.<span class="built_in">push_back</span>(temp_stu[k]); <span class="comment">// 放入总数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(stu.<span class="built_in">begin</span>(), stu.<span class="built_in">end</span>(), cmp); <span class="comment">// 公共排名处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stu.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || stu[i].score != stu[i - <span class="number">1</span>].score)</span><br><span class="line">        &#123;</span><br><span class="line">            r = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stu[i].ranks[<span class="number">0</span>] = r;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; stu.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stu.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; stu[i].num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; stu[i].ranks[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; stu[i].room &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; stu[i].ranks[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1028"><a class="markdownIt-Anchor" href="#1028"></a> 1028</h4>
<p><strong>题目：List Sorting</strong></p>
<p>Excel can sort records according to any column. Now you are supposed to imitate this function.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains two integers <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and C, where N is the number of records and C is the column that you are supposed to sort the records with. Then N lines follow, each contains a record of a student. A student’s record consists of his or her distinct ID (a 6-digit number), name (a string with no more than 8 characters without space), and grade (an integer between 0 and 100, inclusive).</p>
<p><em>Output Specification:</em></p>
<p>For each test case, output the sorting result in N lines. That is, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">C = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> then the records must be sorted in increasing order according to ID’s; if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">C = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> then the records must be sorted in non-decreasing order according to names; and if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">C = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> then the records must be sorted in non-decreasing order according to grades. If there are several students who have the same name or grade, they must be sorted according to their ID’s in increasing order.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>3 1<br />
000007 James 85<br />
000010 Amy 90<br />
000001 Zoe 60</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>000001 Zoe 60<br />
000007 James 85<br />
000010 Amy 90</p>
</blockquote>
<p><strong>思路：</strong> 设置变量 C 在排序规则之外，根据 C 的值返回相应的规则；注意 non-decreasing 表示非降序（≠升序）比较运算符要用 <code>&lt;=</code></p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    string Id, name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Student a, Student b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.Id &lt; b.Id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.name == b.name ? a.Id &lt; b.Id : a.name &lt;= b.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.score == b.score ? a.Id &lt; b.Id : a.score &lt;= b.score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;Student&gt; stu;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Student temp;</span><br><span class="line">        cin &gt;&gt; temp.Id &gt;&gt; temp.name &gt;&gt; temp.score;</span><br><span class="line">        stu.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(stu.<span class="built_in">begin</span>(), stu.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stu.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %s %d\n&quot;</span>, stu[i].Id.<span class="built_in">c_str</span>(), stu[i].name.<span class="built_in">c_str</span>(), stu[i].score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1055"><a class="markdownIt-Anchor" href="#1055"></a> 1055</h4>
<p><strong>题目：The World’s Richest</strong></p>
<p>Forbes magazine publishes every year its list of billionaires based on the annual ranking of the world’s wealthiest people. Now you are supposed to simulate this job, but concentrate only on the people in a certain range of ages. That is, given the net worths of N people, you must find the M richest people in a given range of their ages.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains 2 positive integers: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> - the total number of people, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K (≤10^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> - the number of queries. Then N lines follow, each contains the name (string of no more than 8 characters without space), age (integer in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>200</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(0, 200]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>), and the net worth (integer in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mtext>−</mtext><mn>106</mn><mo separator="true">,</mo><mn>106</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[−106, 106]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">6</span><span class="mclose">]</span></span></span></span>) of a person. Finally there are K lines of queries, each contains three positive integers: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M (≤100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> - the maximum number of outputs, and [<code>Amin</code> , <code>Amax</code> ] which are the range of ages. All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each query, first print in a line <code>Case #X:</code> where <code>X</code> is the query number starting from 1. Then output the M richest people with their ages in the range [<code>Amin</code> , <code>Amax</code> ]. Each person’s information occupies a line, in the format</p>
<p><code>Name   Age   Net_Worth</code></p>
<p>The outputs must be in non-increasing order of the net worths. In case there are equal worths, it must be in non-decreasing order of the ages. If both worths and ages are the same, then the output must be in non-decreasing alphabetical order of the names. It is guaranteed that there is no two persons share all the same of the three pieces of information. In case no one is found, output <code>None</code> .</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>12 4<br />
Zoe_Bill 35 2333<br />
Bob_Volk 24 5888<br />
Anny_Cin 95 999999<br />
Williams 30 -22<br />
Cindy 76 76000<br />
Alice 18 88888<br />
Joe_Mike 32 3222<br />
Michael 5 300000<br />
Rosemary 40 5888<br />
Dobby 24 5888<br />
Billy 24 5888<br />
Nobody 5 0<br />
4 15 45<br />
4 30 35<br />
4 5 95<br />
1 45 50</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>Case #1:<br />
Alice 18 88888<br />
Billy 24 5888<br />
Bob_Volk 24 5888<br />
Dobby 24 5888<br />
Case #2:<br />
Joe_Mike 32 3222<br />
Zoe_Bill 35 2333<br />
Williams 30 -22<br />
Case #3:<br />
Anny_Cin 95 999999<br />
Michael 5 300000<br />
Alice 18 88888<br />
Cindy 76 76000<br />
Case #4:<br />
None</p>
</blockquote>
<p><strong>思路：</strong> 使用多个结构体动态数组，挑选数据后只排序一次，减少复杂度</p>
<ul>
<li>
<p>结构体的字符串使用字符数组，配合 scanf() 减少复杂度</p>
</li>
<li>
<p>输入数据后按规则进行排序，如果年龄相同只保存 100 人，减少遍历长度</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>]; <span class="comment">// 使用字符数组，配合 scanf() 减少复杂度</span></span><br><span class="line">    <span class="type">int</span> age, money;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Person a, Person b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.money != b.money)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.money &gt;= b.money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.age != b.age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.age &lt;= b.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.name, b.name) &lt;= <span class="number">0</span>; <span class="comment">// 字符数组的排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="function">vector&lt;Person&gt; <span class="title">temp_in</span><span class="params">(n)</span></span>; <span class="comment">// 输入数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d %d&quot;</span>, &amp;temp_in[i].name, &amp;temp_in[i].age, &amp;temp_in[i].money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(temp_in.<span class="built_in">begin</span>(), temp_in.<span class="built_in">end</span>(), cmp); <span class="comment">// 排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">book</span><span class="params">(<span class="number">201</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;Person&gt; people;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (book[temp_in[i].age] &lt; <span class="number">100</span>) <span class="comment">// 每个年龄都不超过 100 人</span></span><br><span class="line">        &#123;</span><br><span class="line">            people.<span class="built_in">push_back</span>(temp_in[i]); <span class="comment">// 缩小数据放到新数组</span></span><br><span class="line">            book[temp_in[i].age]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m, Amin, Amax; <span class="comment">// 将循环输入的变量放到循环外减少语句量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;m, &amp;Amin, &amp;Amax);</span><br><span class="line">        vector&lt;Person&gt; temp_out;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; people.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (people[j].age &gt;= Amin &amp;&amp; people[j].age &lt;= Amax)</span><br><span class="line">            &#123;</span><br><span class="line">                temp_out.<span class="built_in">push_back</span>(people[j]); <span class="comment">// 将符合条件的放入输出数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; m &amp;&amp; l &lt; temp_out.<span class="built_in">size</span>(); l++) <span class="comment">// 有不足 m 的情况，加一个大小的判断条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d\n&quot;</span>, temp_out[l].name, temp_out[l].age, temp_out[l].money);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;None\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1075"><a class="markdownIt-Anchor" href="#1075"></a> 1075</h4>
<p><strong>题目：PAT Judge</strong></p>
<p>The ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains 3 positive integers, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤10^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, the total number of users, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K (≤5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mclose">)</span></span></span></span>, the total number of problems, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M (≤10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, the total number of submissions. It is then assumed that the user id’s are 5-digit numbers from 00001 to N, and the problem id’s are from 1 to K. The next line contains K positive integers <code>p[i]</code> (<code>i</code>=1, …, K), where <code>p[i]</code> corresponds to the full mark of the i-th problem. Then M lines follow, each gives the information of a submission in the following format:</p>
<p><code>user_id   problem_id   partial_score_obtained</code></p>
<p>where <code>partial_score_obtained</code> is either −1 if the submission cannot even pass the compiler, or is an integer in the range [0, <code>p[problem_id]</code>]. All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, you are supposed to output the ranklist in the following format:</p>
<p><code>rank   user_id   total_score   s[1] ... s[K]</code></p>
<p>where <code>rank</code> is calculated according to the <code>total_score</code>, and all the users with the same <code>total_score</code> obtain the same <code>rank</code>; and <code>s[i]</code> is the partial score obtained for the <code>i</code>-th problem. If a user has never submitted a solution for a problem, then “-” must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted.</p>
<p>The ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their id’s. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>7 4 20<br />
20 25 25 30<br />
00002 2 12<br />
00007 4 17<br />
00005 1 19<br />
00007 2 25<br />
00005 1 20<br />
00002 2 2<br />
00005 1 15<br />
00001 1 18<br />
00004 3 25<br />
00002 2 25<br />
00005 3 22<br />
00006 4 -1<br />
00001 2 18<br />
00002 1 20<br />
00004 1 15<br />
00002 4 18<br />
00001 3 4<br />
00001 4 2<br />
00005 2 -1<br />
00004 2 0</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>1 00002 63 20 25 - 18<br />
2 00005 42 20 0 22 -<br />
2 00007 42 - 25 - 17<br />
2 00001 42 18 18 4 2<br />
5 00004 40 15 0 25 -</p>
</blockquote>
<p><strong>思路：</strong> 创建一个 N 人的结构体数组，输入时直接以 ID 作为下标进行输入</p>
<ul>
<li>
<p>结构体进行存储，需要自行添加的变量有： <code>isShow</code>只要有一条通过编译，置为 true 表示可以输出； <code>passnum</code>表示满分题目数量</p>
</li>
<li>
<p>输入记录时会有一个人重复提交的情况，每次比对相同 ID 是不现实的，直接创建一个数据规模为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的结构体数组，以 ID 作为下标进行记录提交处理</p>
</li>
<li>
<p>输入的成绩不止未通过和有成绩两种状态，还有未提交的情况，将成绩的初始值置为 -2 表示未提交</p>
</li>
<li>
<p>记录输入完成根据有效成绩，计算 total_score 和 passnum</p>
</li>
<li>
<p>进行排序后为每名同学赋值 rank，然后判断 isShow 的值循环输出</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, m; <span class="comment">// 总人数，问题数和提交记录的数量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Record</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rank, Id, passnum = <span class="number">0</span>;              <span class="comment">//passnum 表示完美通过的数量</span></span><br><span class="line">    <span class="type">int</span> score[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>&#125;; <span class="comment">//-2== 没有提交过；-1== 没通过编译</span></span><br><span class="line">    <span class="type">bool</span> isShow = <span class="literal">false</span>;                    <span class="comment">// 若没有一条能够通过编译不显示</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Record a, Record b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.score[<span class="number">0</span>] != b.score[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.score[<span class="number">0</span>] &gt;= b.score[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.passnum != b.passnum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.passnum &gt;= b.passnum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.Id &lt; b.Id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;k, &amp;m);</span><br><span class="line">    <span class="function">vector&lt;Record&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;     <span class="comment">// 输入记录的时候遍历寻找是哪个人进行提交是不现实的，直接用 ID 作为下标</span></span><br><span class="line">    <span class="type">int</span> full_score[k];           <span class="comment">// 保存每道题目的成绩上限</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="comment">// 题号从 1 开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;full_score[i]); <span class="comment">// 输入每一题的满分</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> Id, pro_num, score_obt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;Id, &amp;pro_num, &amp;score_obt);</span><br><span class="line">        v[Id].Id = Id;</span><br><span class="line">        v[Id].score[pro_num] = <span class="built_in">max</span>(v[Id].score[pro_num], score_obt); <span class="comment">// 多次提交保留最大值</span></span><br><span class="line">        <span class="keyword">if</span> (score_obt != <span class="number">-1</span>)                                         <span class="comment">// 只要有成绩就置为可以输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            v[Id].isShow = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 输入处理完成</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 学生的序号一直到 n</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) <span class="comment">// 题目的序号一直到 k</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i].score[j] != <span class="number">-2</span> &amp;&amp; v[i].score[j] != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                v[i].score[<span class="number">0</span>] += v[i].score[j]; <span class="comment">// 相加有效成绩</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v[i].score[j] == full_score[j])</span><br><span class="line">            &#123;</span><br><span class="line">                v[i].passnum++; <span class="comment">// 记录满分数量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>(), cmp); <span class="comment">//0 恒为空值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)       <span class="comment">// 赋予排名</span></span><br><span class="line">    &#123;</span><br><span class="line">        v[i].rank = i;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span> &amp;&amp; v[i].score[<span class="number">0</span>] == v[i - <span class="number">1</span>].score[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            v[i].rank = v[i - <span class="number">1</span>].rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 处理完成</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i].isShow) <span class="comment">// 判断有无输出条件按格式输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %05d %d&quot;</span>, v[i].rank, v[i].Id, v[i].score[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i].score[j] != <span class="number">-1</span> &amp;&amp; v[i].score[j] != <span class="number">-2</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, v[i].score[j]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (v[i].score[j] == <span class="number">-2</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; -&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; 0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1083"><a class="markdownIt-Anchor" href="#1083"></a> 1083</h4>
<p><strong>题目：List Grades</strong></p>
<p>Given a list of N student records with name, ID and grade. You are supposed to sort the records with respect to the grade in non-increasing order, and output those student records of which the grades are in a given interval.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case is given in the following format:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">N</span><br><span class="line">name[<span class="number">1</span>] ID[<span class="number">1</span>] grade[<span class="number">1</span>]</span><br><span class="line">name[<span class="number">2</span>] ID[<span class="number">2</span>] grade[<span class="number">2</span>]</span><br><span class="line">... ...</span><br><span class="line">name[N] ID[N] grade[N]</span><br><span class="line">grade1 grade2</span><br></pre></td></tr></table></figure>
<p>where <code>name[i]</code> and <code>ID[i]</code> are strings of no more than 10 characters with no space, <code>grade[i]</code> is an integer in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>, <code>grade1</code> and <code>grade2</code> are the boundaries of the grade’s interval. It is guaranteed that all the grades are <strong>distinct</strong>.</p>
<p><em>Output Specification:</em></p>
<p>For each test case you should output the student records of which the grades are in the given interval [<code>grade1</code> , <code>grade2</code> ] and are in non-increasing order. Each student record occupies a line with the student’s name and ID, separated by one space. If there is no student’s grade in that interval, output <code>NONE</code> instead.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>4<br />
Tom CS000001 59<br />
Joe Math990112 89<br />
Mike CS991301 100<br />
Mary EE990830 95<br />
60 100</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>Mike CS991301<br />
Mary EE990830<br />
Joe Math990112</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>2<br />
Jean AA980920 60<br />
Ann CS01 80<br />
90 95</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>NONE</p>
</blockquote>
<p><strong>思路：</strong> 输入完成后根据区间判断，记录符合范围的个数，不符合将值改为 -1，排序输出</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    string name, Id;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Student a, Student b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;Student&gt; stu;</span><br><span class="line">    Student temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; temp.name &gt;&gt; temp.Id &gt;&gt; temp.score;</span><br><span class="line">        stu.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> low, height;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; low &gt;&gt; height;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stu.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (stu[i].score &lt; low || stu[i].score &gt; height)</span><br><span class="line">        &#123;</span><br><span class="line">            stu[i].score = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(stu.<span class="built_in">begin</span>(), stu.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; stu[i].name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; stu[i].Id &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NONE\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1080"><a class="markdownIt-Anchor" href="#1080"></a> 1080</h4>
<p><strong>题目：Graduate Admission</strong></p>
<p>It is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure.</p>
<p>Each applicant will have to provide two grades: the national entrance exam grade <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>E</mi></msub></mrow><annotation encoding="application/x-tex">G_E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, and the interview grade <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>I</mi></msub></mrow><annotation encoding="application/x-tex">G_I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. The final grade of an applicant is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>G</mi><mi>E</mi></msub><mo>+</mo><msub><mi>G</mi><mi>I</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(G_E+G_I)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>. The admission rules are:</p>
<ul>
<li>
<p>The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list.</p>
</li>
<li>
<p>If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>E</mi></msub></mrow><annotation encoding="application/x-tex">G_E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. If still tied, their ranks must be the same.</p>
</li>
<li>
<p>Each applicant may have K choices and the admission will be done according to his/her choices: if according to the rank list, it is one’s turn to be admitted; and if the quota of one’s most preferred shcool is not exceeded, then one will be admitted to this school, or one’s other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected.</p>
</li>
<li>
<p>If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, <strong>even if its quota will be exceeded</strong>.</p>
</li>
</ul>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case.Each case starts with a line containing three positive integers: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>40</mn><mo separator="true">,</mo><mn>000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤40,000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the total number of applicants; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M (≤100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the total number of graduate schools; and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K(≤5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mclose">)</span></span></span></span>, the number of choices an applicant may have.</p>
<p>In the next line, separated by a space, there are M positive integers. The i-th integer is the quota of the i-th graduate school respectively.</p>
<p>Then N lines follow, each contains 2+K integers separated by a space. The first 2 integers are the applicant’s <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>E</mi></msub></mrow><annotation encoding="application/x-tex">G_E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>I</mi></msub></mrow><annotation encoding="application/x-tex">G_I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, respectively. The next K integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to M−1, and the applicants are numbered from 0 to N−1.</p>
<p><em>Output Specification:</em></p>
<p>For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants’ numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>11 6 3<br />
2 1 2 2 2 3<br />
100 100 0 1 2<br />
60 60 2 3 5<br />
100 90 0 3 4<br />
90 100 1 2 0<br />
90 90 5 1 3<br />
80 90 1 0 2<br />
80 80 0 1 2<br />
80 70 1 3 2<br />
70 80 1 2 3<br />
100 100 0 2 4</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>0 10<br />
3<br />
5 6 7<br />
2 8<br />
1 4</p>
</blockquote>
<p><strong>思路：</strong> 同时建立学生学校两个结构体分别进行处理</p>
<ul>
<li>
<p>学校结构体创建一个 last 变量，方便比对招满后最后一人的排名是否有与之并列的存在</p>
</li>
<li>
<p>学生结构体创建 ID 变量和 rank 保存原始编号和排名</p>
</li>
<li>
<p>按成绩排序分配排名后，对每个学生进行处理，遍历每个学生的志愿，判断是否达到入校条件</p>
</li>
<li>
<p>对每个学校的招入名单排序输出</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">School</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> quota, last;   <span class="comment">//last 为录取的最后一个学生用来判断同排名</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; admit; <span class="comment">// 被录取的学生放到该数组</span></span><br><span class="line">&#125; school[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Applicant</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Id, rnk, Ge, Gi, G; <span class="comment">// 学生 ID 要单独保存</span></span><br><span class="line">    <span class="type">int</span> choice[<span class="number">5</span>];</span><br><span class="line">&#125; alct[<span class="number">40000</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M, K;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Applicant a, Applicant b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.G != b.G)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.G &gt; b.G;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.Ge &gt; b.Ge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; school[i].quota; <span class="comment">// 输入每个学校的招生人数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; alct[i].Ge &gt;&gt; alct[i].Gi;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; K; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; alct[i].choice[j];</span><br><span class="line">        &#125;</span><br><span class="line">        alct[i].G = alct[i].Ge + alct[i].Gi; <span class="comment">// 相加即可</span></span><br><span class="line">        alct[i].Id = i;                      <span class="comment">// 将编号保存，排序后仍使用原始编号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(alct, alct + N, cmp); <span class="comment">// 将学生按成绩排名</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || alct[i].G != alct[i - <span class="number">1</span>].G || alct[i].Ge != alct[i - <span class="number">1</span>].Ge)</span><br><span class="line">        &#123; <span class="comment">// 分配名次</span></span><br><span class="line">            alct[i].rnk = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            alct[i].rnk = alct[i - <span class="number">1</span>].rnk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; K; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = alct[i].choice[j]; <span class="comment">// 遍历所有志愿</span></span><br><span class="line">            <span class="keyword">if</span> (school[k].admit.<span class="built_in">size</span>() &lt; school[k].quota || alct[i].rnk == alct[school[k].last].rnk)</span><br><span class="line">            &#123;                                          <span class="comment">// 人数没招满或与招到最后一人的排名相等</span></span><br><span class="line">                school[k].admit.<span class="built_in">push_back</span>(alct[i].Id); <span class="comment">//ID 放入数组</span></span><br><span class="line">                school[k].last = i;                    <span class="comment">// 覆盖最后值</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(school[i].admit.<span class="built_in">begin</span>(), school[i].admit.<span class="built_in">end</span>()); <span class="comment">// 对每个学校照到的学生按序号排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; school[i].admit.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j)</span><br><span class="line">            &#123; <span class="comment">// 不是第一个就输出空格</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; school[i].admit[j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1095"><a class="markdownIt-Anchor" href="#1095"></a> 1095</h4>
<p><strong>题目：Cars on Campus</strong></p>
<p>Zhejiang University has 8 campuses and a lot of gates. From each gate we can collect the in/out times and the plate numbers of the cars crossing the gate. Now with all the information available, you are supposed to tell, at any specific time point, the number of cars parking on campus, and at the end of the day find the cars that have parked for the longest time period.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case starts with two positive integers <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(≤10^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, the number of records, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>8</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K (≤8×10^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> the number of queries. Then N lines follow, each gives a record in the format:</p>
<p><code>plate_number   hh:mm:ss   status</code></p>
<p>where <code>plate_number</code> is a string of 7 English capital letters or 1-digit numbers; <code>hh:mm:ss</code> represents the time point in a day by hour:minute:second, with the earliest time being <code>00:00:00</code> and the latest <code>23:59:59</code> ; and <code>status</code> is either <code>in</code> or <code>out</code> .</p>
<p>Note that all times will be within a single day. Each <code>in</code> record is paired with the chronologically next record for the same car provided it is an <code>out</code> record. Any <code>in</code> records that are not paired with an <code>out</code> record are ignored, as are <code>out</code> records not paired with an <code>in</code> record. It is guaranteed that at least one car is well paired in the input, and no car is both <code>in</code> and <code>out</code> at the same moment. Times are recorded using a 24-hour clock.</p>
<p>Then K lines of queries follow, each gives a time point in the format <code>hh:mm:ss</code> . Note: the queries are given in <strong>ascending</strong> order of the times.</p>
<p><em>Output Specification:</em></p>
<p>For each query, output in a line the total number of cars parking on campus. The last line of output is supposed to give the plate number of the car that has parked for the longest time period, and the corresponding time length. If such a car is not unique, then output all of their plate numbers in a line in alphabetical order, separated by a space.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>16 7<br />
JH007BD 18:00:01 in<br />
ZD00001 11:30:08 out<br />
DB8888A 13:00:00 out<br />
ZA3Q625 23:59:50 out<br />
ZA133CH 10:23:00 in<br />
ZD00001 04:09:59 in<br />
JH007BD 05:09:59 in<br />
ZA3Q625 11:42:01 out<br />
JH007BD 05:10:33 in<br />
ZA3Q625 06:30:50 in<br />
JH007BD 12:23:42 out<br />
ZA3Q625 23:55:00 in<br />
JH007BD 12:24:23 out<br />
ZA133CH 17:11:22 out<br />
JH007BD 18:07:01 out<br />
DB8888A 06:30:50 in<br />
05:10:00<br />
06:30:50<br />
11:00:00<br />
12:23:42<br />
14:00:00<br />
18:00:00<br />
23:59:00</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>1<br />
4<br />
5<br />
2<br />
1<br />
0<br />
1<br />
JH007BD ZD00001 07:20:09</p>
</blockquote>
<p><strong>思路：</strong> 使用 MAP 集合存储数据，车牌号为键，结构体数组为值</p>
<ul>
<li>
<p>使用结构体对出入记录进行存储，同时计算记录是在一天中的第几秒</p>
</li>
<li>
<p>遍历集合，将每个车牌对应的记录数组进行排序，进行出入配对，将当前时间点放入出入数组中，并累积一个车牌号停车的时长</p>
</li>
<li>
<p>遍历一天中的 86400 秒，将每秒的停车数量记录下来，公式：时间点前的所有进减去所有出</p>
</li>
<li>
<p>比较所有时长取出停车时间最长的，并列也放入数组，然后对车牌号排序</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Record</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    string p_num, statu;</span><br><span class="line">    <span class="type">int</span> hour, mintue, second, time; <span class="comment">// 存储当前时间点在一天中是第多少秒</span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line">unordered_map&lt;string, vector&lt;Record&gt;&gt; msvr; <span class="comment">// 记录集合</span></span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; msi; <span class="comment">// 停靠时间集合</span></span><br><span class="line"><span class="type">int</span> N, K; </span><br><span class="line"><span class="type">int</span> in_school[<span class="number">86400</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 在这一秒有多少车辆进入</span></span><br><span class="line"><span class="type">int</span> out_school[<span class="number">86400</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 在这一秒有多少车辆出去</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Record a, Record b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.time &lt; b.time; <span class="comment">// 时间从早到晚排序</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Record temp;</span><br><span class="line">        cin &gt;&gt; temp.p_num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d&quot;</span>, &amp;temp.hour, &amp;temp.mintue, &amp;temp.second);</span><br><span class="line">        cin &gt;&gt; temp.statu;</span><br><span class="line">        temp.time = temp.hour * <span class="number">3600</span> + temp.mintue * <span class="number">60</span> + temp.second;</span><br><span class="line">        msvr[temp.p_num].<span class="built_in">push_back</span>(temp); <span class="comment">// 将每次输入的记录放到车牌号对应的数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : msvr) <span class="comment">// 遍历集合</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> v = it.second; <span class="comment">// 将每个车牌号对应的数组取出</span></span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i].statu == <span class="string">&quot;in&quot;</span>) <span class="comment">// 进行配对处理</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; v.<span class="built_in">size</span>() &amp;&amp; v[i + <span class="number">1</span>].statu == <span class="string">&quot;out&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    in_school[v[i].time]++; <span class="comment">// 将 in 的状态放到对应的时间点</span></span><br><span class="line">                    out_school[v[i + <span class="number">1</span>].time]++;</span><br><span class="line">                    msi[it.first] += v[i + <span class="number">1</span>].time - v[i].time; <span class="comment">// 统计停车时长</span></span><br><span class="line">                    i += <span class="number">2</span>;                                     <span class="comment">// 下一组</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> car_cnt[<span class="number">86400</span>];</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">86400</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += in_school[i];</span><br><span class="line">        t -= out_school[i];</span><br><span class="line">        car_cnt[i] = t; <span class="comment">// 每个时间的车辆 == 之前所有的进 - 所有的出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t_h, t_m, t_s; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; K; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d&quot;</span>, &amp;t_h, &amp;t_m, &amp;t_s); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, car_cnt[t_h * <span class="number">3600</span> + t_m * <span class="number">60</span> + t_s]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max_time = <span class="number">0</span>; </span><br><span class="line">    vector&lt;string&gt; maxcars; <span class="comment">// 存储并列的最久车辆，保存车牌号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : msi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.second &gt; max_time)</span><br><span class="line">        &#123;</span><br><span class="line">            max_time = it.second; </span><br><span class="line">            maxcars = &#123;it.first&#125;; <span class="comment">// 现在是唯一的答案，直接赋值（不使用放入，因为每次赋值都要清空前面所有的）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (it.second == max_time)</span><br><span class="line">        &#123;</span><br><span class="line">            maxcars.<span class="built_in">push_back</span>(it.first); <span class="comment">// 现在是并列的答案，放入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(maxcars.<span class="built_in">begin</span>(), maxcars.<span class="built_in">end</span>()); <span class="comment">// 根据字符排序</span></span><br><span class="line">    <span class="keyword">for</span> (string each : maxcars)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; each &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d&quot;</span>, max_time / <span class="number">3600</span>, max_time / <span class="number">60</span> % <span class="number">60</span>, max_time % <span class="number">60</span>); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a class="markdownIt-Anchor" href="# 总结"></a> 总结</h3>
<ol>
<li>如果需要对排序进行查询，一定要数据全部处理完成后再放入 MAP 集合或其他容器中，不然会导致下标混乱，如 T1012</li>
<li>排序型算法要处理的数据难免过大，可以采用以下方式缩小复杂度：
<ul>
<li>将局部变量定义在循环外，尽量缩小循环内的执行语句量</li>
<li>输入输出函数使用 scanf() 和 printf()，字符串可以使用字符数组，排序使用 strcmp() 函数</li>
<li>局部多次排序可以使用单次排序，尤其对大型数据的小型查询，如 T1028</li>
</ul>
</li>
<li>循环中进行比较的动态数组，不要直接放入，存在每次比较过后要清空之前数据的可能，直接赋值，如 T095</li>
</ol>
<h2 id="散列"><a class="markdownIt-Anchor" href="# 散列"></a> 散列</h2>
<h3 id="思想解释 -2"><a class="markdownIt-Anchor" href="# 思想解释 -2"></a> 思想解释</h3>
<p>将元素通过某种方式转换为整数使其尽量唯一的表示这个元素的特质</p>
<p>如：求在长度为 N 的数组中，求 M 个数有没有出现过，就可以设置一个 judge[] 以 Ni 作为下标，将值置为 true，查询时只需判断 Mi 作为下标时值是否为 true 即可</p>
<p>将直接输入的数作为数组下标直接表示这个数的特质的方式经常使用</p>
<h3 id="类型练习 -2"><a class="markdownIt-Anchor" href="# 类型练习 -2"></a> 类型练习</h3>
<h4 id="1084"><a class="markdownIt-Anchor" href="#1084"></a> 1084</h4>
<p><strong>题目：Broken Keyboard</strong></p>
<p>On a broken keyboard, some of the keys are worn out. So when you type some sentences, the characters corresponding to those keys will not appear on screen.</p>
<p>Now given a string that you are supposed to type, and the string that you actually type out, please list those keys which are for sure worn out.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the 1st line contains the original string, and the 2nd line contains the typed-out string. Each string contains no more than 80 characters which are either English letters <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>A</mi><mo>−</mo><mi>Z</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[A-Z]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">]</span></span></span></span> (case insensitive), digital numbers <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>−</mo><mn>9</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0-9]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">9</span><span class="mclose">]</span></span></span></span>, or <code>_</code> (representing the space). It is guaranteed that both strings are non-empty.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in one line the keys that are worn out, in the order of being detected. The English letters must be capitalized. Each worn out key must be printed once only. It is guaranteed that there is at least one worn out key.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>7_This_is_a_test<br />
_hs_s_a_es</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>7TI</p>
</blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>
<p>字符串写法：遍历预想字符串的每个字符去实际字符串中查找，如果本身和它大写形式查找的返回值都是<code>string::npos</code>，保留其大写形式</p>
</li>
<li>
<p>散列写法：设立一个标记数组（字符会自动转为 ASCII 码作为数字下标），遍历预想字符串，如果不相同且没被标记过，放入数组</p>
</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 字符串写法</span></span><br><span class="line"><span class="comment">    string s1, s2, ans;</span></span><br><span class="line"><span class="comment">    cin &gt;&gt; s1 &gt;&gt; s2;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; s1.length(); i++) // 遍历字符串 1 中的每个字符去字符串 2 中查找</span></span><br><span class="line"><span class="comment">        if (s2.find(s1[i]) == string::npos &amp;&amp; ans.find(toupper(s1[i])) == string::npos)</span></span><br><span class="line"><span class="comment">        &#123; // 查找字符和字符的大写，查找失败返回 string::npos</span></span><br><span class="line"><span class="comment">            ans += toupper(s1[i]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; ans;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> flag[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; vc;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s1.<span class="built_in">length</span>()) <span class="comment">// 遍历全部的预想结果</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i] != s2[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag[s1[i]]) <span class="comment">// 还没有标记过</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag[<span class="built_in">tolower</span>(s1[i])] = <span class="number">1</span>;</span><br><span class="line">                flag[<span class="built_in">toupper</span>(s1[i])] = <span class="number">1</span>;     <span class="comment">// 将大小写全部标记成 1</span></span><br><span class="line">                vc.<span class="built_in">push_back</span>(<span class="built_in">toupper</span>(s1[i])); <span class="comment">// 放入大写形式</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i : vc)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1092"><a class="markdownIt-Anchor" href="#1092"></a> 1092</h4>
<p><strong>题目：To Buy or Not to Buy</strong></p>
<p>Eva would like to make a string of beads with her favorite colors so she went to a small shop to buy some beads. There were many colorful strings of beads. However the owner of the shop would only sell the strings in whole pieces. Hence Eva must check whether a string in the shop contains all the beads she needs. She now comes to you for help: if the answer is <code>Yes</code> , please tell her the number of extra beads she has to buy; or if the answer is <code>No</code> , please tell her the number of beads missing from the string.</p>
<p>For the sake of simplicity, let’s use the characters in the ranges <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>−</mo><mn>9</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0-9]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">9</span><span class="mclose">]</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>−</mo><mi>z</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a-z]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">]</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>A</mi><mo>−</mo><mi>Z</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[A-Z]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">]</span></span></span></span> to represent the colors. For example, the 3rd string in Figure 1 is the one that Eva would like to make. Then the 1st string is okay since it contains all the necessary beads with 8 extra ones; yet the 2nd one is not since there is no black bead and one less red bead.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case gives in two lines the strings of no more than 1000 beads which belong to the shop owner and Eva, respectively.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print your answer in one line. If the answer is <code>Yes</code> , then also output the number of extra beads Eva has to buy; or if the answer is <code>No</code> , then also output the number of beads missing from the string. There must be exactly 1 space between the answer and the number.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>ppRYYGrrYBR2258<br />
YrR8RrY</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>Yes 8</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>ppRYYGrrYB225<br />
YrR8RrY</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>No 2</p>
</blockquote>
<p><strong>思路：</strong> 使用数组或集合对每个颜色的个数进行记录，减去需要购买的值（且个数不为 0），不存在将 lack++；根据 lack 进行输出</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mci;</span><br><span class="line">    string str1, str2;</span><br><span class="line">    cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">    <span class="comment">/* 数组下标标记法</span></span><br><span class="line"><span class="comment">    int book[256];</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; str1.length(); i++)</span></span><br><span class="line"><span class="comment">        book[str1[i]]++;</span></span><br><span class="line"><span class="comment">    int result = 0;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; str2.length(); i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if (book[str2[i]] &gt; 0)</span></span><br><span class="line"><span class="comment">            book[str2[i]]--;</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            result++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 集合标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str1.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mci.<span class="built_in">count</span>(str1[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            mci[str1[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mci[str1[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lack = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str2.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mci.<span class="built_in">count</span>(str2[i]) &amp;&amp; mci[str2[i]] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mci[str2[i]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            lack++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!lack)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes &quot;</span> &lt;&lt; str1.<span class="built_in">length</span>() - str2.<span class="built_in">length</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No &quot;</span> &lt;&lt; lack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1041"><a class="markdownIt-Anchor" href="#1041"></a> 1041</h4>
<p><strong>题目：Be Unique</strong></p>
<p>Being unique is so important to people on Mars that even their lottery is designed in a unique way. The rule of winning is simple: one bets on a number chosen from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>. The first one who bets on a unique number wins. For example, if there are 7 people betting on {5 31 5 88 67 88 17}, then the second one who bets on 31 wins.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case contains a line which begins with a positive integer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and then followed by N bets. The numbers are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print the winning number in a line. If there is no winner, print <code>None</code> instead.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>7 5 31 5 88 67 88 17</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>31</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>5 888 666 666 888 888</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>None</p>
</blockquote>
<p><strong>思路：</strong> 使用两个数组分别记录个数和输入顺序</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag[<span class="number">100001</span>] = &#123;<span class="number">0</span>&#125;, num[<span class="number">100000</span>]; <span class="comment">//flag 进行个数统计，num 记录输入顺序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; num[i];</span><br><span class="line">        flag[num[i]]++; <span class="comment">// 将输入的数作为下标自增</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> f = <span class="literal">true</span>; <span class="comment">// 判断是否有符合条件的值输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[num[i]] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; num[i];</span><br><span class="line">            f = <span class="literal">false</span>; <span class="comment">// 有输出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;None&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1050"><a class="markdownIt-Anchor" href="#1050"></a> 1050</h4>
<p><strong>题目：String Subtraction</strong></p>
<p>Given two strings S1 and S2, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi>S</mi><mn>1</mn><mtext>−</mtext><mi>S</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">S=S1−S2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">2</span></span></span></span> is defined to be the remaining string after taking all the characters in S2 from S1. Your task is simply to calculate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn><mtext>−</mtext><mi>S</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">S1−S2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">2</span></span></span></span> for any given strings. However, it might not be that simple to do it <strong>fast</strong>.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case consists of two lines which gives S1 and S2, respectively. The string lengths of both strings are no more than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>. It is guaranteed that all the characters are visible ASCII codes and white space, and a new line character signals the end of a string.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn><mtext>−</mtext><mi>S</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">S1−S2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">2</span></span></span></span> in one line.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>They are students.<br />
aeiou</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>Thy r stdnts.</p>
</blockquote>
<p><strong>思路：</strong> 使用数组以字符的 ASCII 码为下标标记 S1 中每个出现的字符值为 1，S2 出现的字符置为 0，遍历 S1 只输出标记数组值为 1 的字符</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string str1, str2; </span><br><span class="line">    <span class="built_in">getline</span>(cin, str1); </span><br><span class="line">    <span class="built_in">getline</span>(cin, str2); </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str1.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag[str1[i]] = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str2.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag[str2[i]] = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str1.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[str1[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; str1[i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1048"><a class="markdownIt-Anchor" href="#1048"></a> 1048</h4>
<p><strong>题目：Find Coins</strong></p>
<p>Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she could only use exactly two coins to pay the exact amount. Since she has as many as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span> coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find two coins to pay for it.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains 2 positive numbers: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">N (≤10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>, the total number of coins) and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">M(≤10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>, the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers no more than 500. All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in one line the two face values V1 and V2 (separated by a space) such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mn>1</mn><mo>+</mo><mi>V</mi><mn>2</mn><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">V1+V2=M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mn>1</mn><mo>≤</mo><mi>V</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">V1≤V2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">2</span></span></span></span>. If such a solution is not unique, output the one with the smallest V1. If there is no solution, output <code>No Solution</code> instead.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>8 15<br />
1 2 8 7 2 4 11 15</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>4 11</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>7 14<br />
1 8 7 2 4 11 15</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>No Solution</p>
</blockquote>
<p><strong>思路：</strong> 使用数组标记每个面值出现的次数，然后从 1 到 bill 对每一个面值进行遍历（规则就是从小到大），判断输出</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag[<span class="number">1001</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 用来统计每个面值出现了几次</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, temp;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        flag[temp]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) <span class="comment">// 对每个面值的硬币从小到大判断（保证输出规则）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[i]) <span class="comment">// 当前面值存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag[i]--;       <span class="comment">// 存在就 -1，防止出现一个数出现了一次但它的二倍等于 bill</span></span><br><span class="line">            <span class="keyword">if</span> (flag[m - i]) <span class="comment">// 符合相加条件的硬币也存在</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m - i; <span class="comment">// 输出</span></span><br><span class="line">                <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="贪心"><a class="markdownIt-Anchor" href="# 贪心"></a> 贪心</h2>
<h3 id="思想解释 -3"><a class="markdownIt-Anchor" href="# 思想解释 -3"></a> 思想解释</h3>
<p>总是做出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择</p>
<h3 id="类型练习 -3"><a class="markdownIt-Anchor" href="# 类型练习 -3"></a> 类型练习</h3>
<h4 id="1070"><a class="markdownIt-Anchor" href="#1070"></a> 1070</h4>
<p><strong>题目：Mooncake</strong></p>
<p>Mooncake is a Chinese bakery product traditionally eaten during the Mid-Autumn Festival. Many types of fillings and crusts can be found in traditional mooncakes according to the region’s culture. Now given the inventory amounts and the prices of all kinds of the mooncakes, together with the maximum total demand of the market, you are supposed to tell the maximum profit that can be made.</p>
<p>Note: partial inventory storage can be taken. The sample shows the following situation: given three kinds of mooncakes with inventory amounts being 180, 150, and 100 thousand tons, and the prices being 7.5, 7.2, and 4.5 billion yuans. If the market demand can be at most 200 thousand tons, the best we can do is to sell 150 thousand tons of the second kind of mooncake, and 50 thousand tons of the third kind. Hence the total profit is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7.2</mn><mo>+</mo><mn>4.5</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><mn>9.45</mn></mrow><annotation encoding="application/x-tex">7.2 + 4.5/2 = 9.45</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">7</span><span class="mord">.</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord">.</span><span class="mord">5</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">.</span><span class="mord">4</span><span class="mord">5</span></span></span></span> (billion yuans).</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains 2 positive integers <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(≤1000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the number of different kinds of mooncakes, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">D(≤500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span> thousand tons), the maximum total demand of the market. Then the second line gives the positive inventory amounts (in thousand tons), and the third line gives the positive prices (in billion yuans) of N kinds of mooncakes. All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print the maximum profit (in billion yuans) in one line, accurate up to 2 decimal places.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>3 200<br />
180 150 100<br />
7.5 7.2 4.5</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>9.45</p>
</blockquote>
<p><strong>思路：</strong> 使用结构体放入数组，根据单价排序，循环判断需求量计算收益</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mooncake</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> quality, single_price, total_price; <span class="comment">// 全国用 double 型，防止精确度不够</span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, D; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Mooncake a, Mooncake b)</span> <span class="comment">// 按单价排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.single_price &gt; b.single_price;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; N &gt;&gt; D; </span><br><span class="line">    <span class="function">vector&lt;Mooncake&gt; <span class="title">mc</span><span class="params">(N)</span></span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; mc[i].quality; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; mc[i].total_price; </span><br><span class="line">        mc[i].single_price = mc[i].total_price / mc[i].quality; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(mc.<span class="built_in">begin</span>(), mc.<span class="built_in">end</span>(), cmp); <span class="comment">// 输入后按照单价进行排序</span></span><br><span class="line">    <span class="type">double</span> profit = <span class="number">0.0</span>; </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (D &amp;&amp; i &lt; mc.<span class="built_in">size</span>()) <span class="comment">// 注意可能存在所有种类的总量不够需求量的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (D &gt; mc[i].quality)</span><br><span class="line">        &#123;</span><br><span class="line">            profit += mc[i].total_price; <span class="comment">// 需求量仍超过当前种类的质量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            profit += D * mc[i].single_price; <span class="comment">// 不足将剩余量乘单价</span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        D -= mc[i].quality; <span class="comment">// 去掉已经购买的</span></span><br><span class="line">        i++; <span class="comment">// 判断下一组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>, profit); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1033"><a class="markdownIt-Anchor" href="#1033"></a> 1033</h4>
<p><strong>题目：To Fill or Not to Fill</strong></p>
<p>With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains 4 positive numbers: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Cmax (≤ 100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the maximum capacity of the tank; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>30000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(≤30000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the distance between Hangzhou and the destination city; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>a</mi><mi>v</mi><mi>g</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>20</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Davg (≤20)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the average distance per unit gas that the car can run; and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>500</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(≤ 500)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: Pi, the unit gas price, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mo>≤</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D_i(≤D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span></span></span></span>, the distance between this station and Hangzhou, for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mo separator="true">,</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">i=1,⋯,N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>. All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print <code>The maximum travel distance = X</code> where <code>X</code> is the maximum possible distance the car can run, accurate up to 2 decimal places.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>50 1300 12 8<br />
6.00 1250<br />
7.00 600<br />
7.00 150<br />
7.10 0<br />
7.20 200<br />
7.50 400<br />
7.30 1000<br />
6.85 300</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>749.17</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>50 1300 12 2<br />
7.10 0<br />
7.00 600</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>The maximum travel distance = 1200.00</p>
</blockquote>
<p><strong>思路：</strong> 将终点也作为加油站的形式进行存储，对所有的加油站按照距离进行排序，每次从起点判断满油状态下可以到达的加油站中油价最便宜的一个，根据价格进行不同的处理</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">station</span> <span class="comment">// 加油站的结构体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> price, distance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Cmax, D, Davg;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">station sta[<span class="number">501</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(station a, station b)</span> <span class="comment">// 将所有加油站按距离排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.distance &lt; b.distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; Cmax &gt;&gt; D &gt;&gt; Davg &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; sta[i].price &gt;&gt; sta[i].distance;</span><br><span class="line">    &#125;</span><br><span class="line">    sta[N].price = <span class="number">0</span>;</span><br><span class="line">    sta[N].distance = D;     <span class="comment">// 将终点作为加油站的形式方便循环处理</span></span><br><span class="line">    <span class="built_in">sort</span>(sta, sta + N, cmp); <span class="comment">// 按距离排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sta[<span class="number">0</span>].distance != <span class="number">0</span>) <span class="comment">// 如果起点位置没有加油站</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The maximum travel distance = 0.00&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">0</span>, nowTank = <span class="number">0</span>, max_dis = Cmax * Davg;</span><br><span class="line">        <span class="keyword">while</span> (now &lt; N) <span class="comment">// 循环模拟每一个站</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line">            <span class="type">double</span> minP = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = now + <span class="number">1</span>; i &lt;= N &amp;&amp; sta[i].distance - sta[now].distance &lt;= max_dis; i++)</span><br><span class="line">            &#123; <span class="comment">// 循环判断满油状态下的最长距离中油价最便宜的一个站</span></span><br><span class="line">                <span class="keyword">if</span> (sta[i].price &lt; minP)</span><br><span class="line">                &#123;</span><br><span class="line">                    minP = sta[i].price;</span><br><span class="line">                    k = i;</span><br><span class="line">                    <span class="keyword">if</span> (minP &lt; sta[now].price)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">-1</span>) <span class="comment">// 没找到跳出</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> need = (sta[k].distance - sta[now].distance) / Davg; <span class="comment">// 到最便宜站需要加的油</span></span><br><span class="line">            <span class="keyword">if</span> (minP &lt;= sta[now].price)                                 <span class="comment">// 又可以到达价格小于当前的站</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nowTank &lt; need) <span class="comment">// 当前油箱无法到达</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans += (need - nowTank) * sta[now].price;</span><br><span class="line">                    nowTank = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nowTank -= need;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans += (Cmax - nowTank) * sta[now].price;</span><br><span class="line">                nowTank = Cmax - need;</span><br><span class="line">            &#125;</span><br><span class="line">            now = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (now == N)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The maximum travel distance = %.2f&quot;</span>, sta[now].distance + max_dis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="1037"><a class="markdownIt-Anchor" href="#1037"></a> 1037</h4>
<p><strong>题目：Magic Coupon</strong></p>
<p>The magic shop in Mars is offering some magic coupons. Each coupon has an integer N printed on it, meaning that when you use this coupon with a product, you may get N times the value of that product back! What is more, the shop also offers some bonus product for free. However, if you apply a coupon with a positive N to this bonus product, you will have to pay the shop N times the value of the bonus product… but hey, magically, they have some coupons with negative N’s!</p>
<p>For example, given a set of coupons {1 2 4 −1}, and a set of product values {7 6 −2 −3} (in Mars dollars M$) where a negative value corresponds to a bonus product. You can apply coupon 3 (with N being 4) to product 1 (with value M$7) to get M$28 back; coupon 2 to product 2 to get M$12 back; and coupon 4 to product 4 to get M$3 back. On the other hand, if you apply coupon 3 to product 4, you will have to pay M$12 to the shop.</p>
<p>Each coupon and each product may be selected at most once. Your task is to get as much money back as possible.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains the number of coupons NC, followed by a line with NC coupon integers. Then the next line contains the number of products NP, followed by a line with NP product values. Here <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>N</mi><mi>C</mi></msub><mo separator="true">,</mo><msub><mi>N</mi><mi>P</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1≤N_C, N_P≤10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>, and it is guaranteed that all the numbers will not exceed <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, simply print in a line the maximum amount of money you can get back.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>4<br />
1 2 4 -1<br />
4<br />
7 6 -2 -3</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>43</p>
</blockquote>
<p><strong>思路：</strong> 将两组数据放入两个数组，将数据从小到大排序，负数从小到大分别相乘，正数从大到小分别相乘，0 不做处理</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m; </span><br><span class="line">    cin &gt;&gt; n; </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">coupon</span><span class="params">(n)</span></span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; coupon[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m; </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">product</span><span class="params">(m)</span></span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; product[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(coupon.<span class="built_in">begin</span>(), coupon.<span class="built_in">end</span>()); </span><br><span class="line">    <span class="built_in">sort</span>(product.<span class="built_in">begin</span>(), product.<span class="built_in">end</span>()); <span class="comment">// 将数组从小到大排序</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, ans = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m &amp;&amp; coupon[i] &lt; <span class="number">0</span> &amp;&amp; product[j] &lt; <span class="number">0</span>) <span class="comment">// 处理负数</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans += coupon[i] * product[j]; </span><br><span class="line">        i++; </span><br><span class="line">        j++; </span><br><span class="line">    &#125;</span><br><span class="line">    i = n - <span class="number">1</span>; </span><br><span class="line">    j = m - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; coupon[i] &gt; <span class="number">0</span> &amp;&amp; product[j] &gt; <span class="number">0</span>) <span class="comment">// 处理正数</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans += coupon[i] * product[j]; </span><br><span class="line">        i--; </span><br><span class="line">        j--; </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1067"><a class="markdownIt-Anchor" href="#1067"></a> 1067</h4>
<p><strong>题目：Sort with Swap(0, i)</strong></p>
<p>Given any permutation of the numbers {0, 1, 2,…, N−1}, it is easy to sort them in increasing order. But what if <code>Swap(0, *)</code> is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Swap</span>(<span class="number">0</span>, <span class="number">1</span>) =&gt; &#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">Swap</span>(<span class="number">0</span>, <span class="number">3</span>) =&gt; &#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>&#125;</span><br><span class="line"><span class="built_in">Swap</span>(<span class="number">0</span>, <span class="number">4</span>) =&gt; &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
<p>Now you are asked to find the minimum number of swaps need to sort the given permutation of the first N nonnegative integers.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case, which gives a positive <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(≤10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> followed by a permutation sequence of {0, 1, …, N−1}. All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each case, simply print in a line the minimum number of swaps need to sort the given permutation.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>10<br />
3 5 7 2 6 4 9 0 8 1</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>9</p>
</blockquote>
<p><strong>思路：</strong> 使用数字作为下标顺序，作为位置的方式存储数组，当每个位置上数字与位置相同表示交换完毕（这样无需进行下标查找）</p>
<ul>
<li>
<p>遍历位置与数字是否对应，当不对应且 0 未处于排列首位时交换 0 与本该在 0 的位置上的数字 <code>swap(per[0], per[per[0]]); </code></p>
</li>
<li>
<p>当 0 回到首位继续判断位置是否对应，若未成功将 0 换到不对应的位置继续判断操作</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n; </span><br><span class="line">    cin &gt;&gt; n; </span><br><span class="line">    <span class="type">int</span> per[n], temp, ans = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; temp; <span class="comment">// 将输入的数作为下标，第几次输入作为位置</span></span><br><span class="line">        per[temp] = i; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != per[i]) <span class="comment">// 当各个数字没有归位</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (per[<span class="number">0</span>] != <span class="number">0</span>) <span class="comment">//0 没有归位便进行调换</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(per[<span class="number">0</span>], per[per[<span class="number">0</span>]]); <span class="comment">// 将 0 所在的位置和其应当存在的的数进行交换</span></span><br><span class="line">                ans++; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != per[i]) <span class="comment">// 一轮调换未能匹配，将 0 换入不匹配的位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(per[<span class="number">0</span>], per[i]); </span><br><span class="line">                ans++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1038"><a class="markdownIt-Anchor" href="#1038"></a> 1038</h4>
<p><strong>题目：Recover the Smallest Number</strong></p>
<p>Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given<br />
{<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mo separator="true">,</mo><mn>321</mn><mo separator="true">,</mo><mn>3214</mn><mo separator="true">,</mo><mn>0229</mn><mo separator="true">,</mo><mn>87</mn></mrow><annotation encoding="application/x-tex">32, 321, 3214, 0229, 87</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord">2</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mord">7</span></span></span></span>}, we can recover many numbers such like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mo>−</mo><mn>321</mn><mo>−</mo><mn>3214</mn><mo>−</mo><mn>0229</mn><mo>−</mo><mn>87</mn></mrow><annotation encoding="application/x-tex">32-321-3214-0229-87</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord">2</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">7</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0229</mn><mo>−</mo><mn>32</mn><mo>−</mo><mn>87</mn><mo>−</mo><mn>321</mn><mo>−</mo><mn>3214</mn></mrow><annotation encoding="application/x-tex">0229-32-87-321-3214</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord">2</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span></span></span></span> with respect to different orders of combinations of these segments, and the smallest number is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0229</mn><mo>−</mo><mn>321</mn><mo>−</mo><mn>3214</mn><mo>−</mo><mn>32</mn><mo>−</mo><mn>87</mn></mrow><annotation encoding="application/x-tex">0229-321-3214-32-87</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">2</span><span class="mord">2</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">7</span></span></span></span>.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case gives a positive integer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤10^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> followed by N number segments. Each segment contains a non-negative integer of no more than 8 digits. All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print the smallest number in one line. Notice that the first digit must not be zero.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>5 32 321 3214 0229 87</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>22932132143287</p>
</blockquote>
<p><strong>思路：</strong> 采用字符串进行读取，定义一个等式相加的排序规则</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b &lt; b + a; <span class="comment">// 如果 a+b&lt;b+a，a 就在前面，否则反之</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string str[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(str, str + n, cmp);</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += str[i]; <span class="comment">// 拼接排序后的字符数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ans.<span class="built_in">length</span>() != <span class="number">0</span> &amp;&amp; ans[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="comment">// 去掉前导零</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans.<span class="built_in">erase</span>(ans.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">length</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分"><a class="markdownIt-Anchor" href="# 二分"></a> 二分</h2>
<h3 id="思想解释 -4"><a class="markdownIt-Anchor" href="# 思想解释 -4"></a> 思想解释</h3>
<p>在有序的排列中，根据目标值 goal 与中间值 mid (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo stretchy="false">(</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo>+</mo><mi>b</mi><mi>e</mi><mi>g</mi><mi>i</mi><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">mid=(end+begin)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>) 的大小关系不断缩小范围的查找方式</p>
<p>mid 的求值：有些数据长度过大，导致 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi><mo>+</mo><mi>b</mi><mi>e</mi><mi>g</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">end+begin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span></span></span></span> 超出当前数据类型的范围，可以采用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mi>b</mi><mi>e</mi><mi>g</mi><mi>i</mi><mi>n</mi><mo>+</mo><mo stretchy="false">(</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo>−</mo><mi>b</mi><mi>e</mi><mi>g</mi><mi>i</mi><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">mid=begin+(end-begin)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 的式子</p>
<p>常使用 [algorithm] 下的 upper_bound(lower_bound) 和 binary_search 方法</p>
<h3 id="类型练习 -4"><a class="markdownIt-Anchor" href="# 类型练习 -4"></a> 类型练习</h3>
<h4 id="1085"><a class="markdownIt-Anchor" href="#1085"></a> 1085</h4>
<p><strong>题目：Perfect Sequence</strong></p>
<p>Given a sequence of positive integers and another positive integer p. The sequence is said to be a <strong>perfect sequence</strong> if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>≤</mo><mi>m</mi><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">M≤m×p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> where M and m are the maximum and minimum numbers in the sequence, respectively.</p>
<p>Now given a sequence and a parameter p, you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains two positive integers N and p, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is the number of integers in the sequence, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p (≤10^9)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is the parameter. In the second line there are N positive integers, each is no greater than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>10 8<br />
2 3 20 4 5 1 6 7 8 9</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>8</p>
</blockquote>
<p><strong>思路：</strong> 将输入的数据从小到大排序，遍历每一个数将它作为 m 计算 M，使用 upper_bound() 函数求出 <strong> 完美队列 </strong> 的长度，取长度最大值</p>
<p>注意：数据范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">m×p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>可能溢出 int 型，所以使用 <code>long long</code> 强转</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, p; </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p; </span><br><span class="line">    <span class="type">int</span> arr[n]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n); <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123; <span class="comment">// 从数组的开始每次找一个数作为 m 进行判断</span></span><br><span class="line">        <span class="type">int</span> bound = <span class="built_in">upper_bound</span>(arr, arr + n, (<span class="type">long</span> <span class="type">long</span>)arr[i] * p) - arr; </span><br><span class="line">        <span class="comment">//arr[i] 作为 m 时符合完美队列条件的长度</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, bound - i); <span class="comment">// 保留最大长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1010"><a class="markdownIt-Anchor" href="#1010"></a> 1010</h4>
<p><strong>题目：Radix</strong></p>
<p>Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is <code>yes</code>, if 6 is a decimal number and 110 is a binary number.</p>
<p>Now for any pair of positive integers <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">N1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">1</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">2</span></span></span></span>, your task is to find the radix of one number while that of the other is given.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case occupies a line which contains 4 positive integers:</p>
<blockquote>
<p>N1 N2 tag radix</p>
</blockquote>
<p>Here <code>N1</code> and <code>N2</code> each has no more than 10 digits. A digit is less than its radix and is chosen from the set {0-9, <code>a</code>-<code>z</code> } where 0-9 represent the decimal numbers 0-9, and <code>a</code>-<code>z</code> represent the decimal numbers 10-35. The last number <code>radix</code> is the radix of <code>N1</code> if <code>tag</code> is 1, or of <code>N2</code> if <code>tag</code> is 2.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in one line the radix of the other number so that the equation <code>N1</code> = <code>N2</code> is true. If the equation is impossible, print <code>Impossible</code>. If the solution is not unique, output the smallest possible radix.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>6 110 1 10</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>2</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>1 ab 1 2</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>Impossible</p>
</blockquote>
<p><strong>思路：</strong> 将确定进制的数转换为十进制，将为判断的数采用二分法来确定进制；<strong>一个数的进制越大，转换为十进制的结果越大</strong>：101 的二进制为 5，但十六进制为 272</p>
<ul>
<li>
<p>编写一个转换函数，其中要解决字符映射问题，手动转换十进制思路：反向循环相加 当前数×指数的位数幂</p>
</li>
<li>
<p>编写查找进制函数，其中要解决的时上下界的确定，下界 low 为单个位最大数 +1，上界 height 位 max(low, 要求数字的十进制），每次二分 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>r</mi><mi>y</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">binary(low,height)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>作为指数转换为十进制，如果得到的数为负数（过大溢出）或超过要求数字的十进制，表示当前进制过大，否者过小，每次更换范围，直到相等</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">convert</span><span class="params">(string str, <span class="type">long</span> <span class="type">long</span> radix)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 将已经确定进制的数转换为十进制</span></span><br><span class="line">    <span class="type">int</span> decimal = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = str.<span class="built_in">rbegin</span>(); it != str.<span class="built_in">rend</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = <span class="built_in">isdigit</span>(*it) ? *it - <span class="string">&#x27;0&#x27;</span> : *it - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">        decimal += temp * <span class="built_in">pow</span>(radix, index++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decimal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">findresult</span><span class="params">(string str, <span class="type">long</span> <span class="type">long</span> decimal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> it = *<span class="built_in">max_element</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());<span class="comment">// 使用函数求出 ASCII 码最大的字符</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> low = (<span class="built_in">isdigit</span>(it) ? it - <span class="string">&#x27;0&#x27;</span> : it - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>) + <span class="number">1</span>;<span class="comment">// 确定下界</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> height = <span class="built_in">max</span>(low, decimal);<span class="comment">// 确定上界</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= height)<span class="comment">// 二分判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mid = low + (height - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp = <span class="built_in">convert</span>(str, mid);</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; <span class="number">0</span> || temp &gt; decimal) <span class="comment">//t 小于 0 表示溢出</span></span><br><span class="line">        &#123;</span><br><span class="line">            height = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp == decimal)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;<span class="comment">// 相等返回 mid 作为指数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 不存在返回 -1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tag = <span class="number">0</span>, radix = <span class="number">0</span>, result_radix;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; tag &gt;&gt; radix;</span><br><span class="line">    <span class="keyword">if</span> (s1 == s2)<span class="comment">// 如果输入直接相等，输出给定的指数</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; radix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result_radix = (tag == <span class="number">1</span>) ? <span class="built_in">findresult</span>(s2, <span class="built_in">convert</span>(s1, radix)) : <span class="built_in">findresult</span>(s1, <span class="built_in">convert</span>(s2, radix));</span><br><span class="line">        <span class="keyword">if</span> (result_radix == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; result_radix;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1044"><a class="markdownIt-Anchor" href="#1044"></a> 1044</h4>
<p><strong>题目：Shopping in Mars</strong></p>
<p>Shopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M). When making the payment, the chain can be cut at any position for only once and some of the diamonds are taken off the chain one by one. Once a diamond is off the chain, it cannot be taken back. For example, if we have a chain of 8 diamonds with values M <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">3, 2, 1, 5, 4, 6, 8, 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span></span></span></span>, and we must pay M 15. We may have 3 options:</p>
<ol>
<li>
<p>Cut the chain between 4 and 6, and take off the diamonds from the position 1 to 5<br />
with values <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>4</mn><mo>=</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">3+2+1+5+4=15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span></p>
</li>
<li>
<p>Cut before 5 or after 6, and take off the diamonds from the position 4 to 6 (with values <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>6</mn><mo>=</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">5+4+6=15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span>).</p>
</li>
<li>
<p>Cut before 8, and take off the diamonds from the position 7 to 8 (with values <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>+</mo><mn>7</mn><mo>=</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">8+7=15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span>).</p>
</li>
</ol>
<p>Now given the chain of diamond values and the amount that a customer has to pay, you are supposed to list all the paying options for the customer.</p>
<p>If it is impossible to pay the exact amount, you must suggest solutions with minimum lost.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains 2 numbers: N (≤105), the total number of diamonds on the chain, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M (≤10^8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, the amount that the customer has to pay. Then the next line contains N positive numbers <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mn>1</mn><mo>⋯</mo><mi>D</mi><mi>N</mi><mo stretchy="false">(</mo><mi>D</mi><mi>i</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mi>f</mi><mi>o</mi><mi>r</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D1⋯DN (Di≤10^3 for all i=1, ⋯, N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> which are the values of the diamonds. All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print <code>i-j</code> in a line for each pair of <code>i</code> ≤ <code>j</code> such that D <code>i</code> + … + D <code>j</code> = M. Note that if there are more than one solution, all the solutions must be printed in increasing order of <code>i</code> .</p>
<p>If there is no solution, output <code>i-j</code> for pairs of <code>i</code> ≤ <code>j</code> such that D <code>i</code> + … + D <code>j</code> &gt;M with (D <code>i</code> + … + D <code>j</code> −M) minimized. Again all the solutions must be printed in increasing order of <code>i</code> .</p>
<p>It is guaranteed that the total value of diamonds is sufficient to pay the given amount.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>16 15<br />
3 2 1 5 4 6 8 7 16 10 15 11 9 12 14 13</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>1-5<br />
4-6<br />
7-8<br />
11-11</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>5 13<br />
2 4 5 7 9</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>2-4<br />
4-5</p>
</blockquote>
<p><strong>思路：</strong> 序列的和是有序递增的，因此一个连续序列和的右端减去左端就是该子序列的和 (must pay)</p>
<ul>
<li>
<p>对有序序列可以采用二分查找的方式，遍历左端点，二分查找右端点，查找值是 &gt;=m，因为可能有无法匹配求最小损失的情况</p>
</li>
<li>
<p>方法函数的参数可以使用 <code>(int i, int &amp;j, int &amp;tempsum)</code>的方式直接改变 j 和 tempsum 的值</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m; </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; sum, resultArr; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> &amp;j, <span class="type">int</span> &amp;tempsum)</span> <span class="comment">// 二分就目标值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = i, right = n;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum[mid] - sum[i - <span class="number">1</span>] &gt;= m) <span class="comment">// 不一定完全匹配，求较大的最小值</span></span><br><span class="line">        &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    j = right;</span><br><span class="line">    tempsum = sum[j] - sum[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    sum.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; sum[i];</span><br><span class="line">        sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> minans = sum[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 遍历所有数字作为左端点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j, tempsum;</span><br><span class="line">        <span class="built_in">Func</span>(i, j, tempsum);  <span class="comment">// 挨个二分查找</span></span><br><span class="line">        <span class="keyword">if</span> (tempsum &gt; minans) <span class="comment">// 如果过大下一次循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tempsum &gt;= m) <span class="comment">// 符合条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tempsum &lt; minans) <span class="comment">// 有更接近目标值的数字便更新集合</span></span><br><span class="line">            &#123;</span><br><span class="line">                resultArr.<span class="built_in">clear</span>();</span><br><span class="line">                minans = tempsum;</span><br><span class="line">            &#125;</span><br><span class="line">            resultArr.<span class="built_in">push_back</span>(i);</span><br><span class="line">            resultArr.<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; resultArr.<span class="built_in">size</span>(); i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; resultArr[i] &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; resultArr[i + <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="双指针"><a class="markdownIt-Anchor" href="# 双指针"></a> 双指针</h2>
<h3 id="思想解释 -5"><a class="markdownIt-Anchor" href="# 思想解释 -5"></a> 思想解释</h3>
<p>使用两个指针指向序列的不同位置，用指针的移动操作减少处理复杂度的方式<br />
其中归并排序和快速排序都可以使用双指针的方式进行编写</p>
<ul>
<li>
<p><strong>归并排序：</strong> 常使用的多为二路归并排序，将一组数分为两两一组进行组内排序，再将每组两两合并进行排序，以此类推</p>
</li>
<li>
<p><strong>快速排序：</strong> 每次挑选一个数字作为比较参照，将大于参照数的值放入右侧，小于放左侧</p>
</li>
</ul>
<h3 id="类型练习 -5"><a class="markdownIt-Anchor" href="# 类型练习 -5"></a> 类型练习</h3>
<h4 id="1089"><a class="markdownIt-Anchor" href="#1089"></a> 1089</h4>
<p><strong>题目：Insert or Merge</strong></p>
<p>According to Wikipedia:</p>
<p><strong>Insertion sort</strong> iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.</p>
<p><strong>Merge sort</strong> works as follows: Divide the unsorted list into N sublists, each containing 1 element (a list of 1 element is considered sorted). Then repeatedly merge two adjacent sublists to produce new sorted sublists until there is only 1 sublist remaining.</p>
<p>Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in the first line either “Insertion Sort” or “Merge Sort” to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>10<br />
3 1 2 8 7 5 9 4 6 0<br />
1 2 3 7 8 5 9 4 6 0</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>Insertion Sort<br />
1 2 3 5 7 8 9 4 6 0</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>10<br />
3 1 2 8 7 5 9 4 0 6<br />
1 3 2 8 5 7 4 9 0 6</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>Merge Sort<br />
1 2 3 8 4 5 7 9 0 6</p>
</blockquote>
<p><strong>思路：</strong> 先判断是否为插入排序，如果不是则一定是归并排序</p>
<ul>
<li>
<p>建立两个初始数组，和目标数组，初始数组中一个用于插入排序，一个用于归并排序</p>
</li>
<li>
<p>注意初始数组不能直接和目标数组相同，否者容易出现双解</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> origin[<span class="number">100</span>], tempOri[<span class="number">100</span>], changed[<span class="number">100</span>]; <span class="comment">// 初始数组，初始备份，目标数组</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[])</span> <span class="comment">// 判断数组相同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != b[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArr</span><span class="params">(<span class="type">int</span> a[])</span> <span class="comment">// 输出方法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insertSort</span><span class="params">()</span> <span class="comment">// 使用布尔型，返回 false 表示其为归并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="comment">// 从第二个元素开始插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span> &amp;&amp; <span class="built_in">isSame</span>(tempOri, changed)) <span class="comment">// 抛开第一次即相同的情况下相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>; <span class="comment">// 判断相同再排序一次，方便输出 next 序列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入排序核心代码</span></span><br><span class="line">        <span class="type">int</span> j = i, temp = tempOri[i];</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">0</span> &amp;&amp; tempOri[j - <span class="number">1</span>] &gt; temp)</span><br><span class="line">        &#123;</span><br><span class="line">            tempOri[j] = tempOri[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        tempOri[j] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="comment">// 当判断成功直接跳出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">()</span> <span class="comment">// 不是插入排序直接使用归并方法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> step = <span class="number">2</span>; step / <span class="number">2</span> &lt;= n; step *= <span class="number">2</span>) <span class="comment">// 归并的遍历方式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (step != <span class="number">2</span> &amp;&amp; <span class="built_in">isSame</span>(origin, changed)) <span class="comment">// 抛开第一次即相同的情况下相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += step) <span class="comment">// 对每组进行排序</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sort</span>(origin + i, origin + <span class="built_in">min</span>(i + step, n)); <span class="comment">// 直接使用 sort 方法即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">showArr</span>(origin);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 在循环中结束记得跳出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; origin[i];</span><br><span class="line">        tempOri[i] = origin[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; changed[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">insertSort</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Insertion Sort&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">showArr</span>(tempOri);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Merge Sort&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">mergeSort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1029"><a class="markdownIt-Anchor" href="#1029"></a> 1029</h4>
<p>** 题目：Median **</p>
<p>Given an increasing sequence S of N integers, the median is the number at the middle position. For example, the median of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn><mo>=</mo><mrow><mn>11</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn></mrow></mrow><annotation encoding="application/x-tex">S1 = {11, 12, 13, 14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span></span></span></span></span> is 12, and the median of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>2</mn><mo>=</mo><mrow><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>16</mn><mo separator="true">,</mo><mn>17</mn></mrow></mrow><annotation encoding="application/x-tex">S2 = {9, 10, 15, 16, 17}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">7</span></span></span></span></span> is 15. The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences. For example, the median of S1 and S2 is 13.</p>
<p>Given two increasing sequences of integers, you are asked to find their median.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case occupies 2 lines, each gives the information of a sequence. For each sequence, the first positive integer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤2×10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is the size of that sequence. Then N integers follow, separated by a space. It is guaranteed that all the integers are in the range of <strong>long int</strong>.</p>
<p><em>Output Specification:</em></p>
<p>For each test case you should output the median of the two given sequences in a line.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>4 11 12 13 14<br />
5 9 10 15 16 17</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>13</p>
</blockquote>
<p><strong>思路：</strong> 只需要输出中位数而无需对整个序列进行处理，所以不必采用合并后排序的方式进行判断，使用双指针判断相应位置</p>
<ul>
<li>
<p>设置 i、j 两个指针分别指向两个数组，每次判断较小值后指针后移，当后移次数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>P</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>÷</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">medianPosition=(N+M-1)÷2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>输出</p>
</li>
<li>
<p>可能存在一个数组的整体数字过于小导致真个数组全部判断完成，两个指针的移动次数和还未到达中位数，所以要在数组的后边界设置一个较大数，int 型最大为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>（代码可以写作 <code>0x7fffffff</code>或 <code>(1&lt;&lt;31)-1</code>）的形式</p>
</li>
<li>
<p>最后到达中位位置时，两个数的值还未进行判断，再次判断指针输出较小值</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sequeN, sequeM;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        sequeN.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        sequeM.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> median = (n + m - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    sequeN[n] = sequeM[m] = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>;<span class="comment">// 将数组边界设置为 2^31-1</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; median)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sequeN[i] &lt; sequeM[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sequeN[i] &lt; sequeM[j])</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; sequeN[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; sequeM[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="其他"><a class="markdownIt-Anchor" href="# 其他"></a> 其他</h2>
<h3 id="思想解释 -6"><a class="markdownIt-Anchor" href="# 思想解释 -6"></a> 思想解释</h3>
<ul>
<li><strong>打表：</strong> 将小范围结果计算出来，直接在程序中调用，用空间换时间</li>
<li><strong>递推：</strong> 大部分算法都是有递推规则的，根据规则编写仅适合这一道题的程序</li>
<li>随机选择：有点玄学</li>
</ul>
<h3 id="类型练习 -6"><a class="markdownIt-Anchor" href="# 类型练习 -6"></a> 类型练习</h3>
<h4 id="1093"><a class="markdownIt-Anchor" href="#1093"></a> 1093</h4>
<p><strong>题目：Count PAT’s</strong></p>
<p>The string <code>APPAPT</code> contains two <code>PAT</code>’s as substrings. The first one is formed by the 2nd, the 4th, and the 6th characters, and the second one is formed by the 3rd, the 4th, and the 6th characters.</p>
<p>Now given any string, you are supposed to tell the number of <code>PAT</code>’s contained in the string.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, there is only one line giving a string of no more than 105 characters containing only <code>P</code>, <code>A</code>, or <code>T</code>.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in one line the number of <code>PAT</code>’s contained in the string. Since the result may be a huge number, you only have to output the result moded by 1000000007.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>APPAPT</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>2</p>
</blockquote>
<p><strong>思路：</strong> 根据递推思想，组成 &quot;PAT&quot; 的个数就是字符’A’左边’P’的个数乘右边’T’的个数</p>
<ul>
<li>
<p>遍历字符串求出每个字符左边 P 的个数</p>
</li>
<li>
<p>反向遍历，遇到 T 计数器 +1，遇到 A 累加相乘取模</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> countP[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="comment">// 获取每个位置左侧字符 &#x27;P&#x27; 的个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            countP[i] = countP[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            countP[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, countT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            countT++; <span class="comment">// 累计 T</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;A&#x27;</span>) <span class="comment">// 遇到 &#x27;A&#x27; 便相加取模</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = (ans + countT * countP[i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1101"><a class="markdownIt-Anchor" href="#1101"></a> 1101</h4>
<p><strong>题目：Quick Sort</strong></p>
<p>There is a classical process named <strong>partition</strong> in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition?</p>
<p>For example, given N=5 and the numbers 1, 3, 2, 4, and 5. We have:</p>
<ul>
<li>
<p>1 could be the pivot since there is no element to its left and all the elements to its right are larger than it;</p>
</li>
<li>
<p>3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well;</p>
</li>
<li>
<p>2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well;</p>
</li>
<li>
<p>and for the similar reason, 4 and 5 could also be the pivot.</p>
</li>
</ul>
<p>Hence in total there are 3 pivot candidates.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤105). Then the next line contains N distinct positive integers no larger than 109. The numbers in a line are separated by spaces.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>5<br />
1 3 2 4 5</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>3<br />
1 4 5</p>
</blockquote>
<p><strong>思路：</strong> 双向遍历，保留每个数字左边的最大值和右边的最小值，最后遍历判断是否大于左边最大值并小于右边最小值</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n; </span><br><span class="line">    cin&gt;&gt;n; </span><br><span class="line">    <span class="type">int</span> leftMax[n], rightMin[n], arr[n]; </span><br><span class="line">    <span class="type">int</span> ans[n], num = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    leftMax[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        leftMax[i] = <span class="built_in">max</span>(leftMax[i - <span class="number">1</span>], arr[i - <span class="number">1</span>]); </span><br><span class="line">    &#125;</span><br><span class="line">    rightMin[n - <span class="number">1</span>] = <span class="number">0x3fffffff</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        rightMin[i] = <span class="built_in">min</span>(rightMin[i + <span class="number">1</span>], arr[i + <span class="number">1</span>]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftMax[i] &lt; arr[i] &amp;&amp; rightMin[i] &gt; arr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            ans[num++] = arr[i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ans[i]; </span><br><span class="line">        <span class="keyword">if</span> (i &lt; num - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>校招后端面试算法题 —— Java 实现</title>
    <url>/school_interview-exam/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p> 自己参加秋招时做过的算法题（包括面试、笔试），这里贴出来做一个记录，代码够清晰了，所以也就没写注释，以后也尽量改掉一行注释一行代码的习惯，毕竟能够靠代码自己表达的东西就没必要啰嗦了 </p>
<span id="more"></span>
<h2 id="度小满金融"><a class="markdownIt-Anchor" href="# 度小满金融"></a> 度小满金融 </h2>
<p> 秋招开始第一次做笔试题，因为不能在自己的 IDE 上写，可给我难受坏了，第一次做的时候发挥的一塌糊涂，后来应该是邮件重复了又给我发了一次笔试邀请，想着闲着也是闲着就又参加了一次，第二次感觉还不错，第一次笔试之后有事耽误了总结，这里只贴第二次笔试的代码 </p>
<h3 id="变形的约瑟夫环"><a class="markdownIt-Anchor" href="# 变形的约瑟夫环"></a> 变形的约瑟夫环 </h3>
<p><strong> 题目：</strong><br />
1, ···, n 这 n 个人按编号排成一个圆圈，从数字 1 开始报数，报出的数字为 a 的人出局，下一个人继续从 1 开始报数，报出 b 的人出局，也就是奇数次出局的为报 a 的人，偶数次出局的人报的是 b<br />
输入格式为 <code>n a b</code> 求出这个圆圈里剩下的最后一个人的编号 </p>
<p><strong> 样例输入：</strong></p>
<blockquote>
<p>6 3 5</p>
</blockquote>
<p><strong> 样例输出：</strong></p>
<blockquote>
<p>1</p>
</blockquote>
<p><strong> 思路：</strong><br />
大名鼎鼎的约瑟夫环，只是原来的固定淘汰值变成了两个轮换的值，在原来的解法中每次淘汰数字之后更换一下淘汰值即可 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Aidan on 2021/9/26 16:29</span></span><br><span class="line"><span class="comment"> * GitHub: github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * Blog: aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JosephRing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        scanner.close();</span><br><span class="line">        <span class="comment">// 使用集合维护元素，方便淘汰的处理 </span></span><br><span class="line">        List&lt;Integer&gt; person = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            person.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>, now = a;</span><br><span class="line">        <span class="keyword">while</span> (person.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            k += now;</span><br><span class="line">            <span class="comment">// 根据淘汰值找出被淘汰的具体人 </span></span><br><span class="line">            k = k % person.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                person.remove(person.size() - <span class="number">1</span>);</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                person.remove(k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每次更换淘汰值 </span></span><br><span class="line">            now = now == a ? b : a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(person.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="奥运会"><a class="markdownIt-Anchor" href="# 奥运会"></a> 奥运会 </h3>
<p><strong> 题目：</strong><br />
两个电视频道同时转播奥运会的竞赛项目，两个频道播出的项目中没有重复的，如果看一个项目就全部看完的话，根据节目单判断最多能完整看多少个项目（忽略换台的时间）<br />
第一行输入 m, n 作为两个频道转播的项目数量，然后以 <code>HH:mm</code> 的格式输入 m+n 行时间，返回能观看项目的最大值 </p>
<p><strong> 样例输入：</strong></p>
<blockquote>
<p>3 4<br />
07:00-08:00<br />
08:00-09:00<br />
08:00-11:00<br />
09:30-11:00<br />
13:00-15:00<br />
12:00-13:30<br />
13:00-15:30</p>
</blockquote>
<p><strong> 样例输出：</strong></p>
<blockquote>
<p>4</p>
</blockquote>
<p><strong> 思路：</strong><br />
这道题算法不多，考察的更像是字符串、时间类和集合的应用（我没想到更好的解决方式），首先将 String 转换成 LocalTime 然后使用 TreeMap 存储时间的结束和开始，因为判断的是最多，所以用结束时间为 key 来排序，判断下一场的开始时间是不是晚于当前的结束时间，符合条件的累加 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Aidan on 2021/9/26 16:31</span></span><br><span class="line"><span class="comment"> * GitHub: github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * Blog: aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeLag</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> m + n;</span><br><span class="line">        scanner.nextLine();</span><br><span class="line">        Map&lt;LocalTime, LocalTime&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 定义字符串转时间的格式（直接用字符串也行）</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm&quot;</span>);</span><br><span class="line">        <span class="comment">// 依次转换格式放入 map 中 </span></span><br><span class="line">        <span class="keyword">while</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="type">LocalTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalTime.parse(time.substring(<span class="number">0</span>, <span class="number">5</span>), dtf);</span><br><span class="line">            <span class="type">LocalTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalTime.parse(time.substring(<span class="number">6</span>), dtf);</span><br><span class="line">            <span class="keyword">if</span> (map.get(end) == <span class="literal">null</span>) &#123;</span><br><span class="line">                map.put(end, start);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start.isAfter(map.get(end))) &#123;<span class="comment">// 结束时间相同只保留开始时间晚的 </span></span><br><span class="line">                map.put(end, start);</span><br><span class="line">            &#125;</span><br><span class="line">            total--;</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">perEnd</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;00:00&quot;</span>, dtf);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;LocalTime, LocalTime&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;<span class="comment">// 第一场永远是最优解 </span></span><br><span class="line">                perEnd = entry.getKey();</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开始时间不早于上一场的结束时间即有效 </span></span><br><span class="line">            <span class="keyword">if</span> (!entry.getValue().isBefore(perEnd)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            perEnd = entry.getKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="涂鸦移动"><a class="markdownIt-Anchor" href="# 涂鸦移动"></a> 涂鸦移动 </h2>
<h3 id="路径深度"><a class="markdownIt-Anchor" href="# 路径深度"></a> 路径深度 </h3>
<p><strong> 题目：</strong><br />
首先看这么一段文件路径 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Preface 1</span><br><span class="line">  Java SE5 and SE6</span><br><span class="line">      Java SE6</span><br><span class="line">  The 4th edition</span><br><span class="line">      Changes</span><br><span class="line">  Note on the cover design</span><br><span class="line">  Acknowledgements</span><br></pre></td></tr></table></figure>
<p> 如果用代码表示，上面的文件系统可以写为： <code>Preface 1\n\tJava SE5 and SE6\n\t\tJava SE6\n\tThe 4th edition\n\t\tChanges\n\tNote on the cover design\n\tAcknowledgements&quot;</code> ，其中 ‘\n’ 和 ‘\t’ 分别是换行符和制表符。那么指向目录中任何一个条目，都会有一条路径，路径都有深度 </p>
<p> 上面的例子中：<br />
<code>Note on the cover design</code> 的路径是 <code>Preface 1/Note on the cover design</code> ，深度是 2，路径都由字母、数字或空格组成，给定一个以上述代码格式表示目录的字符串 input，返回深度最深的条目中，最长路径的长度 </p>
<p><a class="link"   href="https://leetcode-cn.com/problems/longest-absolute-file-path/"> 类似题 LeetCode 地址 <i class="fas fa-external-link-alt"></i></a></p>
<p><strong> 样例输入：</strong></p>
<blockquote>
<p>Title\n\tSubtitle1\n\tSubtitle2\n\t\taaaa</p>
</blockquote>
<p><strong> 样例输出：</strong></p>
<blockquote>
<p>20<br />
解释：aaaa 路径为 “Title/Subtitle2/aaaa”，深度是 3，路径长度 20</p>
</blockquote>
<p><strong> 思路：</strong><br />
首先将输入的路径根据 <code>\n</code> 进行切割，遍历每一段根据 <code>\t</code> 的个数判断处于第几层，将每层的目录长度放到数组中，根据最后求出的最大深度计算最大长度 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Aidan on 2021/9/3 16:22</span></span><br><span class="line"><span class="comment"> * GitHub: github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * Blog: aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilePathLength</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;Title\n\tSubtitle1\n\t\taaa\n\t\tSubsubtitle1\n\t\t\tbbbb\n\tSubtitle2\n\t\tSubsubtitle2\n\t\t\tcccccc&quot;</span>;</span><br><span class="line">        System.out.println(LongestPath(input));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">LongestPath</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[input.length() + <span class="number">1</span>];    <span class="comment">// 从 1 开始，第 0 层就是 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">Deepest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">deepestLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : input.split(<span class="string">&quot;\n&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> s.lastIndexOf(<span class="string">&#x27;\t&#x27;</span>) + <span class="number">2</span>;    <span class="comment">// 计算当前在第几层（从第一层开始，没有、t 为第一层）</span></span><br><span class="line">            Deepest = Math.max(Deepest, level);</span><br><span class="line">            deepestLen = s.length() - (Deepest - <span class="number">1</span>);    <span class="comment">// 即便层数深度相同，最深长度也会更新 </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length() - (level - <span class="number">1</span>);     <span class="comment">// 计算当前这一行的长度 </span></span><br><span class="line">            sum[level] = sum[level - <span class="number">1</span>] + len + <span class="number">1</span>;  <span class="comment">// 是目录，要 +1，目录有个 / 的 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum[Deepest - <span class="number">1</span>] + deepestLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="temmie- 的 -x- 运算"><a class="markdownIt-Anchor" href="#temmie- 的 -x- 运算"></a> Temmie 的 X 运算 </h3>
<p><strong> 题目：</strong><br />
有一种特殊的运算 X，它的运算方式如下：对于一个整数 n，对它的每一位 d，用 d+1 替换 d<br />
例如，对于 193，它的每一位 +1 后的结果为 2，10，4。所以，193 的 X 运算结果为 2104<br />
计算 n 进行 m 次运算后结果的位数，因为结果可能超过整形范围，所以你只需要告诉他结果模 10^9+7 的余数即可 </p>
<p><strong> 样例输入：</strong><br />
输入多行，每行用 <code>m n</code> 的格式表示数字和遍历次数 </p>
<blockquote>
<p>5<br />
1912 1<br />
5 6<br />
999 1<br />
88 2<br />
12 100</p>
</blockquote>
<p><strong> 样例输出：</strong></p>
<blockquote>
<p>5<br />
2<br />
6<br />
4<br />
2115</p>
</blockquote>
<p><strong> 思路：</strong><br />
直接模拟即可，注意当一位数字等于 10 之后会占两位 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Aidan on 2021/9/3 17:43</span></span><br><span class="line"><span class="comment"> * GitHub: github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * Blog: aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticNum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">fre</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fre; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">product</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                m--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (m-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">power</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    temp = n % <span class="number">10</span>;</span><br><span class="line">                    temp++;</span><br><span class="line">                    <span class="comment">// 处理 10 占两位的情况 </span></span><br><span class="line">                    <span class="keyword">if</span> (temp == <span class="number">10</span>) &#123;</span><br><span class="line">                        temp *= power;</span><br><span class="line">                        power *= <span class="number">10</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        temp *= power;</span><br><span class="line">                    &#125;</span><br><span class="line">                    product += temp;</span><br><span class="line">                    power *= <span class="number">10</span>;</span><br><span class="line">                    n /= <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">                power = <span class="number">1</span>;</span><br><span class="line">                n = product;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (product &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                product = product / <span class="number">10</span>;</span><br><span class="line">                count++;</span><br><span class="line">                count %= Math.pow(<span class="number">10</span>, <span class="number">9</span>) + <span class="number">7</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="58- 同城"><a class="markdownIt-Anchor" href="#58- 同城"></a> 58 同城 </h2>
<p>58 同城的笔试题（9-11 20:00），牛客上进行的，当初度小满的第一次笔试题可给我自闭坏了（一道样例怎么改都是 81.7%，还有一道忘了加 scanner.nextLine() 一直报空指针，因为读到的换行符是作为空字符串存储的），这次倒好，三道编程题没半小时全部 AC，调试都不用调，安逸的很 </p>
<h3 id="数组唯一数"><a class="markdownIt-Anchor" href="# 数组唯一数"></a> 数组唯一数 </h3>
<p><strong> 题目：</strong><br />
给出一个整型数组，找出其中只出现过一次的数字，这里确定至少会有一个出现一次的数，返回一个数组，其中按原数组顺序返回 </p>
<p><strong> 样例输入：</strong></p>
<blockquote>
<p>[1, 1, 4, 6, 7, 7, 3]</p>
</blockquote>
<p><strong> 样例输出：</strong></p>
<blockquote>
<p>[4, 6, 3]</p>
</blockquote>
<p><strong> 思路：</strong><br />
这里规定按原数组属性返回，如果使用 HashMap 需要增加遍历一次原数组的代码，所以直接使用 LinkedHashSet 就完了 <br />
不存在添加进 Set 集合，如若已经存在则移除，最后根据 <code>Set.size()</code> 取出数据即可 <br />
存在的问题是如果数字出现奇数次也会存在 Set 中，但 AC 了，看来测试数据没有出现过超过两次的情况，后续添加了一个 deletedSet 保存删除的数字解决问题 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Aidan on 2021/9/11 20:50</span></span><br><span class="line"><span class="comment"> * GitHub: github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * Blog: aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UniqueNumber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] test = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] result = find(test);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">            System.out.println(result[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] find(<span class="type">int</span>[] arg) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arg.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(arg[i])) &#123;</span><br><span class="line">                set.add(arg[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.remove(arg[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[set.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : set) &#123;</span><br><span class="line">            arr[index] = i;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    public static int[] find(int[] arg) &#123;</span></span><br><span class="line"><span class="comment">        Set&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">        Set&lt;Integer&gt; delSet = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arg.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            if (!set.contains(arg[i]) &amp;&amp; !delSet.contains(arg[i])) &#123;</span></span><br><span class="line"><span class="comment">                set.add(arg[i]);</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                set.remove(arg[i]);</span></span><br><span class="line"><span class="comment">                delSet.add(arg[i]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int[] arr = new int[set.size()];</span></span><br><span class="line"><span class="comment">        int index = 0;</span></span><br><span class="line"><span class="comment">        for (Integer i : set) &#123;</span></span><br><span class="line"><span class="comment">            arr[index] = i;</span></span><br><span class="line"><span class="comment">            index++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return arr;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大子数组和"><a class="markdownIt-Anchor" href="# 最大子数组和"></a> 最大子数组和 </h3>
<p><strong> 题目：</strong><br />
给定一个数组和子数组的长度，找出子数组和的最大值，返回值一个数组包含其子数组的起始下标与子数组和，格式为：[index, sum]</p>
<p><strong> 样例输入：</strong></p>
<blockquote>
<p>[1, 2, 30, 4, 5, 6, 7, 8, 9, 10], 10, 3</p>
</blockquote>
<p><strong> 样例输出：</strong></p>
<blockquote>
<p>[2, 39]</p>
</blockquote>
<p><strong> 思路：</strong><br />
模拟一下就好，注意不要超过数组边界 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Aidan on 2021/9/11 20:50</span></span><br><span class="line"><span class="comment"> * GitHub: github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * Blog: aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumBySub</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] result = subArraySum(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">30</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;, <span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">            System.out.println(result[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] subArraySum(<span class="type">int</span>[] Array, <span class="type">int</span> arrayLen, <span class="type">int</span> subArrayLen) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i + subArrayLen &lt; arrayLen) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; i + subArrayLen; j++) &#123;</span><br><span class="line">                tempMax += Array[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; tempMax) &#123;</span><br><span class="line">                max = tempMax;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;index, max&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不能坑队友"><a class="markdownIt-Anchor" href="# 不能坑队友"></a> 不能坑队友 </h3>
<p><strong> 题目：</strong><br />
王者荣耀中英雄大致可以分为五类：上中下、打野、辅助，给定整型数组代表英雄，返回有几种组合，如果阵容不合理则不能开团（返回 0）</p>
<p><strong> 样例输入：</strong></p>
<blockquote>
<p>{0, 1, 2, 3, 4}</p>
</blockquote>
<p><strong> 样例输出：</strong></p>
<blockquote>
<p>1</p>
</blockquote>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Aidan on 2021/9/11 20:58</span></span><br><span class="line"><span class="comment"> * GitHub: github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * Blog: aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeroPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> getTeams(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getTeams</span><span class="params">(<span class="type">int</span>[] heros)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">countZero</span> <span class="operator">=</span> <span class="number">0</span>, countOne = <span class="number">0</span>, countTwo = <span class="number">0</span>, countThree = <span class="number">0</span>, countFour = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; heros.length; i++) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (heros[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                    countZero++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                    countOne++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                    countTwo++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                    countThree++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>: &#123;</span><br><span class="line">                    countFour++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countZero * countOne * countTwo * countThree * countFour;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="字节跳动"><a class="markdownIt-Anchor" href="# 字节跳动"></a> 字节跳动 </h2>
<p> 为面试准备的算法题，面试的部门是非中商业化技术，刷了一些面经中出现频率比较高的，结果很遗憾面试的时候没能撑到算法那一关 </p>
<h3 id="二叉树的右视图"><a class="markdownIt-Anchor" href="# 二叉树的右视图"></a> 二叉树的右视图 </h3>
<p><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">LeetCode 地址 <i class="fas fa-external-link-alt"></i></a></p>
<p><strong> 思路：</strong><br />
同时维护两个栈：节点栈和深度栈，节点站按照先左后右的顺序存放结点，深度栈存放每个结点对应的深度，这样在同一层深度第一个弹出的必定是最右边的结点，然后将当前深度和结点放入 Map 中，如果后续已经存在当前的深度的 Key，那就直接进入下一层 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** TreeNode 结构 </span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 以 &lt;Depth, Node&gt; 的形式存储每层深度的结点 </span></span><br><span class="line">        Map&lt;Integer, Integer&gt; rightSideNode = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// 最大深度，负责从 Map 中取出对应深度的 Node</span></span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; depthStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        depthStack.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!nodeStack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> nodeStack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> depthStack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                maxDepth = Math.max(maxDepth, depth);</span><br><span class="line">                <span class="comment">// 如果当前深度在 Map 中没有对应的 Key</span></span><br><span class="line">                <span class="keyword">if</span> (!rightSideNode.containsKey(depth)) &#123;</span><br><span class="line">                    rightSideNode.put(depth, node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从左向右依次放入结点 </span></span><br><span class="line">                nodeStack.push(node.left);</span><br><span class="line">                nodeStack.push(node.right);</span><br><span class="line">                depthStack.push(depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= maxDepth; i++) &#123;</span><br><span class="line">            list.add(rightSideNode.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除排序链表中的重复元素"><a class="markdownIt-Anchor" href="# 删除排序链表中的重复元素"></a> 删除排序链表中的重复元素 </h3>
<p><a class="link"   href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">LeetCode 地址 <i class="fas fa-external-link-alt"></i></a></p>
<p><strong> 思路：</strong><br />
因为是排序链表，所以重复元素一定是连续出现的，可以维护一对快慢指针，当 <code>slow.next==fast.next</code> 时，取出当前重复值，快指针不断前移判断，直到不再重复时停下继续判断，中间重复值取消连接即可 </p>
<p><strong> 代码：</strong><br />
这里优化后的代码仅使用一个指针，用 <code>cursor.next</code> 和 <code>cursor.next.next</code> 表示快慢 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用哑结点表示头结点的前置结点，因为头节点也可能重复被删除 </span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cursor</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要快慢指针还能前移就持续判断 </span></span><br><span class="line">        <span class="keyword">while</span> (cursor.next != <span class="literal">null</span> &amp;&amp; cursor.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当快慢指针的 next 结点值重复 </span></span><br><span class="line">            <span class="keyword">if</span> (cursor.next.val == cursor.next.next.val) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cursor.next.val;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 越过第一个重复值之后判断后续是否继续重复 </span></span><br><span class="line">                    cursor.next = cursor.next.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (cursor.next != <span class="literal">null</span> &amp;&amp; cursor.next.val == x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cursor = cursor.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子集"><a class="markdownIt-Anchor" href="# 子集"></a> 子集 </h3>
<p><a class="link"   href="https://leetcode-cn.com/problems/subsets/solution/zi-ji-by-leetcode-solution/">LeetCode 地址 <i class="fas fa-external-link-alt"></i></a></p>
<p><strong> 思路：</strong><br />
回溯寻找，首先找长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的子集，到达数组末尾就表示寻找完毕，保存结果集 <br />
然后寻找长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的子集，到达数组末尾可能存在存在 K 不为 0 的情况，那就移除最后放入的数，继续存储 <br />
以此类推 </p>
<p> 不太好说，可以看官方的视频题解 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;= len; k++) &#123;    <span class="comment">// 寻找所有长度的子集 </span></span><br><span class="line">            backTrack(<span class="number">0</span>, k, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> k, List&lt;Integer&gt; tempSet, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;   <span class="comment">// 当前长度已经找完保存结果 </span></span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempSet));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; len; i++) &#123;</span><br><span class="line">            tempSet.add(nums[i]);</span><br><span class="line">            <span class="comment">// 防止重复，每次从下一个开始寻找，同时缩小子集要求个数 </span></span><br><span class="line">            backTrack(i + <span class="number">1</span>, k - <span class="number">1</span>, tempSet, nums);</span><br><span class="line">            tempSet.remove(tempSet.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* dfs 版本 </span></span><br><span class="line"><span class="comment">    List&lt;Integer&gt; t = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">        dfs(0, nums);</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public void dfs(int cur, int[] nums) &#123;</span></span><br><span class="line"><span class="comment">        if (cur == nums.length) &#123;</span></span><br><span class="line"><span class="comment">            ans.add(new ArrayList&lt;Integer&gt;(t));</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        t.add(nums[cur]);</span></span><br><span class="line"><span class="comment">        dfs(cur + 1, nums);</span></span><br><span class="line"><span class="comment">        t.remove(t.size() - 1);</span></span><br><span class="line"><span class="comment">        dfs(cur + 1, nums);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表的倒数第 -n- 个结点"><a class="markdownIt-Anchor" href="# 删除链表的倒数第 -n- 个结点"></a> 删除链表的倒数第 N 个结点 </h3>
<p><a class="link"   href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">LeetCode 地址 <i class="fas fa-external-link-alt"></i></a></p>
<p><strong> 思路：</strong></p>
<ol>
<li> 可以先遍历长度，第二次遍历到 length-n+1 时进行删除 </li>
<li> 将链表全部压入栈中，弹出的第 n 个数据就是要删除的链表 </li>
<li> 使用间隔为 n 的快慢指针，当 fast 为空时，删除 slow 结点 </li>
</ol>
<p><strong> 代码：</strong><br />
这里使用第三种方法实现，复杂度最低 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head); <span class="comment">// 创建哑结点，因为头结点也有可能被删除 </span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            first = first.next; <span class="comment">// 快结点先走 n 步 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="literal">null</span>) &#123; <span class="comment">// 快结点到达末尾删除满结点所在位置 </span></span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并 -k- 个升序链表"><a class="markdownIt-Anchor" href="# 合并 -k- 个升序链表"></a> 合并 K 个升序链表 </h3>
<p><a class="link"   href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">LeetCode 地址 <i class="fas fa-external-link-alt"></i></a></p>
<p><strong> 思路：</strong><br />
这里先把问题规模缩小，不考虑 K 个链表怎么合并，看作是两个链表，每次合并后作为一个链表继续和后续链表合并即可 </p>
<p> 至于两个链表的合并就是每次判断值赋予新链表上，当一个链表为空后，将另一链表直接置于新链表末尾即可 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; ++i) &#123;<span class="comment">// 遍历每一条链表让其与上一条链表合并 </span></span><br><span class="line">            ans = mergeTwoLists(ans, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode a, ListNode b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a != <span class="literal">null</span> ? a : b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);    <span class="comment">// 哑结点的 next 表示，防止错乱 </span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head, aPtr = a, bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr != <span class="literal">null</span> &amp;&amp; bPtr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;  <span class="comment">// 比较值之后保留小的 </span></span><br><span class="line">                tail.next = aPtr;</span><br><span class="line">                aPtr = aPtr.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = bPtr;</span><br><span class="line">                bPtr = bPtr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail.next;   <span class="comment">// 指针后移 </span></span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = (aPtr != <span class="literal">null</span> ? aPtr : bPtr);   <span class="comment">// 当有链表为空时，另一链表放到结果链表的后边 </span></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="花旗"><a class="markdownIt-Anchor" href="# 花旗"></a> 花旗 </h2>
<p> 纯英文的题目，但好在描述的简洁直接，读题还是没障碍的，一道 SQL 实现题，放到了这篇 <a class="link"   href="https://aidanblog.top/2021/11/10/Database-SQL-ContinuousID/"> 实现贴上面 <i class="fas fa-external-link-alt"></i></a>，还有一道合并有序数组的没必要放上来了，说说这道动规吧 </p>
<h3 id="规定时间内到达终点的最小花费"><a class="markdownIt-Anchor" href="# 规定时间内到达终点的最小花费"></a> 规定时间内到达终点的最小花费 </h3>
<p><a class="link"   href="https://leetcode-cn.com/problems/minimum-cost-to-reach-destination-in-time/">LeetCode 地址 <i class="fas fa-external-link-alt"></i></a></p>
<p><strong> 思路：</strong><br />
这道题第一时间想的是最短路径实现，但后来还是换成了动态规划，结束之后推算了一下确实也是动态规划的复杂度比较小，要花费 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∗</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">n*maxTimes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span></span></span></span> 的规模初始化 dp 数组，然后遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">maxTimes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span></span></span></span> 来对每一个 edges 数组来操作，最后的复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((n+m)⋅maxTimes)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></p>
<p> 创建一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">maxTimes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span></span></span></span> 的 dp 数组，然后我们在时间限定内进行动规，dp[t][i] 表示第 t 分钟到达城市 i 时的最少费用，然后假设跟其有边的点 j 就是到达 i 的最后一步，进行状态转移，最后找出时间范围中到达 n-1 花费最小的即可 </p>
<ul>
<li> 当前时间为 1，只能从 0 走到 3 号点，这样的花费就是 25    <code>dp[1][3]=dp[0][0]+cost[3]</code></li>
<li> 时间在 2-9 之间时只能在 0-3 点横跳 </li>
<li>…</li>
<li> 此时时间为 10，横跳结束，可以走到 1 号点，花费 15   <code>dp[10][1]=dp[0][0]+cost[1]</code></li>
<li> 时间来到 11，可以到达 4 号点，花费 45     <code>dp[11][34]=dp[1][3]+cost[4]</code></li>
<li>… 依次类推 </li>
</ul>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinCostWithTimeLimited</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(minCostWithTimeLimited(<span class="number">30</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">                        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">3</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minCostWithTimeLimited</span><span class="params">(<span class="type">int</span> maxTime, <span class="type">int</span>[][] edges, <span class="type">int</span>[] passingFees)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> passingFees.length; <span class="comment">// 根据城市成本数组保留城市个数 </span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        最大费用，这里根据数据规模计算 </span></span><br><span class="line"><span class="comment">        可以使用 `Integer.MAX_VALUE - Arrays.stream(passingFees).max().getAsInt();`</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxFee</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1E6</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 创建时间限制同样规模的数组，保留从 0 到 i 需要的时间 </span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[maxTime + <span class="number">1</span>][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用最大成本填充 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= maxTime; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], maxFee);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 起点花费 </span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = passingFees[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 在时间限定中尝试 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= maxTime; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">                <span class="comment">// 耗时超过当前时间限定直接下一次循环 </span></span><br><span class="line">                <span class="keyword">if</span> (edge[<span class="number">2</span>] &gt; i) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> edge[<span class="number">0</span>], y = edge[<span class="number">1</span>], time = edge[<span class="number">2</span>];</span><br><span class="line">                <span class="comment">// 根据边关系求出走这条路时的花费 </span></span><br><span class="line">                dp[i][x] = Math.min(dp[i][x], dp[i - time][y] + passingFees[x]);</span><br><span class="line">                dp[i][y] = Math.min(dp[i][y], dp[i - time][x] + passingFees[y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> maxFee;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= maxTime; i++) &#123;</span><br><span class="line">            ans = Math.min(ans, dp[i][n - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ans == maxFee) ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="阿里巴巴"><a class="markdownIt-Anchor" href="# 阿里巴巴"></a> 阿里巴巴 </h2>
<p> 两道题，第二道没做明白，只 AC 了第一道 </p>
<h3 id="补码的加法运算"><a class="markdownIt-Anchor" href="# 补码的加法运算"></a> 补码的加法运算 </h3>
<p><strong> 题目：</strong><br />
第一行给出组数 N，紧接输入 N 行数据，每行一对以补码形式的的 32 位字符，输出相加后的十进制结果 </p>
<p><strong> 样例输入：</strong></p>
<blockquote>
<p>2<br />
00000000000000000000000000000101 11111111111111111111111111111111<br />
00000000000000000000000000011111 00000000000000000000000000000111</p>
</blockquote>
<p><strong> 样例输出：</strong></p>
<blockquote>
<p>4<br />
38</p>
</blockquote>
<p><strong> 思路：</strong><br />
可以根据补码直接定义运算规则，也可以转换为原码后进行计算，我这里选择的是第二种，根据原码对补码的转换思路反向操作即可，转换补码的思路：</p>
<ol>
<li> 正数：保持不变 </li>
<li> 负数：符号位保持不变，数值位按位取反末位加一 </li>
</ol>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Aidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2021/10/8 20:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@GitHub</span> github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComplementArithmetic</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尽量不要在代码中出现 magic number</span></span><br><span class="line"><span class="comment">     * 可以使用 int 型定义为 48,49</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">ZERO</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">ONE</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            scanner.nextLine();</span><br><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="comment">// 数据读取后进行处理，转换为 10 进制 </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> hand(a), y = hand(b);</span><br><span class="line">            System.out.println(x + y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hand</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 符号位为 0 是一个正数，直接进行进制转换 </span></span><br><span class="line">        <span class="keyword">if</span> (chars[<span class="number">0</span>] == ZERO) &#123;</span><br><span class="line">            m = Integer.parseInt(str, <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将数值位按位取反 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chars[i] == ONE) &#123;</span><br><span class="line">                    chars[i] = ZERO;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    chars[i] = ONE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">newA</span> <span class="operator">=</span> String.copyValueOf(chars, <span class="number">1</span>, <span class="number">31</span>);</span><br><span class="line">            <span class="comment">// 处理末尾与符号 </span></span><br><span class="line">            m = Integer.parseInt(newA, <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                m *= -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="倍业科技"><a class="markdownIt-Anchor" href="# 倍业科技"></a> 倍业科技 </h2>
<h3 id="字符串压缩与解压"><a class="markdownIt-Anchor" href="# 字符串压缩与解压"></a> 字符串压缩与解压 </h3>
<p><a class="link"   href="https://leetcode-cn.com/problems/compress-string-lcci/">LeetCode 地址 <i class="fas fa-external-link-alt"></i></a></p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Aidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2021/10/26 14:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@GitHub</span> github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TarString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        System.out.println(compress(str));</span><br><span class="line">        System.out.println(decompress(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">compress</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">char</span> <span class="variable">start</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">next</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="comment">// 重复字符累加 </span></span><br><span class="line">            <span class="keyword">if</span> (start == next) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据重复次数压缩 </span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                builder.append(start);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                builder.append(count).append(start);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开始下一轮重复 </span></span><br><span class="line">            start = next;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理末尾数据 </span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            builder.append(start);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            builder.append(count).append(start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">decompress</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length();) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="comment">// 如果当前遍历到的字符是数字，考虑位数超过一的情况 </span></span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (; j &lt; str.length(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!Character.isDigit(str.charAt(j))) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据数字进行重复 </span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str.substring(i, j));</span><br><span class="line">                builder.append(String.valueOf(str.charAt(j)).repeat(Math.max(<span class="number">0</span>, num)));</span><br><span class="line">                i = j + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 遇到单个字符的情况 </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                builder.append(str.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="便利蜂"><a class="markdownIt-Anchor" href="# 便利蜂"></a> 便利蜂 </h2>
<h3 id="测量次数"><a class="markdownIt-Anchor" href="# 测量次数"></a> 测量次数 </h3>
<p><strong> 题目：</strong><br />
小明和他的伙伴发现了一堆木头排成了一排，一共 n 个，假设排列在 x 轴上，最左端的木头的坐标是 -1，最右端木头的坐标是 n。他们想拿走里面最重和最轻的木头各一个，但是他们并不知道是这一堆里的哪一个，因此他们需要挨个测量。现在他们在这排木头的两端，一个人在坐标 0，一个人在坐标 n，他们只能按顺序测量，即在 0 位置的人只能依次测量 0, 1, 2, 3 然后到 n，在 n 位置的人则相反。现在你已经知道每个木头的重量，你可以指挥他们是否继续测量，问两个人一共最少需要多少次测量就可以找到最重和最轻的木头 </p>
<p><strong> 输入描述：</strong><br />
第一行一个整数 n，0&lt;=n&lt;=1000</p>
<p> 第二行 n 个空格隔开的整数，表示木头的重量，其中任意一个数大小范围是 [-1, 10000]。</p>
<p><strong> 输出描述：</strong><br />
一个整数，表示最少需要测量的次数。</p>
<p><strong> 样例输入：</strong></p>
<blockquote>
<p>4<br />
0 5 4 3 2</p>
</blockquote>
<p><strong> 样例输出：</strong></p>
<blockquote>
<p>1</p>
</blockquote>
<p><strong> 思路：</strong><br />
直接根据描述模拟的测量方法，可能剪枝后还是跑不完样例，贴一下代码吧 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Aidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2021/10/30 19:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@GitHub</span> github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MeasureNum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxInd</span> <span class="operator">=</span> <span class="number">0</span>, max = Integer.MIN_VALUE, minInd = <span class="number">0</span>, min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">                maxInd = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">                min = arr[i];</span><br><span class="line">                minInd = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; maxIndList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; minIndList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[minInd]) &#123;</span><br><span class="line">                minIndList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[maxInd]) &#123;</span><br><span class="line">                maxIndList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer maxTemp : maxIndList) &#123;</span><br><span class="line">            maxInd = maxTemp;</span><br><span class="line">            <span class="keyword">for</span> (Integer minTemp : minIndList) &#123;</span><br><span class="line">                minInd = minTemp;</span><br><span class="line">                <span class="keyword">if</span> (maxInd &lt; minInd) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> maxInd;</span><br><span class="line">                    maxInd = minInd;</span><br><span class="line">                    minInd = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                result = Math.min(Math.min(n - minInd, maxInd + <span class="number">1</span>), (minInd + <span class="number">1</span>) + (n - maxInd));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="滴滴"><a class="markdownIt-Anchor" href="# 滴滴"></a> 滴滴 </h2>
<h3 id="删除游戏的最大得分"><a class="markdownIt-Anchor" href="# 删除游戏的最大得分"></a> 删除游戏的最大得分 </h3>
<p><strong> 题目：</strong><br />
首先随机写下 N 个正整数，然后任选一个数字作为起始点，从起始点开始从左往右每次可以删除一个数字，但是必须满足下一个删除的数字要小于上一个删除的数字。每成功删除一个数字计 1 分。请问对于给定的 N 个正整数，一局游戏过后可以得到的最大计分是多少？</p>
<p><strong> 思路：</strong><br />
第一时间考虑的 dfs 方式，也能跑完但这种问题还是动态规划比较好，所以结束后又写了一遍动规的写法 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Aidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2021/10/23 16:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@GitHub</span> github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxScore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* dfs 调用 </span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            dfs(arr[i], i, arr, 1);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        dp(arr);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[i] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[maxIndex] &lt; dp[i]) &#123;</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = dp[maxIndex];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dfs 解法 </span></span><br><span class="line"><span class="comment">    private static void dfs(int flag, int i, int[] arr, int count) &#123;</span></span><br><span class="line"><span class="comment">        if (i + 1 == arr.length) &#123;</span></span><br><span class="line"><span class="comment">            result = Math.max(result, count);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int j = i + 1;</span></span><br><span class="line"><span class="comment">        for (; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">            if (arr[j] &lt; flag) &#123;</span></span><br><span class="line"><span class="comment">                count++;</span></span><br><span class="line"><span class="comment">                dfs(arr[j], j, arr, count);</span></span><br><span class="line"><span class="comment">                count--;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if (j == arr.length) &#123;</span></span><br><span class="line"><span class="comment">            result = Math.max(result, count);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小生成树"><a class="markdownIt-Anchor" href="# 最小生成树"></a> 最小生成树 </h3>
<p><strong> 题目：</strong><br />
X 星大学新校区终于建成啦！  新校区一共有 N 栋教学楼和办公楼。现在需要用光纤把这 N 栋连接起来，保证任意两栋楼之间都有一条有线网络通讯链路。<br />
已知任意两栋楼之间的直线距离（单位：千米）。为了降低成本，要求两栋楼之间都用直线光纤连接。<br />
光纤的单位成本 C 已知（单位：X 星币 / 千米），请问最少需要多少 X 星币才能保证任意两栋楼之间都有光纤直接或者间接相连？<br />
注意：如果 1 号楼和 2 号楼相连，2 号楼和 3 号楼相连，则 1 号楼和 3 号楼间接相连 </p>
<p><strong> 思路：</strong><br />
直接最小生成树进行判断即可 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Aidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2021/10/23 16:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@GitHub</span> github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinLen</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt(), c = scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] visited = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n * (n - <span class="number">1</span>) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            map[x][y] = len;</span><br><span class="line">            map[y][x] = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有楼都会间接可达，不用考虑入口，直接选择 1 号楼 </span></span><br><span class="line">        visited[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>, step = <span class="number">1</span>, now = <span class="number">0</span>, min;</span><br><span class="line">        <span class="keyword">while</span> (step &lt; n) &#123;</span><br><span class="line">            min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 选择没被连接的可达最小值 </span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (visited[j] == <span class="number">0</span> &amp;&amp; min &gt; map[i][j]) &#123;</span><br><span class="line">                            min = map[i][j];</span><br><span class="line">                            now = j;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min != Integer.MAX_VALUE) &#123;</span><br><span class="line">                <span class="comment">// 被连接后标识 </span></span><br><span class="line">                visited[now] = <span class="number">1</span>;</span><br><span class="line">                result += min;</span><br><span class="line">                step++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result * c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="去哪儿"><a class="markdownIt-Anchor" href="# 去哪儿"></a> 去哪儿 </h2>
<p><strong> 题目：</strong><br />
对字符串按照字符出现频率重新排序，频率相同按大小写排序，同为大写或小写按字母序排列 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringReordering</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123;</span><br><span class="line">            <span class="type">int</span> count;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                count = map.get(c);</span><br><span class="line">                map.put(c, ++count);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Map.Entry&lt;Character, Integer&gt;&gt; entryList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.entrySet());</span><br><span class="line"></span><br><span class="line">        entryList.sort((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Objects.equals(o2.getValue(), o1.getValue())) &#123;</span><br><span class="line">                <span class="keyword">return</span> o2.getValue() - o1.getValue();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((o1.getKey() &gt; <span class="number">94</span> &amp;&amp; o2.getKey() &gt; <span class="number">94</span>) || (o1.getKey() &lt; <span class="number">95</span> &amp;&amp; o2.getKey() &lt; <span class="number">95</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getKey() - o2.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> o1.getKey() &gt; <span class="number">94</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : entryList) &#123;</span><br><span class="line">            stringBuilder.append(String.valueOf(entry.getKey()).repeat(Math.max(<span class="number">0</span>, entry.getValue())));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuilder);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="360"><a class="markdownIt-Anchor" href="#360"></a> 360</h2>
<p><strong> 题目：</strong><br />
小 A 的英语考了个不及格，老师很生气，并且发现他英语的语法几乎全错！于是老师决定好好教教他英语语法 </p>
<blockquote>
<p> 老师想先从句子结构开始教他。一个句子至少需要包含主谓结构，即主语和谓语，并且主语在前，谓语在后。有些句子会在谓语后面加上宾语。避免复杂，本题中句子的顺序严格按照主语 - 谓语 - 宾语的顺序（即无宾语前置和倒装等情况）。</p>
<p> 老师给了小 A 三张单词表，分别是主语单词表、谓语单词表和宾语单词表。老师要让小 A 用这些单词表中的单词来造句，并且规定：谓语有且仅有一个单词，主语和宾语可以包含任意个单词（主语不可为空）。老师暂时不想让小 A 造出能保证意思通顺的句子，他只想让小 A 能够学会基本的句子结构就行。</p>
<p> 现在，小 A 根据这些单词造了 m 条句子，现在假设你是老师，你需要判断每条句子是否符合上述句子结构。</p>
</blockquote>
<p><strong> 输入描述 </strong></p>
<ol>
<li> 第一行三个正整数 n1, n2, n3，分别表示主语、谓语、宾语单词表的单词数；</li>
<li> 第二行包含 n1 个单词，单词仅由小写英文字母组成，每两个单词之间有一个空格，单词长度不超过 10；</li>
<li> 第三行包含 n2 个单词，其他格式同上；</li>
<li> 第四行包含 n3 个单词，其他格式同上；</li>
<li> 第五行一个正整数 m；</li>
<li> 接下来 m 行，每行一个句子。句子由若干单词（至少一个）组成，并且保证出现的单词都在上面的单词表内。每两个单词之间一个空格隔开 </li>
</ol>
<blockquote>
<p> 数据保证一个单词最多只可做一种句子成分。即每个单词仅会出现在一个单词表上。<br />
1≤n1, n2, n3≤1000, 1≤m≤20, 1≤句子单词数≤10</p>
</blockquote>
<p><strong> 输出描述 </strong><br />
对于每条句子，如果其符合句子结构，输出一行“YES”（不含引号），否则输出一行“NO”（不含引号）</p>
<p><strong> 样例输入 </strong></p>
<blockquote>
<p>3 3 3<br />
i you he<br />
am is are<br />
yours his hers<br />
5<br />
i am yours<br />
you is his<br />
he are hers yours<br />
i am am yours<br />
is his</p>
</blockquote>
<p><strong> 样例输出 </strong></p>
<blockquote>
<p>YES<br />
NO</p>
</blockquote>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Aidan on 2021/10/24 15:42</span></span><br><span class="line"><span class="comment"> * GitHub: github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * Blog: aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmIsAre</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">zCount</span> <span class="operator">=</span> scanner.nextInt(), wCount = scanner.nextInt(), bCount = scanner.nextInt();</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; zCount; j++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            map.put(temp, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.nextLine();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; wCount; j++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            map.put(temp, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.nextLine();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bCount; j++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            map.put(temp, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        scanner.nextLine();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            String[] strings = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">                list.add(map.get(string));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!list.contains(<span class="number">0</span>)) &#123;</span><br><span class="line">                flag = <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">W_Count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1</span>; i1 &lt; list.size(); i1++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.get(i1 - <span class="number">1</span>) &gt; list.get(i1) || W_Count &gt; <span class="number">1</span></span><br><span class="line">                            || (list.get(i1) == <span class="number">2</span>) &amp;&amp; W_Count == <span class="number">0</span>) &#123;</span><br><span class="line">                        flag = <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.get(i1) == <span class="number">1</span>) &#123;</span><br><span class="line">                        W_Count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(flag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="途家民宿"><a class="markdownIt-Anchor" href="# 途家民宿"></a> 途家民宿 </h2>
<h3 id="生成城市树"><a class="markdownIt-Anchor" href="# 生成城市树"></a> 生成城市树 </h3>
<p><strong> 题目：</strong></p>
<p> 按照固定的格式进行输入，每行的格式为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>d</mi><mi>p</mi><mi>I</mi><mi>d</mi><mi>l</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>l</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Id pId level name</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">n</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span></span></span></span>，最后按照级别生成目录形式的文本输出，若级别相同，则按姓名进行升序排列 </p>
<p><strong> 思路：</strong></p>
<p> 将每个城市封装成一个 class，对级别为 0 的城市进行遍历，然后递归输出后续的城市并进行格式的调整 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Aidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2021/11/13 15:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@GitHub</span> github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenerateCityTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">City</span> &#123;</span><br><span class="line">        <span class="type">int</span> ID, PID, level;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">City</span><span class="params">(<span class="type">int</span> ID, <span class="type">int</span> PID, <span class="type">int</span> level, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>. ID = ID; </span><br><span class="line">            <span class="built_in">this</span>. PID = PID; </span><br><span class="line">            <span class="built_in">this</span>.level = level; </span><br><span class="line">            <span class="built_in">this</span>.name = name; </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        List&lt;City&gt; cityList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scannerStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(str);</span><br><span class="line">            String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                strings[i] = scannerStr.next();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">City</span> <span class="variable">tempCity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(Integer.parseInt(strings[<span class="number">0</span>]),</span><br><span class="line">                    Integer.parseInt(strings[<span class="number">1</span>]), Integer.parseInt(strings[<span class="number">2</span>]), strings[<span class="number">3</span>]);</span><br><span class="line">            cityList.add(tempCity);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cityList.sort((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1.level != o2.level) &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.level - o2.level;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> o1.ID - o2.ID;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*for (City city : cityList) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(city.getName());</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (City city : cityList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (city.level == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(city.name);</span><br><span class="line">                dfs(cityList, city.level + <span class="number">1</span>, city.ID);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;City&gt; list, <span class="type">int</span> level, <span class="type">int</span> ID)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (City city : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (city. PID == ID &amp;&amp; city.level == level) &#123;</span><br><span class="line">                outSpace(level); </span><br><span class="line">                System.out.print(city.name); </span><br><span class="line">                System.out.println(); </span><br><span class="line">                dfs(list, level + <span class="number">1</span>, city. ID); </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outSpace</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (level - <span class="number">1</span>) * <span class="number">4</span>; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="逆序输出文章"><a class="markdownIt-Anchor" href="# 逆序输出文章"></a> 逆序输出文章 </h3>
<p><strong> 题目：</strong></p>
<p> 输入一篇英文文章，将每个词颠倒顺序进行输出，每个词仍保证有序 </p>
<p><strong> 思路：</strong></p>
<p> 将每个词放入 List 集合中，对特定格式的词进行处理（包含 ‘, ‘，’.’），然后逆序遍历输出即可 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Aidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2021/11/13 14:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@GitHub</span> github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReviseArticle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        String[] s1 = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(s1));</span><br><span class="line"></span><br><span class="line">        Collections.reverse(strings);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (string.contains(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">                String[] split = string.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                System.out.print(split[<span class="number">1</span>]);</span><br><span class="line">                System.out.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                System.out.print(split[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (string.contains(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">                String[] split = string.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (split.length == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                    System.out.print(string.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27; &#x27;</span>));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.print(split[<span class="number">1</span>]);</span><br><span class="line">                    System.out.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                    System.out.print(split[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(string);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; strings.size()) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数美科技"><a class="markdownIt-Anchor" href="# 数美科技"></a> 数美科技 </h2>
<p><strong> 题目：</strong></p>
<p> 如果有相邻字符是连续状态则可以看作是连续子串，输入一串字符，求其中连续子串的个数 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Aidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2021/11/18 20:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@GitHub</span> github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubStr</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将连续子串放入 set 中防止重复 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 截取字符串的不中断连续子串 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j + <span class="number">1</span> &lt; str.length() &amp;&amp; str.charAt(j + <span class="number">1</span>) == str.charAt(j) + <span class="number">1</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            numSub(str.substring(i, j + <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// i 会自增，使用 j 即可 </span></span><br><span class="line">            i = j;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结果去掉空串 </span></span><br><span class="line">        System.out.println(set.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个连续子串又可以分成 n(n+1)/2 个（不包括空串）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string 截取的不中断连续子串 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">numSub</span><span class="params">(String string)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子串可以分隔成 i~n 中长度 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= string.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j + i &lt;= string.length(); j++) &#123;</span><br><span class="line">                set.add(string.substring(j, j + i));</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(string.substring(j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT 甲级 - 入门模拟</title>
    <url>/pat_level_a-get_start/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p>当时准备 PAT 竞赛时候，买了本《算法笔记》，书中将题型进行分类，是我最系统的一次算法学习，对题型判断、解题思路都有了新的认知，本篇文章主要记录当时刷的入门模拟题，算是比较简单的算法题（有些都不能称之为算法），就当是打基础了</p>
<p>包括分类：<a href="#%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F">简单模拟 </a>、<a href="#%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"> 查找元素 </a>、<a href="#%E5%9B%BE%E5%BD%A2%E8%BE%93%E5%87%BA"> 图形输出 </a>、<a href="#%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86"> 日期处理 </a>、<a href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"> 进制转换 </a>、<a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86"> 字符串处理</a></p>
<span id="more"></span>
<h2 id="简单模拟"><a class="markdownIt-Anchor" href="# 简单模拟"></a> 简单模拟</h2>
<h3 id="思想解释"><a class="markdownIt-Anchor" href="# 思想解释"></a> 思想解释</h3>
<p>根据题目的要求去做即可，主要考察代码的编写能力</p>
<h3 id="类型练习"><a class="markdownIt-Anchor" href="# 类型练习"></a> 类型练习</h3>
<h4 id="1042"><a class="markdownIt-Anchor" href="#1042"></a> 1042</h4>
<p><strong>题目：Shuffling Machine</strong></p>
<p>Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine.</p>
<p>The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:</p>
<p>S1, S2, …, S13, H1, H2, …, H13, C1, C2, …, C13, D1, D2, …, D13, J1, J2</p>
<p>where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains a positive integer K (&lt;= 20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>2<br />
36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5</p>
</blockquote>
<p><strong>思路：</strong> 用字符串不如使用整型数组直接进行循环调换，根据其编号输出对应的花色</p>
<ul>
<li>
<p>建立三个整型数组，分别用来存储初始顺序、洗牌后的顺序、洗牌规则</p>
</li>
<li>
<p>每次洗牌就是将规则数组中的当前数字作为下标用来控制洗牌后的数组被赋值洗牌前的编号</p>
</li>
<li>
<p>最后花色和数值的输出需要对编号进行 -1，这样是为了防止 13、26…这样的边界数字越界的情况，但输出数值时需要再 +1</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> times;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;times); <span class="comment">// 输入洗牌几次</span></span><br><span class="line">    <span class="type">int</span> start[<span class="number">55</span>], end[<span class="number">55</span>], order[<span class="number">55</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">55</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;order[i]); <span class="comment">// 输入洗牌规则</span></span><br><span class="line">        start[i] = i;           <span class="comment">// 初始化默认排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">55</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            end[order[j]] = start[j]; <span class="comment">// 根据规则洗牌</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; <span class="number">55</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            start[k] = end[k]; <span class="comment">// 将每次洗完的牌放到初始数组，为下一次洗牌做准备</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> color[<span class="number">5</span>] = &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;J&#x27;</span>&#125;; <span class="comment">// 字符花色数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">55</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        end[i]--;</span><br><span class="line">        <span class="comment">// 每次的序号都要自减，防止 13、26…这样的数字除和摸出 13 时得到的值不符合逻辑</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c%d&quot;</span>, color[end[i] / <span class="number">13</span>], end[i] % <span class="number">13</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">54</span>)</span><br><span class="line">        &#123; <span class="comment">// 避免额外空格</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1046"><a class="markdownIt-Anchor" href="#1046"></a> 1046</h4>
<p><strong>题目：Shortest Distance</strong></p>
<p>The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains an integer N (in [3,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>]), followed by N integer distances D1 D2 ⋯ DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (≤<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>5 1 2 4 14 9<br />
3<br />
1 3<br />
2 5<br />
4 1</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>3<br />
10<br />
7</p>
</blockquote>
<p><strong>思路：</strong> 实际上只有一条循环线路，只要求出单个方向（如顺时针）的值，用距离总和减去后获得反向距离，返回二者最小值</p>
<ul>
<li>
<p>创建一个距离数组 <code>distance[]</code>，其中<code>distance[i]</code> 中保存的是从 V1 点到 Vi+1 的距离，在输入时就将数组和距离总和记录下来减少复杂度</p>
</li>
<li>
<p>输入的起点 begin 和终点 end 之间的顺时针距离 dis_left 为 <code>dis_left=distance[end-1]-distance[begin-1]</code>，需要判断 begin 与 end 的大小关系，始终保持小的在前</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n + <span class="number">1</span>)</span></span>; <span class="comment">// 动态数组分配空间后所有的值为 0</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, left, right;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp);</span><br><span class="line">        sum += temp;</span><br><span class="line">        dis[i] = sum; <span class="comment">// 距离数组保存的是 V1 到 Vi 的顺时针距离</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cnt); <span class="comment">// 输入判断几对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;left, &amp;right);</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="comment">// 始终保持顺时针判断</span></span><br><span class="line">            <span class="built_in">swap</span>(left, right);</span><br><span class="line">        <span class="type">int</span> temp = dis[right - <span class="number">1</span>] - dis[left - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">min</span>(temp, sum - temp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1065"><a class="markdownIt-Anchor" href="#1065"></a> 1065</h4>
<p><strong>题目：A+B and C (64bit)</strong></p>
<p>Given three integers A, B and C in [−<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>63</mn></msup></mrow><annotation encoding="application/x-tex">2^{63}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>63</mn></msup></mrow><annotation encoding="application/x-tex">2^{63}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>)，you are supposed to tell whether A+B&gt;C.</p>
<p><em>Input Specification:</em></p>
<p>The first line of the input gives the positive number of test cases, T (≤10). Then T test cases follow, each consists of a single line containing three integers A, B and C, separated by single spaces.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, output in one line <code>Case #X: true</code> if A+B&gt;C, or <code>Case #X: false</code> otherwise, where X is the case number (starting from 1).</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>3<br />
1 2 3<br />
2 3 4<br />
9223372036854775807 -9223372036854775808 0</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>Case #1: false<br />
Case #2: true<br />
Case #3: false</p>
</blockquote>
<p><strong>思路：</strong> 数据类型过大用 <code>long long</code> 型进行存储，同时需要考虑溢出的情况（同为正值溢出必大于，同为负值溢出必小于）</p>
<ul>
<li>
<p>因为 A、B 的大小为 [-2^63, 2^63），用 long long 存储 A 和 B 的值，以及他们相加的值 sum</p>
</li>
<li>
<p>如果 A &gt; 0, B &lt; 0 或者 A &lt; 0, B &gt; 0，sum 是不可能溢出的</p>
</li>
<li>
<p>如果 A &gt; 0, B &gt; 0，sum 可能会溢出，sum 范围理应为 (0, 2^64 – 2]，溢出得到的结果应该是 [-2^63, -2] 是个负数，所以 sum &lt; 0 时候说明溢出了</p>
</li>
<li>
<p>如果 A &lt; 0, B &lt; 0，sum 可能会溢出，同理，sum 溢出后结果是大于 0 的，所以 sum &gt; 0 说明溢出了</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = a + b;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span> &amp;&amp; sum &lt; <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">// 正溢出，结果必定大于 C</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: true\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span> &amp;&amp; sum &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">// 负溢出，两个负数相加而且溢出，必小于 C</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: false\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; c) <span class="comment">// 无溢出，正常比较</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: true\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: false\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1002"><a class="markdownIt-Anchor" href="#1002"></a> 1002</h4>
<p><strong>题目：A+B for Polynomials</strong></p>
<p>This time, you are supposed to find A+B where A and B are two polynomials.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p>
<blockquote>
<p>K N1 aN1 N2 aN2 … NK aNK</p>
</blockquote>
<p>where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤NK&lt;⋯&lt; N2&lt;N1≤1000.</p>
<p><em>Output Specification:</em></p>
<p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>2 1 2.4 0 3.2<br />
2 2 1.5 1 0.5</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>3 2 1.5 1 2.9 0 3.2</p>
</blockquote>
<p><strong>思路：</strong> 使用浮点数组用指数作为下标，存储系数的值，只要指数相同就为同一项，系数直接相加即可</p>
<ul>
<li>
<p>数组长度为指数的最大值 1000，<code>poly[i] = j</code>表示指数 i 的系数为 j，接收 exponent 和 coefficient 输入的同时将对应指数的系数加入到 poly 数组中，所有非零系数的个数，然后从前往后输出所有系数不为 0 的指数和系数</p>
</li>
<li>
<p>注意输出格式和输出的精度</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">coef</span><span class="params">(<span class="number">1001</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 根据数据规模，创建浮点数组存储系数</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;                  <span class="comment">// 判断最后有多少项</span></span><br><span class="line">    <span class="type">int</span> m, n;                     <span class="comment">// 获取每行有多少项</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> e_temp;</span><br><span class="line">        <span class="type">double</span> c_temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %lf&quot;</span>, &amp;e_temp, &amp;c_temp); <span class="comment">// 根据项数输入指数和系数</span></span><br><span class="line">        coef[e_temp] += c_temp;            <span class="comment">// 用指数作为下标将系数相加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> e_temp;</span><br><span class="line">        <span class="type">double</span> c_temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %lf&quot;</span>, &amp;e_temp, &amp;c_temp);</span><br><span class="line">        coef[e_temp] += c_temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coef.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (coef[i])</span><br><span class="line">        &#123; <span class="comment">// 记录所有不为 0 的项</span></span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1000</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (coef[i])</span><br><span class="line">        &#123; <span class="comment">// 不为 0 便输出指数和系数，注意空格和小数点为 1 位</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d %.1f&quot;</span>, i, coef[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1009"><a class="markdownIt-Anchor" href="#1009"></a> 1009</h4>
<p><strong>题目：Product of Polynomials</strong></p>
<p>This time, you are supposed to find A×B where A and B are two polynomials.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p>
<blockquote>
<p>K N1 aN1 N2 aN2 … NK aNK</p>
</blockquote>
<p>where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, ⋯, K) are the exponents and coefficients, respectively. It is given that 1≤K≤10, 0≤NK&lt;⋯&lt;N2&lt;N1≤1000.</p>
<p><em>Output Specification:</em></p>
<p>For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>2 1 2.4 0 3.2<br />
2 2 1.5 1 0.5</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>3 3 3.6 2 6.0 1 1.6</p>
</blockquote>
<p><strong>思路：</strong> 建立两个数组，一个保存第一行的多项式，一个在第二行读入时，直接循环第一个数组的内容进行处理存储</p>
<ul>
<li>
<p>因为是乘法，根据最大指数为 1000，那么乘积的最大指数就是 2000，所以 ans 数组的数据规模为 2001</p>
</li>
<li>
<p>无需将两个多项式分别保存完再处理，在输入第二个多项式时直接循环与第一个多项式的每一项相乘即可（只算非零）</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">coef</span><span class="params">(<span class="number">1001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">2001</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 根据指数最大为 1000，相乘后最大的指数为 1000+1000</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> e_temp;</span><br><span class="line">        <span class="type">double</span> c_temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %lf&quot;</span>, &amp;e_temp, &amp;c_temp);</span><br><span class="line">        coef[e_temp] += c_temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> e_temp;</span><br><span class="line">        <span class="type">double</span> c_temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %lf&quot;</span>, &amp;e_temp, &amp;c_temp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coef.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123; <span class="comment">// 在第二行每输入一项，就与第一行的每项相乘，得到的值根据相同指数加到 ans 数组中</span></span><br><span class="line">            <span class="keyword">if</span> (coef[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[i + e_temp] += coef[i] * c_temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2000</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d %.1f&quot;</span>, i, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="查找元素"><a class="markdownIt-Anchor" href="# 查找元素"></a> 查找元素</h2>
<h3 id="思想解释 -2"><a class="markdownIt-Anchor" href="# 思想解释 -2"></a> 思想解释</h3>
<p>在一组给定的元素中查找目标元素，范围较小可直接遍历查找，或者使用某些数据类型自带的 find() 函数，查找最大最小值可以使用 [algorithm] 下的 max_elemen() 函数等</p>
<h4 id="二分查找"><a class="markdownIt-Anchor" href="# 二分查找"></a> 二分查找</h4>
<p>有些元素的数据范围较大，采用遍历消耗的时间难免过多，所以采用二分查找的方式能够用较小的时间复杂度来完成</p>
<p>具体思路就是每次确定中值<code>mid=(left+right)/2</code>，用要查询的数 x 与 mid 进行比较，根据大小关系再与另一半进行比较，值得注意的是，有些数据范围实在是太大导致 left+right 的值就已经超过的 int 支持的数据范围，这时可以使用<code>mid=left+(right-left)/2</code><br />
在 [algorithm] 下的模板函数为：<code>binary_search(first,last,val)</code></p>
<h3 id="类型练习 -2"><a class="markdownIt-Anchor" href="# 类型练习 -2"></a> 类型练习</h3>
<h4 id="1011"><a class="markdownIt-Anchor" href="#1011"></a> 1011</h4>
<p><strong>题目：World Cup Betting</strong></p>
<p>With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.</p>
<p>Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%.</p>
<p>For example, 3 games’ odds are given as the following:</p>
<blockquote>
<p>W    T     L<br />
1.1  2.5  1.7<br />
1.2  3.1  1.6<br />
4.1  1.2  1.1</p>
</blockquote>
<p>To obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1×3.1×2.5×65%−1)×2=39.31 yuans (accurate up to 2 decimal places).</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>1.1 2.5 1.7<br />
1.2 3.1 1.6<br />
4.1 1.2 1.1</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>T T W 39.31</p>
</blockquote>
<p><strong>思路：</strong> 每次输入时就与前一个值比较只获取最大值，利用输入时的顺序为下标输出字符，最好将每次最大值相乘，按公式输出</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">4</span>] = &#123;<span class="string">&quot;WTL&quot;</span>&#125;; <span class="comment">// 还应存储一个 &#x27;\0&#x27; 表示结束</span></span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0.65</span>;   <span class="comment">// 答案初始为 0.65，无需输出时计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> maxvalue = <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">int</span> maxchar = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;temp);</span><br><span class="line">            <span class="keyword">if</span> (maxvalue &lt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                maxvalue = temp;</span><br><span class="line">                maxchar = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans *= maxvalue;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, c[maxchar]); <span class="comment">// 输出符号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>, (ans - <span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1006"><a class="markdownIt-Anchor" href="#1006"></a> 1006</h4>
<p><strong>题目：Sign In and Sign Out</strong></p>
<p>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:<br />
<code>ID_number  Sign_in_time  Sign_out_time</code></p>
<p>where times are given in the format <code>HH: MM: SS</code> , and <code>ID_number</code> is a string with no more than 15 characters.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.</p>
<p>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>3</p>
</blockquote>
<p>CS301111 15:30:28 17:00:10<br />
SC3021234 08:00:00 11:25:25<br />
CS301133 21:45:00 21:58:40</p>
<p><em>Sample Output:</em></p>
<blockquote>
<p>SC3021234 CS301133</p>
</blockquote>
<p><strong>思路：</strong> 将时间用 <code>scanf()</code> 读入转换为秒，最小的时间为开门人保存其 string 的 ID，最大为锁门人，因为是 string 型，用 iostream</p>
<ul>
<li>
<p>无需建立数组，最后只输出 ID，使用一个 string 型保存，其他用临时变量处理即可</p>
</li>
<li>
<p>输入中的冒号符号和空格用 scanf 处理</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, max = INT_MIN, min = INT_MAX;</span><br><span class="line">    string unlock, lock;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);            <span class="comment">// 读入人数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 建立人数循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        string Id;</span><br><span class="line">        cin &gt;&gt; Id; <span class="comment">// 输入每个人的 ID</span></span><br><span class="line">        <span class="type">int</span> h1, m1, s1, h2, m2, s2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d %d:%d:%d&quot;</span>, &amp;h1, &amp;m1, &amp;s1, &amp;h2, &amp;m2, &amp;s2);</span><br><span class="line">        <span class="type">int</span> in_temp = h1 * <span class="number">3600</span> + m1 * <span class="number">60</span> + s1; <span class="comment">// 将所有的时间转换成秒</span></span><br><span class="line">        <span class="type">int</span> out_temp = h2 * <span class="number">3600</span> + m2 * <span class="number">60</span> + s2;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; in_temp) <span class="comment">// 最小的时间就是开锁人</span></span><br><span class="line">        &#123;</span><br><span class="line">            min = in_temp;</span><br><span class="line">            unlock = Id; <span class="comment">// 保存 ID</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; out_temp) <span class="comment">// 最大的时间就是锁门人</span></span><br><span class="line">        &#123;</span><br><span class="line">            max = out_temp;</span><br><span class="line">            lock = Id; <span class="comment">// 保存 ID</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; unlock &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; lock;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1036"><a class="markdownIt-Anchor" href="#1036"></a> 1036</h4>
<p><strong>题目：Boys vs Girls</strong></p>
<p>This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case contains a positive integer N, followed by N lines of student information. Each line contains a student’s <code>name</code>, <code>gender</code>, <code>ID</code> and <code>grade</code>, separated by a space, where <code>name</code> and <code>ID</code> are strings of no more than 10 characters with no space, <code>gender</code> is either <code>F</code> (female) or <code>M</code> (male), and <code>grade</code> is an integer between 0 and 100. It is guaranteed that all the grades are distinct.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the difference gradeF−gradeM. If one such kind of student is missing, output <code>Absent</code> in the corresponding line, and output <code>NA</code> in the third line instead.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>3<br />
Joe M Math990112 89<br />
Mike M CS991301 100<br />
Mary F EE990830 95</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>Mary EE990830<br />
Joe Math990112<br />
6</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>1<br />
Jean M AA980920 60</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>Absent<br />
Jean AA980920<br />
NA</p>
</blockquote>
<p><strong>思路：</strong> 用 string 类型的 M 和 F 保存要求的学生的信息，F_max 和 M_min 处保存男生的最低分和女生的最高分</p>
<ul>
<li>
<p>输出姓名和编号时用一个字符串进行拼接即可</p>
</li>
<li>
<p>如果成绩还为赋予的初始值说名没有符合条件的人，按条件进行更改输出</p>
</li>
<li>
<p>最后输出的差要男女生的成绩同时被更改，判断大小关系（也可用绝对值输出）后输出</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, M_min = <span class="number">101</span>, F_max = <span class="number">-1</span>; <span class="comment">// 设置人数变量，同时根据范围确定最大最小值</span></span><br><span class="line">    string M, F;                    <span class="comment">// 男女生输出的姓名和编号可以用一个字符串搞定</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 根据人数构建循环处理每行数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        string name_temp, Id_temp; <span class="comment">// 临时字符串保存姓名和编号</span></span><br><span class="line">        <span class="type">char</span> gender;</span><br><span class="line">        <span class="type">int</span> grade;</span><br><span class="line">        cin &gt;&gt; name_temp &gt;&gt; gender &gt;&gt; Id_temp &gt;&gt; grade;</span><br><span class="line">        <span class="keyword">if</span> (gender == <span class="string">&#x27;M&#x27;</span> &amp;&amp; grade &lt; M_min) <span class="comment">// 男生且成绩小于男生成绩的最小值</span></span><br><span class="line">        &#123;</span><br><span class="line">            M_min = grade;                 <span class="comment">// 成绩覆盖</span></span><br><span class="line">            M = name_temp + <span class="string">&quot; &quot;</span> + Id_temp; <span class="comment">// 保存姓名和编号</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (gender == <span class="string">&#x27;F&#x27;</span> &amp;&amp; grade &gt; F_max) <span class="comment">// 女生且成绩大于女生成绩的最大值</span></span><br><span class="line">        &#123;</span><br><span class="line">            F_max = grade;</span><br><span class="line">            F = name_temp + <span class="string">&quot; &quot;</span> + Id_temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (F_max != <span class="number">-1</span>) <span class="comment">// 如果成绩被改动说明有符合条件的人可以输出</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; F &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Absent\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (M_min != <span class="number">101</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; M &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Absent\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (M_min != <span class="number">101</span> &amp;&amp; F_max != <span class="number">-1</span>) <span class="comment">// 如果男女生的成绩都有符合条件的人</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">abs</span>(M_min - F_max); <span class="comment">// 用绝对值输出，防止大小颠倒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图形输出"><a class="markdownIt-Anchor" href="# 图形输出"></a> 图形输出</h2>
<h3 id="思想解释 -3"><a class="markdownIt-Anchor" href="# 思想解释 -3"></a> 思想解释</h3>
<p>根据题目给出的规则输出图形，主要考察的是对规则的总结，主要的实现手段有两种</p>
<ol>
<li>
<p>根据规律直接进行输出</p>
</li>
<li>
<p>根据规律对二维数组进行填充，然后直接输出整个二维数组，如杨辉三角形，注意不论形状为何，统一用行列的方式填入，用空格控制输出</p>
</li>
</ol>
<h3 id="类型练习 -3"><a class="markdownIt-Anchor" href="# 类型练习 -3"></a> 类型练习</h3>
<h4 id="1031"><a class="markdownIt-Anchor" href="#1031"></a> 1031</h4>
<p><strong>题目：Hello World for U</strong></p>
<p>Given any string of N (≥5) characters, you are asked to form the characters into the shape of <code>U</code> . For example, <code>helloworld</code> can be printed as:</p>
<blockquote>
<p>h   d<br />
e    l<br />
l     r<br />
lowo</p>
</blockquote>
<p>That is, the characters must be printed in the original order, starting top-down from the left vertical line with n1 characters, then left to right along the bottom line with n2 characters, and finally bottom-up along the vertical line with n3 characters. And more, we would like <code>U</code> to be as squared as possible – that is, it must be satisfied that:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mn>1</mn><mo>=</mo><mi>n</mi><mn>3</mn><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>k</mi><mo>≤</mo><mi>n</mi><mn>2</mn><mi>f</mi><mi>o</mi><mi>r</mi><mi>a</mi><mi>l</mi><mi>l</mi><mn>3</mn><mo>≤</mo><mi>n</mi><mn>2</mn><mo>≤</mo><mi>N</mi></mrow><mi>w</mi><mi>i</mi><mi>t</mi><mi>h</mi><mi>n</mi><mn>1</mn><mo>+</mo><mi>n</mi><mn>2</mn><mo>+</mo><mi>n</mi><mn>3</mn><mtext>−</mtext><mn>2</mn><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">n1=n3=max {k | k≤n2 for all 3≤n2≤N} with n1+n2+n3−2=N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">n</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">n</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">n</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mord">3</span><span class="mord">−</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case contains one string with no less than 5 and no more than 80 characters in a line. The string contains no white space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print the input string in the shape of U as specified in the description.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>helloworld!</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>h      !<br />
e     d<br />
l       l<br />
lowor</p>
</blockquote>
<p><strong>思路：</strong> 确定长和宽的值，根据规则直接输出或者填充到数组输出</p>
<ul>
<li>主要要求为：n1 == n3；n2 &gt;= n1；n1 为在满足上述条件的情况下的最大值</li>
<li>根据条件 n=length+2 得出 n1 = n / 3，n2 = n / 3 + n % 3</li>
<li>注意：字符数组的输入不要用 gets() 函数，可能造成编译无法通过的情况</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组型</span></span><br><span class="line">    <span class="type">char</span> str[<span class="number">81</span>], map[<span class="number">30</span>][<span class="number">30</span>];     <span class="comment">// 创建一个二维数组</span></span><br><span class="line">    <span class="built_in">memset</span>(map, <span class="string">&#x27; &#x27;</span>, <span class="built_in">sizeof</span>(map)); <span class="comment">// 全部初始化为空格</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(str) + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> row = length / <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> column = length - <span class="number">2</span> * row;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        map[i][<span class="number">0</span>] = str[i];</span><br><span class="line">        map[i][column - <span class="number">1</span>] = str[length - <span class="number">3</span> - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; column; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        map[row - <span class="number">1</span>][i] = str[row - <span class="number">1</span> + i];</span><br><span class="line">    &#125; <span class="comment">// 对二维数组填充</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, map[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != row - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 直接输出型</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="type">int</span> n1 = (n + <span class="number">2</span>) / <span class="number">3</span>, n3 = n1, n2 = (n + <span class="number">2</span>) - <span class="number">2</span> * n1; <span class="comment">// 确定 n1,n2,n3 的长度，n1 和 n3 一个就够</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1 - <span class="number">1</span>; i++)</span><br><span class="line">    &#123; <span class="comment">// 输出没有底层的所有</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, str[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n2 - <span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, str[n - <span class="number">1</span> - i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++)</span><br><span class="line">    &#123; <span class="comment">// 输出底层</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, str[n1 - <span class="number">1</span> + i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1164"><a class="markdownIt-Anchor" href="#1164"></a> 1164</h4>
<p><strong>题目：Good in C</strong></p>
<p>When your interviewer asks you to write “Hello World” using C, can you do as the following figure shows?</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first part gives the 26 capital English letters A-Z, each in a 7×5 matrix of C’s and .'s. Then a sentence is given in a line, ended by a return. The sentence is formed by several words (no more than 10 continuous capital English letters each), and the words are separated by any characters other than capital English letters.</p>
<p>It is guaranteed that there is at least one word given.</p>
<p><em>Output Specification:</em></p>
<p>For each word, print the matrix form of each of its letters in a line, and the letters must be separated by exactly one column of space. There must be no extra space at the beginning or the end of the word.</p>
<p>Between two adjacent words, there must be a single empty line to separate them. There must be no extra line at the beginning or the end of the output.</p>
<p><em>Sample Input:</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">..C..</span><br><span class="line">.C.C.</span><br><span class="line">C...C</span><br><span class="line">CCCCC</span><br><span class="line">C...C</span><br><span class="line">CCCC.</span><br><span class="line">C...C</span><br><span class="line">CCCC.</span><br><span class="line">C...C</span><br><span class="line">CCCC.</span><br><span class="line">.CCC.</span><br><span class="line">C...C</span><br><span class="line">C....</span><br><span class="line">C...C</span><br><span class="line">.CCC.</span><br><span class="line">CCCC.</span><br><span class="line">C...C</span><br><span class="line">CCCC.</span><br><span class="line">CCCCC</span><br><span class="line">C....</span><br><span class="line">CCCC.</span><br><span class="line">C....</span><br><span class="line">CCCCC</span><br><span class="line">C....</span><br><span class="line">CCCC.</span><br><span class="line">C....</span><br><span class="line">CCCC.</span><br><span class="line">C...C</span><br><span class="line">C....</span><br><span class="line">C.CCC</span><br><span class="line">C...C</span><br><span class="line">CCCC.</span><br><span class="line">C...C</span><br><span class="line">CCCCC</span><br><span class="line">C...C</span><br><span class="line">CCCCC</span><br><span class="line">..C..</span><br><span class="line">CCCCC</span><br><span class="line">....C</span><br><span class="line">C...C</span><br><span class="line">.CCC.</span><br><span class="line">C...C</span><br><span class="line">C..C.</span><br><span class="line">C.C..</span><br><span class="line">CC...</span><br><span class="line">C.C..</span><br><span class="line">C..C.</span><br><span class="line">C...C</span><br><span class="line">C....</span><br><span class="line">CCCCC</span><br><span class="line">C...C</span><br><span class="line">CC.CC</span><br><span class="line">C.C.C</span><br><span class="line">C...C</span><br><span class="line">CC..C</span><br><span class="line">C.C.C</span><br><span class="line">C..CC</span><br><span class="line">C...C</span><br><span class="line">.CCC.</span><br><span class="line">C...C</span><br><span class="line">.CCC.</span><br><span class="line">CCCC.</span><br><span class="line">C...C</span><br><span class="line">CCCC.</span><br><span class="line">C....</span><br><span class="line">.CCC.</span><br><span class="line">C...C</span><br><span class="line">C.C.C</span><br><span class="line">C..CC</span><br><span class="line">.CCC.</span><br><span class="line">CCCC.</span><br><span class="line">C...C</span><br><span class="line">CCCC.</span><br><span class="line">CC...</span><br><span class="line">C.C..</span><br><span class="line">C..C.</span><br><span class="line">C...C</span><br><span class="line">.CCC.</span><br><span class="line">C...C</span><br><span class="line">C....</span><br><span class="line">.CCC.</span><br><span class="line">....C</span><br><span class="line">C...C</span><br><span class="line">.CCC.</span><br><span class="line">CCCCC</span><br><span class="line">..C..</span><br><span class="line">C...C</span><br><span class="line">.CCC.</span><br><span class="line">C...C</span><br><span class="line">.C.C.</span><br><span class="line">..C..</span><br><span class="line">C...C</span><br><span class="line">C.C.C</span><br><span class="line">CC.CC</span><br><span class="line">C...C</span><br><span class="line">.C.C.</span><br><span class="line">..C..</span><br><span class="line">.C.C.</span><br><span class="line">C...C</span><br><span class="line">.C.C.</span><br><span class="line">..C..</span><br><span class="line">CCCCC</span><br><span class="line">....C</span><br><span class="line">...C.</span><br><span class="line">..C..</span><br><span class="line">.C...</span><br><span class="line">C....</span><br><span class="line">CCCCC</span><br><span class="line">HELLO~WORLD!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>Sample Output:</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C... C CCCCC C.... C.... . CCC.</span><br><span class="line">C... C C.... C.... C.... C... C</span><br><span class="line">CCCCC CCCC. C.... C.... C... C</span><br><span class="line">C... C C.... C.... C.... C... C</span><br><span class="line">C... C CCCCC CCCCC CCCCC . CCC.</span><br><span class="line"></span><br><span class="line">C... C . CCC. CCCC. C.... CCCC.</span><br><span class="line">C... C C... C C... C C.... C... C</span><br><span class="line">C... C C... C CCCC. C.... C... C</span><br><span class="line">C. C. C C... C CC... C.... C... C</span><br><span class="line">CC. CC C... C C. C.. C.... C... C</span><br><span class="line">C... C C... C C.. C. C.... C... C</span><br><span class="line">C... C . CCC. C... C CCCCC CCCC.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong> 使用二维的字符串数组保存每个字母的七行，对目标单词不是大写字母的作为分割，将每一个单词的字母获取它的字母序号放入数组，对每个单词遍历输出每一行，使用标记记录是否有一个单词被输出，用来输出空行</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string let[<span class="number">26</span>][<span class="number">7</span>], str; <span class="comment">// 保存图形样式，保存目标字符串</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; word;       <span class="comment">// 保存每个符合条件的单词</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; let[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin.<span class="built_in">ignore</span>(); <span class="comment">// 目标字符串要获取整行，忽略上一个换行</span></span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">// 标记是否有单词被输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isupper</span>(str[i]) &amp;&amp; i == str.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="comment">// 存在最后一个的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            word.<span class="built_in">push_back</span>(str[i] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isupper</span>(str[i]) &amp;&amp; i != str.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="comment">// 用非大写字母或者结尾进行一次输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            word.<span class="built_in">push_back</span>(str[i] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="comment">// 判断之前是否有单词被输出</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; endl</span><br><span class="line">                     &lt;&lt; endl;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) <span class="comment">// 每个单词输出 7 行</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; word.<span class="built_in">size</span>(); k++) <span class="comment">// 输出每个单词的每一行</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k != <span class="number">0</span>) <span class="comment">// 空格相隔</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cout &lt;&lt; let[word[k]][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">6</span>) <span class="comment">// 换行</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            word.<span class="built_in">clear</span>(); <span class="comment">// 清空保存数组进行下一次输出</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="日期处理"><a class="markdownIt-Anchor" href="# 日期处理"></a> 日期处理</h2>
<h3 id="思想解释 -4"><a class="markdownIt-Anchor" href="# 思想解释 -4"></a> 思想解释</h3>
<p>主要解决的是平年和闰年造成的二月日期差异，还有大小月的不同，PAT 暂没有这样的试题</p>
<h3 id="类型练习 -4"><a class="markdownIt-Anchor" href="# 类型练习 -4"></a> 类型练习</h3>
<p>求日期差值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目：以 6 位格式输入两个日期，求两个日期之间的天数，包括这两个日期（如果两个日期相邻那么就是两天）</span></span><br><span class="line"><span class="comment">思路：书上是用循环模拟的方法写的，复杂度太高 </span></span><br><span class="line"><span class="comment"> 先求出每个日期离开年过了多少天，如果年份相同，互减 +1 即可 </span></span><br><span class="line"><span class="comment"> 年份不同，算出隔了多少年，在判断每年是闰年还是平年，得到相应的天数，最后减去较早年份已经过去的日子 +1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judgeYear</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 判断是否闰年</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> year % <span class="number">400</span> == <span class="number">0</span> || (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countDate</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 计算每个日期离开年过去的天数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (month)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        sum = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        sum = <span class="number">59</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        sum = <span class="number">90</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        sum = <span class="number">120</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        sum = <span class="number">151</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        sum = <span class="number">181</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        sum = <span class="number">212</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        sum = <span class="number">243</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        sum = <span class="number">273</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        sum = <span class="number">304</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        sum = <span class="number">334</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += day;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">judgeYear</span>(year) &amp;&amp; month &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> date1, date2; </span><br><span class="line">    cin &gt;&gt; date1 &gt;&gt; date2; </span><br><span class="line">    <span class="type">int</span> year1, month1, day1; </span><br><span class="line">    <span class="type">int</span> year2, month2, day2; </span><br><span class="line">    <span class="keyword">if</span> (date1 &gt; date2)</span><br><span class="line">    &#123; <span class="comment">// 始终让较早的日期在前</span></span><br><span class="line">        <span class="type">int</span> t = date1; </span><br><span class="line">        date1 = date2; </span><br><span class="line">        date2 = t; </span><br><span class="line">    &#125;</span><br><span class="line">    year1 = date1 / <span class="number">10000</span>; </span><br><span class="line">    month1 = date1 % <span class="number">10000</span> / <span class="number">100</span>; </span><br><span class="line">    day1 = date1 % <span class="number">100</span>; </span><br><span class="line">    year2 = date2 / <span class="number">10000</span>; </span><br><span class="line">    month2 = date2 % <span class="number">10000</span> / <span class="number">100</span>; </span><br><span class="line">    day2 = date2 % <span class="number">100</span>; </span><br><span class="line">    <span class="comment">// 获取每个日期的实际年月日</span></span><br><span class="line">    <span class="type">int</span> difDay; <span class="comment">// 记录相差天数</span></span><br><span class="line">    <span class="keyword">if</span> (year1 == year2)</span><br><span class="line">    &#123; <span class="comment">// 年份相同的情况</span></span><br><span class="line">        difDay = <span class="built_in">countDate</span>(year2, month2, day2) - <span class="built_in">countDate</span>(year1, month1, day1) + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">// 年份不同</span></span><br><span class="line">        difDay = <span class="built_in">countDate</span>(year2, month2, day2); </span><br><span class="line">        <span class="type">int</span> difYear = year2 - year1; </span><br><span class="line">        <span class="keyword">while</span> (difYear)</span><br><span class="line">        &#123; <span class="comment">// 判断每一年的天数</span></span><br><span class="line">            <span class="built_in">judgeYear</span>(year2 - difYear) ? difDay += <span class="number">366</span> : difDay += <span class="number">365</span>; </span><br><span class="line">            difYear--; </span><br><span class="line">        &#125;</span><br><span class="line">        difDay -= <span class="built_in">countDate</span>(year1, month1, day1) - <span class="number">1</span>; <span class="comment">// 减去开始年份已经过去（在循环中也加上了）</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; difDay &lt;&lt; endl; </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="进制转换"><a class="markdownIt-Anchor" href="# 进制转换"></a> 进制转换</h2>
<h3 id="思想解释 -5"><a class="markdownIt-Anchor" href="# 思想解释 -5"></a> 思想解释</h3>
<p>主要是不同进制的输入输出，熟练使用 strtol() 函数和 _itoa() 函数</p>
<h3 id="类型练习 -5"><a class="markdownIt-Anchor" href="# 类型练习 -5"></a> 类型练习</h3>
<h4 id="1019"><a class="markdownIt-Anchor" href="#1019"></a> 1019</h4>
<p><strong>题目：General Palindromic Number</strong></p>
<p>A number that will be the same when it is written forwards or backwards is known as a <strong>Palindromic Number</strong>. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.</p>
<p>Although palindromic numbers are most often considered in the decimal system, the concept of palindromicity can be applied to the natural numbers in any numeral system. Consider a number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> in base <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">b≥2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>, where it is written in standard notation with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> digits <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>k</mi></msubsup><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><msup><mi>b</mi><mi>i</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">∑^k_{i=0}(a_ib^i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. Here, as usual, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">0≤a_i&lt;b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is nonzero. Then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> is palindromic if and only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mrow><mi>k</mi><mtext>−</mtext><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_i=a_{k−i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">−</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>. Zero is written 0 in any base and is also palindromic by definition.</p>
<p>Given any positive decimal integer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>and a base <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>, you are supposed to tell if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>is a palindromic number in base <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case consists of two positive numbers <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>and b, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">0&lt;N≤10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> is the decimal number and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo><mi>b</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">2≤b≤10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> is the base. The numbers are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, first print in one line <code>Yes</code> if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>is a palindromic number in base <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>, or <code>No</code> if not. Then in the next line, print <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> as the number in base <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>in the form “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub><msub><mi>a</mi><mrow><mi>k</mi><mtext>−</mtext><mn>1</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_k a_{k−1} ... a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>”. Notice that there must be no extra space at the end of output.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>27 2</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>Yes<br />
1 1 0 1 1</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>121 5</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>No<br />
4 4 1</p>
</blockquote>
<p><strong>思路：</strong> 构建一个数组，循环计算<code>mod(N,k)</code>，放到数组中，判断数组是否为回文即可</p>
<ul>
<li>while 循环的判断条件为 <code>N!=0</code> 或者 <code>!(N&lt;k)</code>采用第二种时还需把 N 的值放到数组作为最后一个余数，使用第一种</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mod;</span><br><span class="line">    <span class="type">int</span> N, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;k);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    while (!(N &lt; k)) // 相等时仍要继续计算，也可以使用 N!=0 作为判断条件</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        mod.push_back(N % k);</span></span><br><span class="line"><span class="comment">        N /= k;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    mod.push_back(N); // 将最后的 N 也放入数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (N)</span><br><span class="line">    &#123; <span class="comment">// 更简洁的判断条件</span></span><br><span class="line">        mod.<span class="built_in">push_back</span>(N % k);</span><br><span class="line">        N /= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mod.<span class="built_in">size</span>() / <span class="number">2</span>; i++)</span><br><span class="line">    &#123; <span class="comment">// 判读获取的余数数组是不是回文数</span></span><br><span class="line">        <span class="keyword">if</span> (mod[i] != mod[mod.<span class="built_in">size</span>() - <span class="number">1</span> - i])</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = mod.<span class="built_in">end</span>() - <span class="number">1</span>; i != mod.<span class="built_in">begin</span>(); i--)</span><br><span class="line">    &#123; <span class="comment">// 反向输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *mod.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1027"><a class="markdownIt-Anchor" href="#1027"></a> 1027</h4>
<p><strong>题目：Colors in Mars</strong></p>
<p>People in Mars represent the colors in their computers in a similar way as the Earth people. That is, a color is represented by a 6-digit number, where the first 2 digits are for <code>Red</code> , the middle 2 digits for <code>Green</code> , and the last 2 digits for <code>Blue</code> . The only difference is that they use radix 13 (0-9 and A-C) instead of 16. Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case which occupies a line containing the three decimal color values.</p>
<p><em>Output Specification:</em></p>
<p>For each test case you should output the Mars RGB value in the following format: first output <code>#</code> , then followed by a 6-digit number where all the English characters must be upper-cased. If a single color is only 1-digit long, you must print a <code>0</code> to its left.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>15 43 71</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>#123456</p>
</blockquote>
<p><strong>思路：</strong> 十三进制的数字包括 ABC，可以放到字符数组中，用下标的方式进行输出</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t1, t2, t3; </span><br><span class="line">    <span class="type">char</span> c[<span class="number">14</span>] = &#123;<span class="string">&quot;0123456789ABC&quot;</span>&#125;; </span><br><span class="line">    cin &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; t3; </span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;#&#x27;</span>; </span><br><span class="line">    cout &lt;&lt; c[t1 / <span class="number">13</span>] &lt;&lt; c[t1 % <span class="number">13</span>]; </span><br><span class="line">    cout &lt;&lt; c[t2 / <span class="number">13</span>] &lt;&lt; c[t2 % <span class="number">13</span>]; </span><br><span class="line">    cout &lt;&lt; c[t3 / <span class="number">13</span>] &lt;&lt; c[t3 % <span class="number">13</span>]; </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1058"><a class="markdownIt-Anchor" href="#1058"></a> 1058</h4>
<p><strong>题目：A+B in Hogwarts</strong></p>
<p>If you are a fan of Harry Potter, you would know the world of magic has its own currency system – as Hagrid explained it to Harry, “Seventeen silver Sickles to a Galleon and twenty-nine Knuts to a Sickle, it’s easy enough.” Your job is to write a program to compute A+B where A and B are given in the standard form of <code>Galleon.Sickle.Knut</code> (<code>Galleon</code> is an integer in [0,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>], <code>Sickle</code> is an integer in [0,17), and <code>Knut</code> is an integer in [0, 29)).</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case which occupies a line with A and B in the standard form, separated by one space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case you should output the sum of A and B in one line, with the same format as the input.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>3.2.1 10.16.27</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>14.1.28</p>
</blockquote>
<p><strong>思路：</strong> 处理读取后，按位相加，小位留余</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1, b1, c1, a2, b2, c2, a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d.%d.%d %d.%d.%d&quot;</span>, &amp;a1, &amp;b1, &amp;c1, &amp;a2, &amp;b2, &amp;c2);</span><br><span class="line">    c = c1 + c2; <span class="comment">// 由小位到大位，按位相加，小位留余</span></span><br><span class="line">    b = b1 + b2 + c / <span class="number">29</span>;</span><br><span class="line">    c = c % <span class="number">29</span>;</span><br><span class="line">    a = a1 + a2 + b / <span class="number">17</span>;</span><br><span class="line">    b = b % <span class="number">17</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d.%d.%d&quot;</span>, a, b, c);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int yuan, jiao, fen;</span></span><br><span class="line"><span class="comment">    scanf(&quot;%d.%d.%d&quot;, &amp;yuan, &amp;jiao, &amp;fen);</span></span><br><span class="line"><span class="comment">    int t_y, t_j, t_f;</span></span><br><span class="line"><span class="comment">    scanf(&quot;%d.%d.%d&quot;, &amp;t_y, &amp;t_j, &amp;t_f);</span></span><br><span class="line"><span class="comment">    yuan += t_y;</span></span><br><span class="line"><span class="comment">    jiao += t_j;</span></span><br><span class="line"><span class="comment">    fen += t_f;</span></span><br><span class="line"><span class="comment">    if (!(fen &lt; 29))</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        jiao++;</span></span><br><span class="line"><span class="comment">        fen -= 29;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if (!(jiao &lt; 17))</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        yuan++;</span></span><br><span class="line"><span class="comment">        jiao -= 17;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    printf(&quot;%d.%d.%d&quot;, yuan, jiao, fen);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串处理"><a class="markdownIt-Anchor" href="# 字符串处理"></a> 字符串处理</h2>
<h3 id="思想解释 -6"><a class="markdownIt-Anchor" href="# 思想解释 -6"></a> 思想解释</h3>
<p>注意细节和输出格式，字符可以直接进行加减，输出需要补零可以用 <code>%02d</code></p>
<p>字符数组表示数字时使用 <code>-'0'</code> （如果时字母使用 <code>-'A'</code> ) 的方式，含义是使用 ASCII 码求差值</p>
<h3 id="类型练习 -6"><a class="markdownIt-Anchor" href="# 类型练习 -6"></a> 类型练习</h3>
<h4 id="1061"><a class="markdownIt-Anchor" href="#1061"></a> 1061</h4>
<p><strong>题目：Dating</strong></p>
<p>Sherlock Holmes received a note with some strange strings: <code>Let's date! 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm</code> . It took him only a minute to figure out that those strange strings are actually referring to the coded time <code>Thursday 14:04</code> – since the first common capital English letter (case sensitive) shared by the first two strings is the 4th capital letter <code>D</code> , representing the 4th day in a week; the second common character is the 5th capital letter <code>E</code> , representing the 14th hour (hence the hours from 0 to 23 in a day are represented by the numbers from 0 to 9 and the capital letters from <code>A</code> to <code>N</code> , respectively); and the English letter shared by the last two strings is <code>s</code> at the 4th position, representing the 4th minute. Now given two pairs of strings, you are supposed to help Sherlock decode the dating time.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case gives 4 non-empty strings of no more than 60 characters without white space in 4 lines.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print the decoded time in one line, in the format <code>DAY HH: MM</code> , where <code>DAY</code> is a 3-character abbreviation for the days in a week – that is, <code>MON</code> for Monday, <code>TUE</code> for Tuesday, <code>WED</code> for Wednesday, <code>THU</code> for Thursday, <code>FRI</code> for Friday, <code>SAT</code> for Saturday, and <code>SUN</code> for Sunday. It is guaranteed that the result is unique for each case.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>3485djDkxh4hhGE<br />
2984akDfkkkkggEdsb<br />
s&amp;hgsfdk<br />
d&amp;Hyscvnm</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>THU 14:04</p>
</blockquote>
<p><strong>思路：</strong> 按照题目所给的方法找到相等的字符后判断即可，如果输出的时间不足 2 位数要在前面添 0，即用 <code>%02d</code> 输出</p>
<ul>
<li>
<p>因为在一对字符串的同一位置出现的相同字符才符合条件，使用一个外部循环条件，减少循环次数，方便操作</p>
</li>
<li>
<p>符合条件的同时还需判断是否符合逻辑条件，如：星期的字母不会超过 G、小时可以是 N 之前的字母也可以是数字</p>
</li>
<li>
<p>对星期的输出可以把每一日的代表字符串放到数组中，通过当前字符减去 A 的值作为下标</p>
</li>
<li>
<p>小时需要根据数字还是字母的类型进行不同的操作，如果是字母减去 A 后还应 +10</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string a, b, c, d; </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; <span class="comment">// 输入字符串</span></span><br><span class="line">    <span class="type">char</span> time[<span class="number">2</span>]; <span class="comment">// 记录星期和小时</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">// 控制字符串遍历，减少循环次数</span></span><br><span class="line">    <span class="type">int</span> m; <span class="comment">// 记录分钟</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; a.<span class="built_in">length</span>() &amp;&amp; i &lt; a.<span class="built_in">length</span>()) <span class="comment">// 同时出现才算符合条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[i] &amp;&amp; (a[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; a[i] &lt;= <span class="string">&#x27;G&#x27;</span>)) <span class="comment">// 星期字母不会超过 G</span></span><br><span class="line">        &#123;</span><br><span class="line">            time[<span class="number">0</span>] = a[i]; </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 保留字符，跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++; </span><br><span class="line">    &#125;</span><br><span class="line">    i++; </span><br><span class="line">    <span class="keyword">while</span> (i &lt; a.<span class="built_in">length</span>() &amp;&amp; i &lt; a.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[i] &amp;&amp; ((a[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; a[i] &lt;= <span class="string">&#x27;N&#x27;</span>) || <span class="built_in">isdigit</span>(a[i]))) <span class="comment">// 数字或者 N 之前的字符</span></span><br><span class="line">        &#123;</span><br><span class="line">            time[<span class="number">1</span>] = a[i]; </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 保留并跳出</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; c.<span class="built_in">length</span>() &amp;&amp; j &lt; d.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c[j] == d[j] &amp;&amp; <span class="built_in">isalpha</span>(c[j])) <span class="comment">// 分钟必须时字母</span></span><br><span class="line">        &#123;</span><br><span class="line">            m = j; <span class="comment">// 只需保存位置</span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        j++; </span><br><span class="line">    &#125;</span><br><span class="line">    string week[<span class="number">7</span>] = &#123;<span class="string">&quot;MON &quot;</span>, <span class="string">&quot;TUE &quot;</span>, <span class="string">&quot;WED &quot;</span>, <span class="string">&quot;THU &quot;</span>, <span class="string">&quot;FRI &quot;</span>, <span class="string">&quot;SAT &quot;</span>, <span class="string">&quot;SUN &quot;</span>&#125;; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, week[time[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>].<span class="built_in">c_str</span>()); <span class="comment">// 注意输出格式，转换为只读指针</span></span><br><span class="line">    <span class="type">int</span> h = <span class="built_in">isdigit</span>(time[<span class="number">1</span>]) ? time[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> : time[<span class="number">1</span>] - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>; <span class="comment">//0 也是字符型必须有单引号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d&quot;</span>, h, m); <span class="comment">// 输出两位不足补零</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1073"><a class="markdownIt-Anchor" href="#1073"></a> 1073</h4>
<p><strong>题目：Scientific Notation</strong></p>
<p>Scientific notation is the way that scientists easily handle very large numbers or very small numbers. The notation matches the regular expression [±][1-9]<code>.</code>[0-9]+E[±][0-9]+ which means that the integer portion has exactly one digit, there is at least one digit in the fractional portion, and the number and its exponent’s signs are always provided even when they are positive.</p>
<p>Now given a real number A in scientific notation, you are supposed to print A in the conventional notation while keeping all the significant figures.</p>
<p><em>Input Specification:</em></p>
<p>Each input contains one test case. For each case, there is one line containing the real number A in scientific notation. The number is no more than 9999 bytes in length and the exponent’s absolute value is no more than 9999.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in one line the input number A in the conventional notation, with all the significant figures kept, including trailing zeros.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>+1.23400E-03</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>0.00123400</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>-1.2E+10</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>-12000000000</p>
</blockquote>
<p><strong>思路：</strong> 将底数和指数分别作为字符串和整数进行保存，然后根据符号和指数位分情况判断</p>
<ul>
<li>
<p>先判断字符串的第一位是否为符号，如果是转换数必然是负数，先输出一个负号</p>
</li>
<li>
<p>如果指数为负数，那么转换数是小数，直接输出<code>&quot;0.&quot;</code>，然后输出指数 -1 个 0，再将底数子串去小数点输出</p>
</li>
<li>
<p>指数为正数，转换数是一个整数，先输出底数子串的第一位，略过小数点，同时判断输出越界和是否超过指数的大小</p>
</li>
<li>
<p>如果子串已经全部输出，将指数的剩余大小补 0</p>
</li>
<li>
<p>指数到达子串未全部输出，输出小数点后继续输出子串</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[index] != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    string f_str = str.<span class="built_in">substr</span>(<span class="number">1</span>, index - <span class="number">1</span>); <span class="comment">// 从 &#x27;E&#x27; 进行分割，将指数前的字符去掉符号放到字符子串中</span></span><br><span class="line">    <span class="type">int</span> e = <span class="built_in">stoi</span>(str.<span class="built_in">substr</span>(index + <span class="number">1</span>));     <span class="comment">// 正负号也会进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)                       <span class="comment">// 如果是一个负数，直接输出符号</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e &lt; <span class="number">0</span>) <span class="comment">// 如果指数是负数，说明结果是一个小数</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0.&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">abs</span>(e) - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; f_str.<span class="built_in">length</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (f_str[j] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; f_str[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果是正数</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; f_str[<span class="number">0</span>]; <span class="comment">// 先输出小数点之前的一位</span></span><br><span class="line">        <span class="type">int</span> j, cnt;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span>, cnt = <span class="number">0</span>; j &lt; f_str.<span class="built_in">length</span>() &amp;&amp; cnt &lt; e; j++, cnt++)</span><br><span class="line">        &#123; <span class="comment">// 略过小数点输出，同时判断长度并构造一个计数不超过指数</span></span><br><span class="line">            cout &lt;&lt; f_str[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == f_str.<span class="built_in">length</span>()) <span class="comment">// 如果字符串全部输出，说明未到指数，后面补零</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; e - cnt; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 指数到了指数未到，输出一个小数点继续输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (j; j &lt; f_str.<span class="built_in">length</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; f_str[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1001"><a class="markdownIt-Anchor" href="#1001"></a> 1001</h4>
<p><strong>题目：A+B Format</strong></p>
<p>Calculate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> and output the sum in standard format ——that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case contains a pair of integers a and b where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>−</mtext><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mo>≤</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">−10^6≤a, b≤10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>. The numbers are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>-1000000  9</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>-999, 991</p>
</blockquote>
<p><strong>思路：</strong> 将和值转换为字符串，通过下标判断逗号的输出</p>
<ul>
<li>
<p>判断条件可以从右往左看，当三位时输出一个逗号，也就是字符串的长度 mod3 的位置，在从左往右看，下标 i 从 0 开始，如果 <code>(i + 1) % 3 == len % 3 </code>成立就输出逗号，注意最后一位不输出</p>
</li>
<li>
<p>第一位输出的可能是一个负号，如果是负号就直接 continue 进入下一次循环，无需判断</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a, b; </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; </span><br><span class="line">    string str = <span class="built_in">to_string</span>(a + b); </span><br><span class="line">    <span class="type">int</span> len = str.<span class="built_in">length</span>(); </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; str[i]; </span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 直接进入下一次循环，防止负号后出现 comma 的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">3</span> == len % <span class="number">3</span> &amp;&amp; i + <span class="number">1</span> != len)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;, &#x27;</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1004"><a class="markdownIt-Anchor" href="#1004"></a> 1004</h4>
<p><strong>题目：Spell It Right</strong></p>
<p>Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case occupies one line which contains an N (≤10100).</p>
<p><em>Output Specification:</em></p>
<p>For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>12345</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>one five</p>
</blockquote>
<p><strong>思路：</strong> 使用字符串输入，利用每个字符数组 <code>-'0'</code> 的方式求和，将 sum 转为字符数组，用其实际数字作下标输出英文数字的字符串数组</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += a[i] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">// 将每一位相加（不 -0 计算的是数字存储的 ASCII 码）</span></span><br><span class="line">    &#125;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(sum);</span><br><span class="line">    string digit[<span class="number">10</span>] = &#123;<span class="string">&quot;zero&quot;</span>, <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;six&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;eight&quot;</span>, <span class="string">&quot;nine&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 将每个数字的读法放到数组中</span></span><br><span class="line">    cout &lt;&lt; digit[s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; digit[s[i] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1035"><a class="markdownIt-Anchor" href="#1035"></a> 1035</h4>
<p><strong>题目：Password</strong></p>
<p>To prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguish <code>1</code> (one) from <code>l</code> (<code>L</code> in lowercase), or <code>0</code> (zero) from <code>O</code> (<code>o</code> in uppercase). One solution is to replace <code>1</code> (one) by <code>@</code> , <code>0</code> (zero) by <code>%</code> , <code>l</code> by <code>L</code> , and <code>O</code> by <code>o</code> . Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case contains a positive integer N (≤1000), followed by N lines of accounts. Each account consists of a user name and a password, both are strings of no more than 10 characters with no space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, first print the number M of accounts that have been modified, then print in the following M lines the modified accounts info, that is, the user names and the corresponding modified passwords. The accounts must be printed in the same order as they are read in. If no account is modified, print in one line <code>There are N accounts and no account is modified</code> where <code>N</code> is the total number of accounts. However, if <code>N</code> is one, you must print <code>There is 1 account and no account is modified</code> instead.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>3<br />
Team000002 Rlsp0dfa<br />
Team000003 perfectpwd<br />
Team000001 R1spOdfa</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>2<br />
Team000002 RLsp%dfa<br />
Team000001 R@spodfa</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>1<br />
team110 abcdefg332</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>There is 1 account and no account is modified</p>
</blockquote>
<p><em>Sample Input 3:</em></p>
<blockquote>
<p>2<br />
team110 abcdefg222<br />
team220 abcdefg333</p>
</blockquote>
<p><em>Sample Output 3:</em></p>
<blockquote>
<p>There are 2 accounts and no account is modified</p>
</blockquote>
<p><strong>思路：</strong> 循环进行判断，将符合条件的字符串放入字符数组，判断完分情况输出</p>
<ul>
<li>
<p>输入密码后循环判断每一个字符（<code>switch()</code>或<code>if()</code>），更改即可；同时设置一个变量进行判断是否被修改</p>
</li>
<li>
<p>若修改放入动态数组，最后根据数组大小和 N 的值输出相应结果</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n; </span><br><span class="line">    cin &gt;&gt; n; </span><br><span class="line">    vector&lt;string&gt; list; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 建立人数循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        string name, password; </span><br><span class="line">        cin &gt;&gt; name &gt;&gt; password; </span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; password.<span class="built_in">length</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (password[j]) <span class="comment">// 依次更换符合要求的值</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                password[j] = <span class="string">&#x27;@&#x27;</span>; </span><br><span class="line">                flag = <span class="number">1</span>; </span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 这里的 break 不是跳出循环，而是不执行后面的判断</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                password[j] = <span class="string">&#x27;%&#x27;</span>; </span><br><span class="line">                flag = <span class="number">1</span>; </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">                password[j] = <span class="string">&#x27;L&#x27;</span>; </span><br><span class="line">                flag = <span class="number">1</span>; </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                password[j] = <span class="string">&#x27;o&#x27;</span>; </span><br><span class="line">                flag = <span class="number">1</span>; </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="comment">// 被更改则放入数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            string temp = name + <span class="string">&quot; &quot;</span> + password; </span><br><span class="line">            list.<span class="built_in">push_back</span>(temp); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list.<span class="built_in">size</span>()) <span class="comment">// 数组中有元素就输出被更改的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; list.<span class="built_in">size</span>() &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); i++)</span><br><span class="line">            cout &lt;&lt; list[i] &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;There is 1 account and no account is modified&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;There are %d accounts and no account is modified&quot;</span>, n); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1077"><a class="markdownIt-Anchor" href="#1077"></a> 1077</h4>
<p><strong>题目：Kuchiguse</strong></p>
<p>The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker’s personality. Such a preference is called “Kuchiguse” and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle “nyan~” is often used as a stereotype for characters with a cat-like personality:</p>
<ul>
<li>
<p>Itai nyan~ (It hurts, nyan~)</p>
</li>
<li>
<p>Ninjin wa iyada nyan~ (I hate carrots, nyan~)</p>
</li>
</ul>
<p>Now given a few lines spoken by the same character, can you find her Kuchiguse?</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line is an integer N (2≤N≤100). Following are N file lines of 0~256 (inclusive) characters in length, each representing a character’s spoken line. The spoken lines are case sensitive.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all N lines. If there is no such suffix, write <code>nai</code>.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>3<br />
Itai nyan~<br />
Ninjin wa iyadanyan~<br />
uhhh nyan~</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>nyan~</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>3<br />
Itai!<br />
Ninjinnwaiyada T_T<br />
T_T</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>nai</p>
</blockquote>
<p><strong>思路：</strong> 每输入一个字符串，就把它逆序过来再比较</p>
<ul>
<li>
<p>首先 ans = s；后来每输入的一个字符串，都和 ans 比较，如果后面不相同的就把它截取掉，根据 ans 的长度判断输出</p>
</li>
<li>
<p>输入数字后再获取整行字符时会直接获取数字后的换行符，可以使用 <code>getchar()</code> 截取，或使用 <code>scanf(&quot;%d``\n``&quot;, &amp;n);</code> 输入数字</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  [algorithm] </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">getchar</span>(); <span class="comment">// 截获、n，不然下面读取字符串时第一个读取的是换行符</span></span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="built_in">getline</span>(cin, s);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()); <span class="comment">// 反转后方便判断</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = s;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">length</span>() &lt; ans.<span class="built_in">length</span>()) <span class="comment">// 判断最短的</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(ans, s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> minlen = <span class="built_in">min</span>(s.<span class="built_in">length</span>(), ans.<span class="built_in">length</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; minlen; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[j] != s[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = ans.<span class="built_in">substr</span>(<span class="number">0</span>, j); <span class="comment">// 将公共子串截取出来</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>()); <span class="comment">// 再翻转回初始状态</span></span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">length</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="string">&quot;nai&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1082"><a class="markdownIt-Anchor" href="#1082"></a> 1082</h4>
<p><strong>题目：Read Number in Chinese</strong></p>
<p>Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output <code>Fu</code> first if it is negative. For example, -123456789 is read as <code>Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu</code> . Note: zero (<code>ling</code> ) must be handled correctly according to the Chinese tradition. For example, 100800 is <code>yi Shi Wan ling ba Bai</code> .</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case, which gives an integer with no more than 9 digits.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>-123456789</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>100800</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>yi Shi Wan ling ba Bai</p>
</blockquote>
<p><strong>思路：</strong> 同时设置 left 和 right 两个坐标，按四位一节进行输出</p>
<ul>
<li>先构建数字单词和位数单词数组，用下标控制读出来</li>
<li>使用两个下标，确保间隔不超过四，始终指向同一小节</li>
<li>循环嵌套，每次输出一个小节，同时注意单个小节的内位数（千、百、十）；每输出一小节判断其的外位数（万、亿）</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string num[<span class="number">10</span>] = &#123;<span class="string">&quot;ling&quot;</span>, <span class="string">&quot;yi&quot;</span>, <span class="string">&quot;er&quot;</span>, <span class="string">&quot;san&quot;</span>, <span class="string">&quot;si&quot;</span>, <span class="string">&quot;wu&quot;</span>, <span class="string">&quot;liu&quot;</span>, <span class="string">&quot;qi&quot;</span>, <span class="string">&quot;ba&quot;</span>, <span class="string">&quot;jiu&quot;</span>&#125;; <span class="comment">// 数字单词</span></span><br><span class="line">    string wei[<span class="number">5</span>] = &#123;<span class="string">&quot;Shi&quot;</span>, <span class="string">&quot;Bai&quot;</span>, <span class="string">&quot;Qian&quot;</span>, <span class="string">&quot;Wan&quot;</span>, <span class="string">&quot;Yi&quot;</span>&#125;; <span class="comment">// 位数单词</span></span><br><span class="line">    string str; </span><br><span class="line">    cin &gt;&gt; str; <span class="comment">// 输入字符串</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = str.<span class="built_in">length</span>() - <span class="number">1</span>; <span class="comment">// 设置左右下标，四位一组输出</span></span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Fu&quot;</span>; <span class="comment">// 符号单独处理</span></span><br><span class="line">        left++; <span class="comment">// 从下标 1 开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">4</span> &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        right -= <span class="number">4</span>; <span class="comment">// 始终让 left 和 right 在同一节</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; str.<span class="built_in">length</span>()) <span class="comment">// 没全部读出就始终循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> zero = <span class="literal">false</span>; </span><br><span class="line">        <span class="type">bool</span> isPrint = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) <span class="comment">// 单节处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; <span class="number">0</span> &amp;&amp; str[left] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123; <span class="comment">// 标识零位</span></span><br><span class="line">                zero = <span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (zero) <span class="comment">// 先判断之前有无零位</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot; ling&quot;</span>; </span><br><span class="line">                    zero = <span class="literal">false</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (left &gt; <span class="number">0</span>) <span class="comment">// 只要不是第一个数组就必须用空格分割</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; num[str[left] - <span class="string">&#x27;0&#x27;</span>]; <span class="comment">// 输出数字</span></span><br><span class="line">                isPrint = <span class="literal">true</span>; <span class="comment">// 标志有输出，需要进行万或者亿的输出</span></span><br><span class="line">                <span class="keyword">if</span> (left != right)            <span class="comment">// 只要这一节没到最后一个字符就要输出千、百、十</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; wei[right - left - <span class="number">1</span>]; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++; <span class="comment">// 左下标后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isPrint &amp;&amp; right != str.<span class="built_in">length</span>() - <span class="number">1</span>) <span class="comment">// 有输出而且不是最后一节</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; wei[(str.<span class="built_in">length</span>() - right) / <span class="number">4</span> + <span class="number">2</span>]; <span class="comment">// 输出万或者亿</span></span><br><span class="line">        &#125;</span><br><span class="line">        right += <span class="number">4</span>; <span class="comment">// 右坐标移动到下一节</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1040"><a class="markdownIt-Anchor" href="#1040"></a> 1040</h4>
<p><strong>题目：Longest Symmetric String</strong></p>
<p>Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given <code>Is PAT&amp;TAP symmetric?</code>, the longest symmetric sub-string is <code>s PAT&amp;TAP s</code>, hence you must output <code>11</code>.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case which gives a non-empty string of length no more than 1000.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, simply print the maximum length in a line.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>Is PAT&amp;TAP symmetric?</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>11</p>
</blockquote>
<p><strong>思路：</strong> 使用每个字符或者两个字符中的空格作为对称轴进行双向遍历，更新最大长度即可</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    <span class="type">int</span> maxlen = <span class="number">0</span>, j, k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) <span class="comment">// 以字符做对称轴</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i, k = i; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; str.<span class="built_in">size</span>() &amp;&amp; str[j] == str[k]; j--, k++)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (k - j - <span class="number">1</span> &gt; maxlen)</span><br><span class="line">        &#123;</span><br><span class="line">            maxlen = k - j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>() - <span class="number">1</span>; i++) <span class="comment">// 字符中间做对称轴</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i, k = i + <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; str.<span class="built_in">size</span>() &amp;&amp; str[j] == str[k]; j--, k++)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (k - j - <span class="number">1</span> &gt; maxlen)</span><br><span class="line">        &#123;</span><br><span class="line">            maxlen = k - j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxlen;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="# 总结"></a> 总结</h2>
<ol>
<li>模拟类的题就是根据要求写代码即可，主要考察思路而不是算法，代码尽量简洁，善用数组和头文件</li>
<li>使用函数赋值变量时注意其返回值，指针和迭代器要进行取值</li>
<li>根据输入的第一个 N 创建循环，输入的数据尽量使用临时变量在循环中处理即可，减少时间复杂度</li>
<li>根据题意总结公式，输出的格式几乎都可以使用下标找到规律</li>
<li>字符串的处理要多变，如：翻转后方便处理，输出多个时直接相加</li>
<li>输入一个数字后紧跟 <code>getline()</code>进行字符串的输出，会接受到数字后的换行符，可在中间加一个 <code>getchar()</code>进行换行符的截获或者是使用 <code>scanf(&quot;%d\n&quot;,&amp;n);</code> 的方式输入数字</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 刷题实用方法总结</title>
    <url>/summarize-c_plus_utility/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p>准备 PAT 竞赛时自己总结的实用函数，搞过 OJ 的应该都有一套自己总结的算法秘籍（小抄），这种东西主观性比较强，自己搞的才看的懂，发出来做个记录吧</p>
<span id="more"></span>
<h2 id="cmath 头文件"><a class="markdownIt-Anchor" href="#cmath 头文件"></a> cmath 头文件</h2>
<p>其针对的参数大多为 double，所有进行整型判断的时候需要进行转换：(double)int；</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>方法</strong></th>
<th style="text-align:center"><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">fabs()</td>
<td style="text-align:center">绝对值</td>
</tr>
<tr>
<td style="text-align:center">floor()、ceil()</td>
<td style="text-align:center">向下、向上取整</td>
</tr>
<tr>
<td style="text-align:center">pow(r, p)</td>
<td style="text-align:center">幂值： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">r^p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">sqrt()</td>
<td style="text-align:center">开根</td>
</tr>
<tr>
<td style="text-align:center">round()</td>
<td style="text-align:center">四舍五入取整</td>
</tr>
<tr>
<td style="text-align:center">log()</td>
<td style="text-align:center">以 e 为底的对数</td>
</tr>
</tbody>
</table>
<p>并没有以任意数为底的求对数函数，但可以采用换底公式： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>a</mi></msub><mi>b</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>e</mi></msub><mi>b</mi><mi mathvariant="normal">/</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>e</mi></msub><mi>a</mi></mrow><annotation encoding="application/x-tex">log_ab=log_eb/log_ea</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">a</span></span></span></span></p>
<h2 id="climits 头文件"><a class="markdownIt-Anchor" href="#climits 头文件"></a> climits 头文件</h2>
<p>最常使用的是对最大最小值的赋予： <code>INT_MAX/MIN</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> max = INT_MIN, min = INT_MAX; <span class="comment">// 最大值初始要足够小，最小值要足够大</span></span><br><span class="line">cout &lt;&lt; max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; min &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="bitset 头文件"><a class="markdownIt-Anchor" href="#bitset 头文件"></a> bitset 头文件</h2>
<h3 id="二进制操作"><a class="markdownIt-Anchor" href="# 二进制操作"></a> 二进制操作</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">bitset&lt;5&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;11&quot;</span>)</span></span>; <span class="comment">//5 表示 5 个⼆进位 </span></span><br><span class="line"><span class="comment">// 初始化⽅式：</span></span><br><span class="line"><span class="comment">// bitset&lt;5&gt; b; 都为 0</span></span><br><span class="line"><span class="comment">// bitset&lt;5&gt; b(u); u 为 unsigned int，如果 u = 1, 则被初始化为 10000</span></span><br><span class="line"><span class="comment">// bitset&lt;5&gt; b(s); s 为字符串，如 &quot;1101&quot; -&gt; &quot;10110&quot;</span></span><br><span class="line"><span class="comment">// bitset&lt;5&gt; b(s, pos, n); 从字符串的 s[pos] 开始，n 位⻓度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    cout &lt;&lt; b[i];</span><br><span class="line">cout &lt;&lt; endl</span><br><span class="line">     &lt;&lt; b.<span class="built_in">any</span>(); <span class="comment">//b 中是否存在 1 的⼆进制位</span></span><br><span class="line">cout &lt;&lt; endl</span><br><span class="line">     &lt;&lt; b.<span class="built_in">none</span>(); <span class="comment">//b 中不存在 1 吗？</span></span><br><span class="line">cout &lt;&lt; endl</span><br><span class="line">     &lt;&lt; b.<span class="built_in">count</span>(); <span class="comment">//b 中 1 的⼆进制位的个数</span></span><br><span class="line">cout &lt;&lt; endl</span><br><span class="line">     &lt;&lt; b.<span class="built_in">size</span>(); <span class="comment">//b 中⼆进制位的个数</span></span><br><span class="line">cout &lt;&lt; endl</span><br><span class="line">     &lt;&lt; b.<span class="built_in">test</span>(<span class="number">2</span>);              <span class="comment">// 测试下标为 2 处是否⼆进制位为 1</span></span><br><span class="line">b.<span class="built_in">set</span>(<span class="number">4</span>);                       <span class="comment">// 把 b 的下标为 4 处置 1</span></span><br><span class="line">b.<span class="built_in">reset</span>();                      <span class="comment">// 所有位归零</span></span><br><span class="line">b.<span class="built_in">reset</span>(<span class="number">3</span>);                     <span class="comment">//b 的下标 3 处归零</span></span><br><span class="line">b.<span class="built_in">flip</span>();                       <span class="comment">//b 的所有⼆进制位逐位取反</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> a = b.<span class="built_in">to_ulong</span>(); <span class="comment">//b 转换为 unsigned long 类型</span></span><br></pre></td></tr></table></figure>
<h3 id="进制转换函数"><a class="markdownIt-Anchor" href="# 进制转换函数"></a> 进制转换函数</h3>
<h4 id="手动写法"><a class="markdownIt-Anchor" href="# 手动写法"></a> 手动写法</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>, arr[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    arr[len++] = n % radix;</span><br><span class="line">    n = n / radix;</span><br><span class="line">&#125; <span class="keyword">while</span> (n != <span class="number">0</span>); <span class="comment">// 十进制转为其他进制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">    n = n * radix + arr[i];</span><br><span class="line">&#125; <span class="comment">// 其他进制转为十进制</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="输出格式"><a class="markdownIt-Anchor" href="# 输出格式"></a> <strong>输出格式</strong></h4>
<p>在使用 <bitset> 头文件时可以根据输出关键字进行进制的转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;35 的 8 进制:&quot;</span> &lt;&lt; oct &lt;&lt; <span class="number">35</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;35 的 10 进制 &quot;</span> &lt;&lt; dec &lt;&lt; <span class="number">35</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;35 的 16 进制:&quot;</span> &lt;&lt; hex &lt;&lt; <span class="number">35</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;35 的 2 进制: &quot;</span> &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">8</span>&gt;(<span class="number">35</span>) &lt;&lt; endl; <span class="comment">//&lt;8&gt;：表示保留 8 位输出</span></span><br></pre></td></tr></table></figure>
<h4 id="strtol 函数"><a class="markdownIt-Anchor" href="#strtol 函数"></a> <strong>strtol()函数</strong></h4>
<p><strong>任意进制转换为十进制(str→long int)</strong>，其格式为： <code>long int strtol(const char *nptr, char **endptr, int base)</code> ，base 是要转化的数的进制，非法字符会赋值给 endptr，nptr 是要转化的字符<br />
因为是 C 语言自带的函数，所以字符串只能用 char 数组的方式读入（也可以字符串读入然后转换成字符数组）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">char</span> a[<span class="number">20</span>]=<span class="string">&quot;10549stend#12&quot;</span>;  </span><br><span class="line"><span class="type">char</span> *stop;  <span class="comment">// 建立一个由 stop 指向的字符数组</span></span><br><span class="line"><span class="type">int</span> ans=<span class="built_in">strtol</span>(a, &amp;stop, <span class="number">8</span>);   <span class="comment">// 将八进制数 1054 转成十进制，后面均为非法字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, stop);   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="itoa 函数"><a class="markdownIt-Anchor" href="#itoa 函数"></a> itoa()函数</h4>
<p><strong>十进制转换为任意进制(int→str)</strong>，其格式为： <code>char</code><em><code>itoa(int value,char</code></em><code>string,int radix);</code>，radix 是要转化的数的进制<br />
因为是 C 语言自带的函数，所以字符串只能用 char 数组的方式读入（也可以字符串读入然后转换成字符数组）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;  </span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];  </span><br><span class="line">_itoa(num, str, <span class="number">2</span>);  <span class="comment">//c++ 中一般用_itoa，用 itoa 也行,</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br></pre></td></tr></table></figure>
<h4 id="sprintf 函数"><a class="markdownIt-Anchor" href="#sprintf 函数"></a> sprintf()函数</h4>
<p><strong>也是将一个 10 进制数转换为指定格式的 n 进制字符串</strong>，函数原型： <code>int sprintf(char *buffer, const char *format, [ argument] … )</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%d&quot;</span>, <span class="number">123</span>); <span class="comment">// 十进制输出产生 &quot;123&quot;</span></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%4d%4d&quot;</span>, <span class="number">123</span>, <span class="number">4567</span>); <span class="comment">// 指定宽度不足的左边补空格，产生：&quot; 1234567&quot;</span></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%8o&quot;</span>, <span class="number">123</span>);    <span class="comment">// 八进制输出，宽度占 8 个位置</span></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%8x&quot;</span>, <span class="number">4567</span>); <span class="comment">// 小写 16 进制，宽度占 8 个位置，右对齐</span></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%10.3f&quot;</span>, <span class="number">3.1415626</span>); <span class="comment">// 产生：&quot; 3.142&quot;</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%.2f&quot;</span>, i);    <span class="comment">// 注意这是不对的</span></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%.2f&quot;</span>, (<span class="type">double</span>)i);    <span class="comment">// 要按照这种方式才行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="cstring 头文件"><a class="markdownIt-Anchor" href="#cstring 头文件"></a> cstring 头文件</h2>
<h3 id="函数初始化数组"><a class="markdownIt-Anchor" href="# 函数初始化数组"></a> 函数初始化数组</h3>
<p>给数组初始化时，可以使用 memset()函数进行填充，而不用 for 循环遍历，其格式为： <code>memset(数组名, 初始值,sizeof(数组名)); </code>其在头文件 <cstring> 中，只用 memset()函数为数组赋 0 或 -1 时使用<br />
也可对二维数组和多维数组进行初始操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串转换数组"><a class="markdownIt-Anchor" href="# 字符串转换数组"></a> <strong>字符串转换数组</strong></h3>
<p>字符串转换为字符数组需要使用 <cstring> 中的 strncpy 方法将字符串内容挨个拷贝进数组中</p>
<p>字符数组转换为字符串可以直接进行赋值转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string s = <span class="string">&quot;aaaa vvva&quot;</span>;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">strncpy</span>(a, s.<span class="built_in">c_str</span>(), s.<span class="built_in">length</span>()); <span class="comment">// 使用 &lt;cstring&gt; 中的方法将字符串拷贝到数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        cout &lt;&lt; a[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> arr[] = <span class="string">&quot;123 45sdf&quot;</span>;</span><br><span class="line">    string str = arr; <span class="comment">// 直接将数组名赋值给字符串</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="tostring 函数"><a class="markdownIt-Anchor" href="#tostring 函数"></a> <strong>tostring 函数</strong></h3>
<p>在头文件 <string> 中，也可以不用<br />
作用是将其他类型的数据转换为 string 型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="built_in">to_string</span>(<span class="number">123</span>); <span class="comment">// 将 123 这个数字转成字符串</span></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">string s2 = <span class="built_in">to_string</span>(<span class="number">4.5</span>); <span class="comment">// 将 4.5 这个数字转成字符串</span></span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s1 + s2 &lt;&lt; endl;           <span class="comment">// 将 s1 和 s2 两个字符串拼接起来并输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (s1 + s2).<span class="built_in">c_str</span>()); <span class="comment">// 如果想⽤printf 输出 string，得加⼀个.c_str()</span></span><br></pre></td></tr></table></figure>
<p>string 转换成 int，double 可以使用 stoi 和 stod 方法，其含义为 string to int，其他数据类型也适用只要将最后一个字母写成目标类型的首字母</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">string str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">stoi</span>(str); <span class="comment">// 非法字符会自动去除</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">str = <span class="string">&quot;123.44&quot;</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="built_in">stod</span>(str);</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="algorithm 头文件"><a class="markdownIt-Anchor" href="#algorithm 头文件"></a> algorithm 头文件</h2>
<h3 id="数学函数"><a class="markdownIt-Anchor" href="# 数学函数"></a> 数学函数</h3>
<p>max(x,y)、min(x,y)函数用来返回两个数（可以是浮点）中较大或较小的那个，如果是判断三个数的最大值可以写成： <code>max(a,max(b,c))</code></p>
<p>abs()只能是整数，浮点数可以用 <cmath> 下的 fabs()</p>
<p>swap()用来交换两个数的值</p>
<h3 id="sort 函数"><a class="markdownIt-Anchor" href="#sort 函数"></a> <strong>sort 函数</strong></h3>
<p>sort 排序函数在头文件 <algorithm> 中，主要是对数组进行排序，格式为： <code>sort(数组头，数组尾，规则 cmp);</code></p>
<p>cmd 的排序规则的格式是返回一个大小判断的 bool 值，不能有 = 号，sort 是不稳定的排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">//cmp 规则的定义几乎都是这种格式</span></span></span><br><span class="line"><span class="function"></span>&#123;                      <span class="comment">// cmp 函数返回的值是 bool 类型</span></span><br><span class="line">    <span class="keyword">return</span> a &gt; b;      <span class="comment">// 从大到小排列，不能有“=”号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">// 因为这⾥没有传⼊参数 cmp，所以按照默认，v 从小到大排列</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + <span class="number">10</span>, cmp); <span class="comment">// arr 从⼤到小排列，因为 cmp 函数排序规则设置从大到小</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="struct 的 sort"><a class="markdownIt-Anchor" href="#struct 的 sort"></a> <strong>struct 的 sort</strong></h4>
<p>结构体中可能会对多个变量进行比对，这就需要进行自定义的 cmp 函数</p>
<p>有一个学生结构体，要对学生进行排序时按照如下方法：当成绩不同时按从大到小排列，若成绩相同，对相同者进行学号从小到大排列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span></span><br><span class="line">&#123; <span class="comment">// 定义⼀个结构体 stu，number 表示学号，score 表示分数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stu a, stu b)</span></span></span><br><span class="line"><span class="function"></span>&#123;                           <span class="comment">// cmp 函数，返回值是 bool，传⼊的参数类型应该是结构体 stu 类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.score != b.score) <span class="comment">// 如果学生分数不同，就按照分数从大到小排列</span></span><br><span class="line">        <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果学生分数相同，就按照学号从小到大排列</span></span><br><span class="line">        <span class="keyword">return</span> a.number &lt; b.number;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stu a, stu b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 写成三目运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.score != b.score ? a.score &gt; b.score : a.number &lt; b.number;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="cmp_char"><a class="markdownIt-Anchor" href="#cmp_char"></a> cmp_char[]</h4>
<p>字符数组的排序不能像字符串那样直接进行比较，需要使用 <cstring> 中的 strcmp()函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="built_in">strcmp</span>(a.name, b.name) &lt; <span class="number">0</span>); <span class="comment">// 递增</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">strcmp</span>(a.name, b.name) &gt; <span class="number">0</span>); <span class="comment">// 递减 </span></span><br></pre></td></tr></table></figure>
<h4 id="项式 cmp"><a class="markdownIt-Anchor" href="# 项式 cmp"></a> 项式 cmp</h4>
<p>PAT(advance)中的 T1038 中就要将字符串使用多项式相加的规则进行排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a + b &lt; b + a; <span class="comment">// 如果 a+b&lt;b+a，a 就在前面，否则反之</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="reverse 函数"><a class="markdownIt-Anchor" href="#reverse 函数"></a> <strong>reverse()函数</strong></h3>
<p><algorithm>中的反转函数，通过指针或迭代器用来反转相应范围内的数，应用于数组和字符串较多<br />
用来反转字符串非常方便</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr[<span class="number">8</span>] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(arr, arr + <span class="number">4</span>);</span><br><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin, str);</span><br><span class="line"><span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());<span class="comment">// 反转首尾</span></span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="next_pernumtation"><a class="markdownIt-Anchor" href="#next_pernumtation"></a> next_pernumtation()</h3>
<p>当前序列的下一个全排列，可配合 do…while()循环输出一个序列的全排列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">do</span> <span class="comment">// 先输出本身</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; endl; <span class="comment">// 只能使用单循环语句</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(arr, arr + <span class="number">3</span>));                     <span class="comment">// 输出最后一个序列后返回值为 false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="max_element 及 min_element 函数"><a class="markdownIt-Anchor" href="#max_element 及 min_element 函数"></a> <strong>max_element（）及 min_element（）函数</strong></h3>
<p><algorithm>中的求最大最小值的函数，可对普通数组和 vector 数组进行使用<br />
返回的是迭代器或指针，所以加上取值符 *，若求下标则用返回的结果减去数组的起始位置即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="type">int</span> maxValue = *<span class="built_in">max_element</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()); </span><br><span class="line"><span class="type">int</span> minValue = *<span class="built_in">min_element</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> maxPosition = <span class="built_in">max_element</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()) - v.<span class="built_in">begin</span>(); </span><br><span class="line"></span><br><span class="line">a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> maxValue = *<span class="built_in">max_element</span>(a,a+<span class="number">6</span>); </span><br><span class="line"><span class="type">int</span> minValue = *<span class="built_in">min_element</span>(a,a+<span class="number">6</span>); </span><br><span class="line"><span class="type">int</span> maxPosition = <span class="built_in">max_element</span>(a,a+<span class="number">6</span>) - a; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="初始化数组"><a class="markdownIt-Anchor" href="# 初始化数组"></a> 初始化数组</h3>
<h4 id="memset 函数"><a class="markdownIt-Anchor" href="#memset 函数"></a> memset()函数</h4>
<p>给数组初始化时，可以使用 memset()函数进行填充，而不用 for 循环遍历，其格式为： <code>memset(数组名, 初始值, sizeof(数组名));  </code>其在头文件 <cstring> 中，只用 memset()函数为数组赋 0 或 -1 时使用<br />
也可对二维数组和多维数组进行初始操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>]; </span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr)); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="fill 函数"><a class="markdownIt-Anchor" href="#fill 函数"></a> fill()函数</h4>
<p>与 memset 不同的是可以对数组不同范围内赋予任意值，格式： <code>fill(起，始，初始值)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">fill</span>(arr + <span class="number">2</span>, arr + <span class="number">5</span>, <span class="number">234</span>);</span><br></pre></td></tr></table></figure>
<h3 id="find 函数"><a class="markdownIt-Anchor" href="#find 函数"></a> find 函数</h3>
<p>find()函数的具体实用是可以返回一个数组（包括动态）中某个特定元素的指针（迭代器），因为数组的存储空间是连续的，用当前指针（迭代器）去减去开始的指针（迭代器）得到的就是数组中该元素的下标</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">int</span> a_length = <span class="built_in">sizeof</span>(a) / a[<span class="number">0</span>]; <span class="comment">// 获取数组 a 的长度</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="type">int</span> *a_head = a;                                <span class="comment">// 获取起始位置</span></span><br><span class="line"><span class="type">int</span> *a_position = <span class="built_in">find</span>(a, a + a_length, <span class="number">6</span>);     <span class="comment">// 被查找元素的位置</span></span><br><span class="line">cout &lt;&lt; a_position - a_head &lt;&lt; endl;            <span class="comment">// 下标</span></span><br><span class="line"><span class="keyword">auto</span> b_position = <span class="built_in">find</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="number">30</span>); <span class="comment">// 动态数组返回的是迭代器类型，auto==vector&lt;int&gt;::iterator</span></span><br><span class="line">cout &lt;&lt; b_position - b.<span class="built_in">begin</span>() &lt;&lt; endl;         <span class="comment">// 下标</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="binary_search"><a class="markdownIt-Anchor" href="#binary_search"></a> binary_search()</h3>
<p>用以实现二分查找： <code>binary_search(first,last,val)</code>，直接使用 find 函数也可，但如果查找数组中第一个大于 X 的数就不好实现了，所以二分查找又延伸出边界的查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">100</span>] = &#123;<span class="number">4</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">30</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">96</span>, <span class="number">100</span>&#125;;</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">binary_search</span>(a, a + <span class="number">9</span>, <span class="number">4</span>); <span class="comment">// 查找成功，返回 1</span></span><br></pre></td></tr></table></figure>
<h4 id="查找边界"><a class="markdownIt-Anchor" href="# 查找边界"></a> 查找边界</h4>
<p>lower_bound()和 upper_bound()函数作用的对象是一个有序数组或容器，其格式为： <code>lower_bound(first, last, val)</code> ，返回数组或容器中第一个小于（或大于）val 的值的位置（指针或迭代器），若获取下标用其返回的位置减去起始位置即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> up_position = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">6</span>) - v.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; v[up_position] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr, arr + <span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> low_position = <span class="built_in">lower_bound</span>(arr, arr + <span class="number">10</span>, <span class="number">7</span>) - arr - <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; arr[low_position] &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="cctype 头文件"><a class="markdownIt-Anchor" href="#cctype 头文件"></a> cctype 头文件</h2>
<p><cctype>就是 C 语言中的 &lt;ctype.h&gt; 头文件，里边包含一些类型判断函数非常方便<br />
有时不进行头文件引用也可以进行函数的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isalpha</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c is alpha&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">islower</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; <span class="string">&quot;islow&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其他的判断函数还包括：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>函数名</strong></td>
<td><strong>意义</strong></td>
</tr>
<tr>
<td>isalpha</td>
<td>字母（包括大写、小写）</td>
</tr>
<tr>
<td>islower</td>
<td>小写字母</td>
</tr>
<tr>
<td>isupper</td>
<td>大写字母</td>
</tr>
<tr>
<td>isalnum</td>
<td>字母（大写、小写）+ 数字</td>
</tr>
<tr>
<td>isblank</td>
<td>space 和 \t</td>
</tr>
<tr>
<td>isspace</td>
<td>space、\t、\r、\n</td>
</tr>
</tbody>
</table>
<p>此外还有 tolower 和 toupper 方法用来将字符转换为大写或小写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">char</span> t = <span class="built_in">tolower</span>(c); <span class="comment">// 将 c 字符转化为⼩写字符赋值给 t</span></span><br><span class="line">cout &lt;&lt; t &lt;&lt; endl;   <span class="comment">// 此处 t 为 &#x27;a&#x27; </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C 转 C++ 刷题教程</title>
    <url>/summarize-c_plus_stl/</url>
    <content><![CDATA[<p>本文章与其说是 C++ 的 STL 容器使用，其实是在准备算法刷题时总结的一些 API 调用，后来更多的是用 Java，虽说算法不应该和语言挂钩，但不得不承认在刷力扣或是 PAT 算法考试时 C++ 才是我真正的心头好</p>
<span id="more"></span>
<p>实际竞赛或是 PAT 考试时经常会同时用到 C 的简单高效和 C++ 的丰富类库，在总结是也着重记录了 C =&gt; C++ 的语法变化和不同应用场景下的选择</p>
<h2 id="语法变化"><a class="markdownIt-Anchor" href="# 语法变化"></a> 语法变化</h2>
<h3 id="输出方法"><a class="markdownIt-Anchor" href="# 输出方法"></a> 输出方法</h3>
<p>C++ 中提供 cin(&gt;&gt;) 和 cout(&lt;&lt;) 进行弱类型的输入和输出，cin 和 cout 虽然使用起来方便，但是输入输出的效率不如 scanf 和 printf</p>
<h3 id="头文件"><a class="markdownIt-Anchor" href="# 头文件"></a> 头文件</h3>
<p>C++ 的头文件一般是没有像 C 语言的 .h 后缀，但 C++ 向下包含 C，一般 C 语言中的头文件去掉 .h 在前面加上 c 就可以继续使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span><span class="comment">// 相当于 #include &lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span><span class="comment">// 相当于 #include &lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span><span class="comment">// 相当于 #include &lt;string.h&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="bool 类型"><a class="markdownIt-Anchor" href="#bool 类型"></a> bool 类型</h3>
<p>C++ 无需添加头文件就自带布尔类型的变量，在 bool 中 0 为 false，非零为 true</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> flag=<span class="number">-357</span>;<span class="comment">// 为 true</span></span><br><span class="line"><span class="type">bool</span> flag=<span class="number">0</span>;<span class="comment">// 为 false </span></span><br></pre></td></tr></table></figure>
<p>C++ 无需用 #define 定义常量，统一用 <code>const 数据类型 常量名称</code> 的方式进行定义</p>
<h3 id="string 类"><a class="markdownIt-Anchor" href="#string 类"></a> string 类</h3>
<p>C++ 中自带 string 字符串类，部分情况仍需使用 char[] 数组方法，包含定义、输出、拼接和一定的处理<br />
尽量使用 <string> 头文件，<string>≠<cstring></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">string str1 = <span class="string">&quot;Hello World&quot;</span>;<span class="comment">// 定义字符串</span></span><br><span class="line">string str2;</span><br><span class="line">cin &gt;&gt; str2;<span class="comment">// 输入字符串</span></span><br><span class="line">string str3 = str2 + str1;<span class="comment">// 字符串拼接</span></span><br><span class="line">cout &lt;&lt; str3 &lt;&lt; endl;<span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str1.<span class="built_in">length</span>(); i++)</span><br><span class="line">&#123; <span class="comment">// 使用字符数组的方式进行输出</span></span><br><span class="line">    cout &lt;&lt; str1[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="string 输入输出"><a class="markdownIt-Anchor" href="#string 输入输出"></a> string 输入输出</h4>
<p>由于 string 是 C++ 中产生的，所以 C 语言中的 scanf 和 printf 函数无法对其进行输入输出的处理<br />
可以使用 <code>printf(&quot;%s&quot;,str.c_str());</code>的方式进行输出，c_str()函数返回的是一个 C 语言中的 char 指针，表示将字符串转换为一个只读的字符数组<br />
cin 的输入处理是以空格结束一个字符串的，如果要进行整行字符串的输入（回车结束）需要使用 getline 方法</p>
<p>对于字符串长度的获取，也可以直接采用 <code>str.length();</code>或者 <code>str.size()</code>的方式<br />
由于有些函数只支持迭代器为参数，所以 string 也可以以迭代器的方式进行访问（可加减）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str4;</span><br><span class="line"><span class="built_in">getline</span>(cin, str4);<span class="comment">//getline 的参数中需要加上 cin 表示输入</span></span><br><span class="line">cout &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str4.<span class="built_in">length</span>() &lt;&lt; endl; </span><br><span class="line">cout &lt;&lt; str4.<span class="built_in">size</span>() &lt;&lt; endl;  </span><br></pre></td></tr></table></figure>
<h4 id="string 函数"><a class="markdownIt-Anchor" href="#string 函数"></a> string 函数</h4>
<ul>
<li>
<p>string 可以直接进行赋值或加减拼接</p>
</li>
<li>
<p>可以直接用比较运算符判断相等或大于小于（以字典序为规则）</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">string str1 = <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 定义字符串</span></span><br><span class="line">string str2 = <span class="string">&quot;12345&quot;</span>; </span><br><span class="line">str1 += str2; <span class="comment">// 相加进行拼接</span></span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl; </span><br><span class="line">cout &lt;&lt; (str1 &gt; str2) &lt;&lt; endl; <span class="comment">// 输出 str1 是否小于 str2</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输出长度常用 length()而不是 size()</p>
</li>
<li>
<p>insert()插入函数常用两种方式</p>
<ul>
<li>直接位置插入： <code>insert(位置下标，要插入的字符串)</code></li>
<li>迭代器参数插入，常用于将一个字符串的一部分插入到另一字符串： <code>insert(插入位置，被插入字符串的起点，终点)</code></li>
</ul>
</li>
<li>
<p>substr() 字符串截取函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;Hello World&quot;</span>;       <span class="comment">// 定义字符串</span></span><br><span class="line">cout &lt;&lt; str1.<span class="built_in">substr</span>(<span class="number">4</span>) &lt;&lt; endl;    <span class="comment">// 从下标 4 开始到结束</span></span><br><span class="line">cout &lt;&lt; str1.<span class="built_in">substr</span>(<span class="number">4</span>, <span class="number">6</span>) &lt;&lt; endl; <span class="comment">// 从下标 4 开始，截取 6 个字符</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除字符的函数 erase()<br />
erase()接收的也是迭代器作为参数，单个元素或者一个区间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"><span class="keyword">while</span> (str.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>) != string::npos) <span class="comment">//find()返回的是字符的下标</span></span><br><span class="line">&#123;</span><br><span class="line">    str.<span class="built_in">erase</span>(str.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>), <span class="number">1</span>); <span class="comment">// 第二个参数的 1 代表删除元素的个数</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>()); <span class="comment">// 删除第一个字符</span></span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">begin</span>() + <span class="number">2</span>); <span class="comment">// 删除一个范围，左闭右开</span></span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">clear</span>(); <span class="comment">// 清空字符串 </span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>find()查找字符或字串，查找失败返回 <code>string::npos</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;qwertasd&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 查找单个字符返回的这个字符的下标，可用其返回值!=string::npos 的方式表示查找成功</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find</span>(str2) &lt;&lt; endl;    <span class="comment">// 返回匹配成功的起始下标</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find</span>(str2, <span class="number">4</span>) &lt;&lt; endl; <span class="comment">// 表示从下标 4 开始向后查找，返回值与上一样</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>replace()函数替换字串： <code>replace(替换起始位置，替换长度，替换的字串)</code><br />
也支持迭代器参数替换： <code>replace(迭代器位置起，始，字串)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">string str = <span class="string">&quot;qwertasd&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">replace</span>(<span class="number">3</span>, <span class="number">3</span>, str2) &lt;&lt; endl; <span class="comment">// 从下标 3 开始往后的三个字符被 str2 替代</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">replace</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">begin</span>() + <span class="number">4</span>, str2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="struct 的使用"><a class="markdownIt-Anchor" href="#struct 的使用"></a> struct 的使用</h3>
<p>在 C++ 中，结构体生成对象时无需进行结构体的声明，也就是不用在前面加是 struct<br />
结构体的定义尽量在 main() 方法之外</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> grade;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span> arr1[<span class="number">10</span>]; <span class="comment">// C 语言里面需要写 struct</span></span><br><span class="line">stu arr2[<span class="number">10</span>];        <span class="comment">// C++ 里面不用写</span></span><br></pre></td></tr></table></figure>
<h3 id="在 c 中的引用"><a class="markdownIt-Anchor" href="# 在 c 中的引用"></a> &amp; 在 C++ 中的引用</h3>
<p>C++ 中的 &amp; 符号在函数的参数列表中作引用，要与 C 语言的取地址输入分开，这两者并不相同<br />
做引用时的意思是将传送进来的变量参数直接进行操作（可以理解成拷贝副本），只是将名字换成了定义方法中的局部变量名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">function</span>(n); <span class="comment">// n 由 0 变成了 99</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> &amp;a)</span><span class="comment">// 传⼊的是 n 的引⽤，相当于直接对 n 进⾏了操作，只不过在 function 函数中换了个名字叫 a</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"></span><br><span class="line">    a = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">function</span>(n); <span class="comment">// 并没有对 n 这个值进行改变，还是 0</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> a)</span> <span class="comment">// 传⼊的是 0 这个值，并不会改变 main 函数中 n 的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">99</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="stl 的应用"><a class="markdownIt-Anchor" href="#stl 的应用"></a> STL 的应用</h2>
<p>STL 称为标准模板库（Standard Template Library） ，STL 已完全被内置到支持 C++ 的编译器中，无需额外安装</p>
<h3 id="vector 动态数组"><a class="markdownIt-Anchor" href="#vector 动态数组"></a> vector 动态数组</h3>
<p>动态数组 vector，能够在运行阶段设置数组的长度、在末尾增加新的数据、在中间插入新的值、长度任意被改变</p>
<ol>
<li>
<p>定义 vector，vector 是包含在头文件 [vector] 中的，预定义头文件之后的生成格式为： <code>vector&lt; 数据类型 &gt; 数组名;</code></p>
</li>
<li>
<p>vector 的大小如果在初始不进行定义的话默认为 0，可以采用<code>vector&lt; 数据类型 &gt; 数组名(``size``);</code> 的方式来进行初始大小的定义，也可以采用 resize 方法进行大小的重定义</p>
</li>
<li>
<p>对定义了长度的数组，那么它的初始值将全部定义为 0<br />
也可以采用 <code>vector&lt; 数据类型 &gt; 数组名(size, 初始值); </code> 在初始化的是否就赋予初始值</p>
</li>
<li>
<p>对 vector 动态数组的访问和普通数组的访问方式一样，也是通过下标的方式，但可以通过迭代器进行遍历</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">cout &lt;&lt; num.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 刚创建的数组为空，size==0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">number</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">// 将 number 数组的大小定义为 10</span></span><br><span class="line">cout &lt;&lt; number.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">num.<span class="built_in">resize</span>(<span class="number">5</span>); <span class="comment">// 将 num 的长度重定义为 5</span></span><br><span class="line">cout &lt;&lt; num.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; num[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 此时初始值为 0</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numbers</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;<span class="comment">// 初始化数组长度为 10，所有元素的初始值为 5</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; numbers[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 此时初始值为 5</span></span><br><span class="line">&#125;</span><br><span class="line">num.<span class="built_in">clear</span>();<span class="comment">// 清空数组元素，复杂度为 O(N)（N 为元素的个数） </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : numbers)<span class="comment">// 读取型遍历</span></span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>push_back() 和 pop_back() 函数实现在数组尾插入或删除元素</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; num = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">num.<span class="built_in">push_back</span>(<span class="number">40</span>); <span class="comment">// 在数组末尾插入 40</span></span><br><span class="line">num.<span class="built_in">pop_back</span>();    <span class="comment">// 移除最后一个元素 </span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>迭代器访问，完整的指针类型定义应该是 <code>vector&lt;int&gt;::iterator</code> ，但在 C++１１中出现了 auto 型，会自动进行检测变量的类型<br />
美国人的思想为 <strong> 左闭右开 </strong>，也就是 end() 函数不进行存储任何东西，表示一个数组到这就为空了（尾元素的下一个元素的地址）</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = num.<span class="built_in">begin</span>(); it != num.<span class="built_in">end</span>(); it++)<span class="comment">//num.begin()是一个指针，代表指向第一个元素</span></span><br><span class="line">&#123;                       <span class="comment">//auto 相当于生成一个 vector 类型的迭代器，it 是 iterator 的缩写</span></span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//it 是一个指针，加 * 进行取值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有 vector 和 string 中才允许有 <code>ve.begin()+3</code>这种迭代器加整数的操作</p>
<ol start="7">
<li>在指定位置插入新的元素，可以使用自带的 insert()和 emplace()函数</li>
</ol>
<p>insert() 函数的功能是在 vector 容器的指定位置插入一个或多个元素。该函数的语法格式有多种</p>
<table>
<thead>
<tr>
<th>语法格式</th>
<th>用法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>insert(pos,elem)</td>
<td>在迭代器 pos 指定的位置之前插入一个新元素 elem，并返回表示新插入元素位置的迭代器</td>
</tr>
<tr>
<td>insert(pos,n,elem)</td>
<td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器</td>
</tr>
<tr>
<td>insert(pos,first,last)</td>
<td>在迭代器 pos 指定的位置之前，插入其他容器（不仅限于 vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器</td>
</tr>
<tr>
<td>insert(pos,initlist)</td>
<td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号 {} 括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; demo&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// 第一种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>); <span class="comment">//&#123;1,3,2&#125;</span></span><br><span class="line">    <span class="comment">// 第二种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>); <span class="comment">//&#123;1,3,2,5,5&#125;</span></span><br><span class="line">    <span class="comment">// 第三种格式用法</span></span><br><span class="line">    array&lt;<span class="type">int</span>, 3&gt; test&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>()); <span class="comment">//&#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line">    <span class="comment">// 第四种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), &#123;<span class="number">10</span>, <span class="number">11</span>&#125;); <span class="comment">//&#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>emplace()用于在 vector 容器指定位置之前插入一个新的元素，其格式为 <code>iterator emplace (const_iterator pos, args...);</code> emplace()函数的效率更高一些</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; demo1&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//emplace() 每次只能插入一个 int 类型元素</span></span><br><span class="line">    demo1.<span class="built_in">emplace</span>(demo1.<span class="built_in">begin</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; demo1.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; demo1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>erase()删除函数用来删除数组中的特定元素，但其接收的参数为一个迭代器，可以先用 <algorithm> 下的 find()函数查找出位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; num = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), <span class="number">6</span>); <span class="comment">// 查找相应元素的迭代器</span></span><br><span class="line">num.<span class="built_in">erase</span>(it);                             <span class="comment">// 删除这个元素</span></span><br><span class="line">num.<span class="built_in">erase</span>(num.<span class="built_in">begin</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = num.<span class="built_in">begin</span>(); it != num.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="set 集合"><a class="markdownIt-Anchor" href="#set 集合"></a> set 集合</h3>
<p>集合中的元素各不相同，而且元素之间会进行从小到大的排序</p>
<ol>
<li>
<p>set 是包含在头文件 <set> 中的，预定义头文件之后的生成格式为： <code>set&lt; 数据类型 &gt; 集合名;</code></p>
</li>
<li>
<p>set 集合中的元素是有序的，所以不用管插入的位置，插入方式为： <code>set.insert(元素);</code></p>
</li>
<li>
<p>集合的输出：使用迭代器的方式进行集合的遍历输出，但集合是默认从小到大排序的，所以可以使用 <code>set.rbegin()/set.rend()</code>反向迭代器实现反向遍历<br />
可以通过 <code>*(num.begin())</code> 这种指针取值的方式来对第一个元素（最小元素）进行输出；同理 <code>*(num.rbegin())</code> 对最后一个元素（最大元素）进行输出</p>
</li>
<li>
<p>对集合中元素的查找可以使用 <code>set.find(目标元素)</code>，但此方法是一个迭代器，我们可以用 <code>set.find(目标元素) != set.end()</code>的方式，通过返回值 1 或 0 判断集合中有无这个元素</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; num;               <span class="comment">// 定义 set 集合</span></span><br><span class="line">num.<span class="built_in">insert</span>(<span class="number">1</span>);              <span class="comment">// 向集合中插入元素 1</span></span><br><span class="line">cout &lt;&lt; num.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 输出集合的大小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    num.<span class="built_in">insert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">num.<span class="built_in">erase</span>(<span class="number">5</span>);<span class="comment">// 擦除元素 5</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;min:&quot;</span> &lt;&lt; *(num.<span class="built_in">begin</span>()) &lt;&lt; endl; <span class="comment">// 输出集合中第一个元素的元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;max:&quot;</span> &lt;&lt; *(num.<span class="built_in">rbegin</span>()) &lt;&lt; endl; <span class="comment">// 输出集合中最后一个元素的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = num.<span class="built_in">begin</span>(); it != num.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123; <span class="comment">// 遍历集合</span></span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = num.<span class="built_in">rbegin</span>(); it != num.<span class="built_in">rend</span>(); it++)</span><br><span class="line">&#123; <span class="comment">// 反向遍历集合</span></span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl</span><br><span class="line">     &lt;&lt; (num.<span class="built_in">find</span>(<span class="number">7</span>) != num.<span class="built_in">end</span>()) &lt;&lt; endl; <span class="comment">// 查找元素 7</span></span><br><span class="line">cout &lt;&lt; *(num.<span class="built_in">find</span>(<span class="number">7</span>)) &lt;&lt; endl; </span><br><span class="line">num.<span class="built_in">clear</span>(); <span class="comment">// 清空集合 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>set 集合的 erase()函数不同于 vector 只能以迭代器作为参数，可以用迭代器，元素值和迭代器范围进行删除<br />
但是 set 集合又不允许迭代器相加的操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; num; <span class="comment">// 定义 set 集合</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    num.<span class="built_in">insert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">num.<span class="built_in">erase</span>(<span class="number">5</span>);                              <span class="comment">// 擦除元素 5</span></span><br><span class="line">num.<span class="built_in">erase</span>(num.<span class="built_in">begin</span>());                    <span class="comment">// 擦除起始元素</span></span><br><span class="line">num.<span class="built_in">erase</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">find</span>(<span class="number">4</span>));       <span class="comment">// 擦除开始到元素 4 的位置（不包含 num.find(4)）</span></span><br></pre></td></tr></table></figure>
<h3 id="map 键值对"><a class="markdownIt-Anchor" href="#map 键值对"></a> map 键值对</h3>
<p>map 集合又称为映射，采用一键对一值的方式进行存储，存放的元素会通过键进行从小到大的排列<br />
map 是包含在头文件 <map> 中的，预定义头文件之后的生成格式为： <code>map&lt; 键数据类型, 值数据类型 &gt; 集合名; </code></p>
<p>通过键作为下标存储值达到同时存储一对数据的目的，擦除也是一样<br />
也有迭代器遍历和反迭代器的内部函数，但是无需对指针进行取值，只要用指针指向 frist 或 second 便可直接显示键或值的内容，如 <code>data.begin()-&gt;frist</code> 表示第一对元素的键的内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; data;</span><br><span class="line">data[<span class="string">&quot;hello&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">data[<span class="string">&quot;world&quot;</span>] = <span class="number">7</span>;</span><br><span class="line">data[<span class="string">&quot;;&quot;</span>] = <span class="number">2</span>;                 <span class="comment">// 在 map 中插入元素</span></span><br><span class="line">cout &lt;&lt; data[<span class="string">&quot;hello&quot;</span>] &lt;&lt; endl; <span class="comment">// 通过键输出值, 不存在返回 0</span></span><br><span class="line">cout &lt;&lt; data.<span class="built_in">size</span>() &lt;&lt; endl;   <span class="comment">//map 的大小，一对键值看作一个元素</span></span><br><span class="line">data.<span class="built_in">erase</span>(<span class="string">&quot;hello&quot;</span>);           <span class="comment">// 通过键擦除一对元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = data.<span class="built_in">begin</span>(); it != data.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123; <span class="comment">// 迭代器遍历，直接用指针取值，指向 frist 表示键，指向 seco 表示值</span></span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>find()函数，参数为 key，查找成功返回一个迭代器</p>
</li>
<li>
<p>count()函数，返回被查找元素的个数（map 中的元素不重复，值只可能是 1 或 0），参数也是 key</p>
</li>
<li>
<p>erase()函数，删除单个元素时的参数可以是迭代器也可以是 key，删除区间元素只能是迭代器的起始位置</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; data;</span><br><span class="line">data[<span class="string">&#x27;a&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">data[<span class="string">&#x27;b&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">data[<span class="string">&#x27;c&#x27;</span>] = <span class="number">4</span>;</span><br><span class="line">data[<span class="string">&#x27;d&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> it = data.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 查找成功返回位置 5</span></span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">data.<span class="built_in">erase</span>(<span class="string">&#x27;a&#x27;</span>);                      <span class="comment">// 通过 key 删除元素</span></span><br><span class="line">data.<span class="built_in">erase</span>(data.<span class="built_in">find</span>(<span class="string">&#x27;b&#x27;</span>));           <span class="comment">// 通过迭代器删除元素</span></span><br><span class="line">data.<span class="built_in">erase</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>()); <span class="comment">// 通过迭代器起始删除区间元素</span></span><br><span class="line">data.<span class="built_in">clear</span>();                         <span class="comment">// 清空元素</span></span><br></pre></td></tr></table></figure>
<h4 id="unordered 集合"><a class="markdownIt-Anchor" href="#unordered 集合"></a> unordered 集合</h4>
<p>因为在 map 和 set 集合中的元素都是有序的，但 unordered 的意思是未经排序，也就是里面的元素是无序的，时间复杂度更小一下，用法相同</p>
<h3 id="queue 队列"><a class="markdownIt-Anchor" href="#queue 队列"></a> queue 队列</h3>
<p>有头尾指针 front 和 back，先进先出，队尾入，队首移除<br />
主要使用是在广度优先搜索时无需手动编写队列</p>
<ol>
<li>
<p>头文件<queue>，定义格式： <code>queue&lt; 数据类型 &gt; 队名;</code></p>
</li>
<li>
<p>push()和 pop()进行入队和出队操作（队尾入，队首出），无法遍历，可读取队首队尾，可访问大小</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    que.<span class="built_in">push</span>(i); <span class="comment">// 从队尾入队</span></span><br><span class="line">&#125;</span><br><span class="line">que.<span class="built_in">pop</span>();                                        <span class="comment">// 移除队首元素</span></span><br><span class="line">cout &lt;&lt; que.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; que.<span class="built_in">back</span>() &lt;&lt; endl; <span class="comment">// 输出首尾元素</span></span><br><span class="line">cout &lt;&lt; que.<span class="built_in">size</span>() &lt;&lt; endl;                       <span class="comment">// 输出大小</span></span><br><span class="line">cout &lt;&lt; que.<span class="built_in">empty</span>() &lt;&lt; endl;                      <span class="comment">// 判断是否为空</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>empty()函数判断是否为空返回 bool 型，在使用 front 和 back 进行输出时，先判断是否为空，否则容易出错</li>
</ol>
<h4 id="priority_queue 队列"><a class="markdownIt-Anchor" href="#priority_queue 队列"></a> priority_queue 队列</h4>
<p>称为优先队列，底层是用堆来实现的，具体表现为队首元素永远时优先级最高的那个（优先级可以自己规定）</p>
<p>优先队列没有 front 和 back 指针，统一用 top 来对队首进行操作（又称为堆顶），其他使用与 queue 无异</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">num.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">num.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">num.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 输出堆顶</span></span><br><span class="line">num.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>优先级的定义，可以使用自带的大小定义，其格式为： <code>priority_queue&lt; 类型，vector&lt; 类型 &gt;，less&lt; 类型 &gt;&gt; num; </code> 这是指小的放后边，也就是默认的规则，若改为大的放后边只要将 less 改为 greater 即可<br />
其他方法看算法笔记 P235</p>
<h3 id="stack 栈"><a class="markdownIt-Anchor" href="#stack 栈"></a> stack 栈</h3>
<p>先进后出，只能对栈顶进行操作，所以只有一个指针 top</p>
<ol>
<li>
<p>头文件<stack>，定义格式： <code>stack&lt; 数据类型 &gt; 栈名;</code></p>
</li>
<li>
<p>push()和 pop()进行入栈和出栈操作，无法遍历，只能读取栈顶 top，可访问大小</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s; <span class="comment">// 定义⼀个空栈 s</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    s.<span class="built_in">push</span>(i); <span class="comment">// 将元素 i 压⼊栈 s 中</span></span><br><span class="line">&#125;</span><br><span class="line">s.<span class="built_in">pop</span>();                  <span class="comment">// 移除栈顶元素</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;  <span class="comment">// 访问 s 的栈顶元素</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 输出 s 的元素个数 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="pair 元素对"><a class="markdownIt-Anchor" href="#pair 元素对"></a> pair 元素对</h3>
<p>在头文件 <utility> 中，主要是将两个元素（无论类型是否相同）合成一个元素，就像定义在结构体中定义两个不同变量，但是用起来更简单，可以直接比较大小（先比较 first，如果相同再比较 second）<br />
访问就像 map 中的 first 元素和 second 函数（但不是指向，而是类似结构体的形式）</p>
<p>初始化可以直接在后边加圆括号直接输入，还有三种赋值方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;string, <span class="type">int</span>&gt; psi;</span><br><span class="line"><span class="comment">//pair&lt;string, int&gt; psi(&quot;hh&quot;, 5);// 初始化 </span></span><br><span class="line">psi = <span class="built_in">make_pair</span>(<span class="string">&quot;ha&quot;</span>, <span class="number">6</span>); <span class="comment">// 使用 make_pair() 函数定义</span></span><br><span class="line">cout &lt;&lt; psi.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; psi.second &lt;&lt; endl;</span><br><span class="line">psi = <span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;hh&quot;</span>, <span class="number">5</span>); <span class="comment">// 指定类型定义</span></span><br><span class="line">cout &lt;&lt; psi.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; psi.second &lt;&lt; endl;</span><br><span class="line">psi.first = <span class="string">&quot;xx&quot;</span>; <span class="comment">// 指定变量定义</span></span><br><span class="line">psi.second = <span class="number">7</span>;</span><br><span class="line">cout &lt;&lt; psi.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; psi.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>具体使用就是代替二元结构体和作为键值对插入 map 中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; msi;</span><br><span class="line">msi[<span class="string">&quot;hh&quot;</span>] = <span class="number">6</span>;                    <span class="comment">// 传统定义</span></span><br><span class="line">msi.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;xixi&quot;</span>, <span class="number">8</span>)); <span class="comment">//pair 插入</span></span><br><span class="line"><span class="keyword">auto</span> it = msi.<span class="built_in">find</span>(<span class="string">&quot;hh&quot;</span>);</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">it = msi.<span class="built_in">find</span>(<span class="string">&quot;xixi&quot;</span>);</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT 甲级 - 模板库</title>
    <url>/pat_level_a-stl/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p>C++ 中为使用者提供了标准的模板库也叫 STL，其中封装了大部分刷题所要用到的容器，而我在之前写过一篇《C++ STL》，所以这里就是单纯的记录一些类型题的解题思路，并不重复赘述具体的使用和含义 <br />
话说 C++ 中的容器在易用性和速度上做出的平衡要比其他语言强的不是一星半点，之前看过侯捷老师的手撕 STL 源码，后来转 Java 没能坚持看完，但仍感觉受益匪浅（虽说时间一长忘干净了），不知道什么原因 B 站上找不到了 </p>
<span id="more"></span>
<h2 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h2>
<h4 id="1039"><a class="markdownIt-Anchor" href="#1039"></a> 1039</h4>
<p><strong> 题目：Course List for Student</strong></p>
<p>Zhejiang University has 40000 students and provides 2500 courses. Now given the student name lists of all the courses, you are supposed to output the registered course list for each student who comes for a query.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤40, 000), the number of students who look for their course lists, and K (≤2, 500), the total number of courses. Then the student name lists are given for the courses (numbered from 1 to K) in the following format: for each course i, first the course index i and the number of registered students Ni (≤200) are given in a line. Then in the next line, Ni student names are given. A student name consists of 3 capital English letters plus a one-digit number. Finally the last line contains the N names of students who come for a query. All the names and numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print your results in N lines. Each line corresponds to one student, in the following format: first print the student’s name, then the total number of registered courses of that student, and finally the indices of the courses in increasing order. The query results must be printed in the same order as input. All the data in a line must be separated by a space, with no extra space at the end of the line.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>11 5<br />
4 7<br />
BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1<br />
1 4<br />
ANN0 BOB5 JAY9 LOR6<br />
2 7<br />
ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR6<br />
3 1<br />
BOB5<br />
5 9<br />
AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1<br />
ZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 NON9</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>ZOE1 2 4 5<br />
ANN0 3 1 2 5<br />
BOB5 5 1 2 3 4 5<br />
JOE4 1 2<br />
JAY9 4 1 2 4 5<br />
FRA8 3 2 4 5<br />
DON2 2 4 5<br />
AMY7 1 5<br />
KAT3 3 2 4 5<br />
LOR6 4 1 2 4 5<br />
NON9 0</p>
</blockquote>
<p><strong> 思路：</strong> 使用 map 搭配 vector 动态数组进行课程编号和姓名的映射存放，因数据规模过大，不要使用 cin 和 cout，姓名使用 char 数组存储，避免使用字符串，查询输出时，进行编号的排序 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    map&lt;string, vector&lt;<span class="type">int</span>&gt;&gt; list;<span class="comment">// 建立集合，用姓名映射课程的方式 </span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];<span class="comment">// 直接输入字符串会超时，使用字符数组的方式 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id, cnt;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;id, &amp;cnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">            list[name].<span class="built_in">push_back</span>(id);<span class="comment">// 根据姓名将课程 ID 放入 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v = list[name];<span class="comment">// 查询时放入临时数组 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d&quot;</span>, name, v.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">// 排序后输出 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, v[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1047"><a class="markdownIt-Anchor" href="#1047"></a> 1047</h4>
<p><strong> 题目：Student List for Course</strong></p>
<p>Zhejiang University has 40,000 students and provides 2,500 courses. Now given the registered course list of each student, you are supposed to output the student name lists of all the courses.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains 2 numbers: N (≤40,000), the total number of students, and K (≤2,500), the total number of courses. Then N lines follow, each contains a student’s name (3 capital English letters plus a one-digit number), a positive number C (≤20) which is the number of courses that this student has registered, and then followed by C course numbers. For the sake of simplicity, the courses are numbered from 1 to K.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print the student name lists of all the courses in increasing order of the course numbers. For each course, first print in one line the course number and the number of registered students, separated by a space. Then output the students’ names in alphabetical order. Each name occupies a line.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>10 5<br />
ZOE1 2 4 5<br />
ANN0 3 5 2 1<br />
BOB5 5 3 4 2 1 5<br />
JOE4 1 2<br />
JAY9 4 1 2 5 4<br />
FRA8 3 4 2 5<br />
DON2 2 4 5<br />
AMY7 1 5<br />
KAT3 3 5 4 2<br />
LOR6 4 2 4 1 5</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>1 4<br />
ANN0<br />
BOB5<br />
JAY9<br />
LOR6<br />
2 7<br />
ANN0<br />
BOB5<br />
FRA8<br />
JAY9<br />
JOE4<br />
KAT3<br />
LOR6<br />
3 1<br />
BOB5<br />
4 7<br />
BOB5<br />
DON2<br />
FRA8<br />
JAY9<br />
KAT3<br />
LOR6<br />
ZOE1<br />
5 9<br />
AMY7<br />
ANN0<br />
BOB5<br />
DON2<br />
FRA8<br />
JAY9<br />
KAT3<br />
LOR6<br />
ZOE1</p>
</blockquote>
<p><strong> 思路：</strong> 使用 map 映射 vector 字符串数组即可 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int n, m;</span></span><br><span class="line"><span class="comment">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span></span><br><span class="line"><span class="comment">    map&lt;int, vector&lt;string&gt;&gt; list;</span></span><br><span class="line"><span class="comment">    char name[5];</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int k;</span></span><br><span class="line"><span class="comment">        scanf(&quot;%s %d&quot;, name, &amp;k);</span></span><br><span class="line"><span class="comment">        for (int j = 0; j &lt; k; j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            int temp;</span></span><br><span class="line"><span class="comment">            scanf(&quot;%d&quot;, &amp;temp);</span></span><br><span class="line"><span class="comment">            list[temp].push_back(name);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    for (int i=1;i&lt;=m;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        vector&lt;string&gt; str = list[i];</span></span><br><span class="line"><span class="comment">        printf(&quot;%d %d\n&quot;, i, str.size());</span></span><br><span class="line"><span class="comment">        sort(str.begin(), str.end());</span></span><br><span class="line"><span class="comment">        for (int j = 0; j &lt; str.size(); j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            printf(&quot;%s\n&quot;,str[j].c_str());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    system(&quot;pause&quot;);</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, c, idx;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; course;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    course.<span class="built_in">resize</span>(k + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        string name;</span><br><span class="line">        cin &gt;&gt; name &gt;&gt; c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;idx);</span><br><span class="line">            course[idx].<span class="built_in">push_back</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, course[i].<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">sort</span>(course[i].<span class="built_in">begin</span>(), course[i].<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; course[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, course[i][j].<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h2>
<h4 id="1063"><a class="markdownIt-Anchor" href="#1063"></a> <strong>1063</strong></h4>
<p><strong> 题目：Set Similarity</strong></p>
<p>Given two sets of integers, the similarity of the sets is defined to be Nc/Nt×100%, where Nc is the number of distinct common numbers shared by the two sets, and Nt is the total number of distinct numbers in the two sets. Your job is to calculate the similarity of any given pair of sets.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. Each case first gives a positive integer N (≤50) which is the total number of sets. Then N lines follow, each gives a set with a positive <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M (≤10^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and followed by M integers in the range [0, 109]. After the input of sets, a positive integer K (≤2000) is given, followed by K lines of queries. Each query gives a pair of set numbers (the sets are numbered from 1 to N). All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each query, print in one line the similarity of the sets, in the percentage form accurate up to 1 decimal place.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>3<br />
3 99 87 101<br />
4 87 101 5 87<br />
7 99 101 18 5 135 18 99<br />
2<br />
1 2<br />
1 3</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>50.0%<br />
33.3%</p>
</blockquote>
<p><strong> 思路：</strong> 相似性的计算就是在集合 B 中出现过的集合 A 的元素除以所有不重复的元素和；注意：集合变量的名称不能时模板类的名称 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m; </span><br><span class="line">set&lt;<span class="type">int</span>&gt; st[<span class="number">51</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">// 将比较方法独立出来 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> samenum = <span class="number">0</span>, totalnum = st[b].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = st[a].<span class="built_in">begin</span>(); it != st[a].<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[b].<span class="built_in">find</span>(*it) != st[b].<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            samenum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            totalnum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1f%\n&quot;</span>, samenum * <span class="number">100.00</span> / totalnum); <span class="comment">// 输出保留一位小数 </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> size, temp;</span><br><span class="line">        cin &gt;&gt; size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; temp;</span><br><span class="line">            st[i].<span class="built_in">insert</span>(temp); <span class="comment">// 存储到 set 数组中 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">compare</span>(a, b); <span class="comment">// 通过查找编号调用方法 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="string"><a class="markdownIt-Anchor" href="#string"></a> string</h2>
<h4 id="1060"><a class="markdownIt-Anchor" href="#1060"></a> 1060</h4>
<p><strong> 题目：Are They Equal</strong></p>
<p>If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123×105 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10100, and that its total digit number is less than 100.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in a line <code>YES</code> if the two numbers are treated equal, and then the number in the standard form <code>0.d[1]...d[N]*10^k</code> (<code>d[1]</code>&gt;0 unless the number is 0); or <code>NO</code> if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line.</p>
<p>Note: Simple chopping is assumed without rounding.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>3 12300 12358.9</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>YES 0.123*10^5</p>
</blockquote>
<p><em>Sample Input 2:</em></p>
<blockquote>
<p>3 120 128</p>
</blockquote>
<p><em>Sample Output 2:</em></p>
<blockquote>
<p>NO 0.12010^3 0.12810^3</p>
</blockquote>
<p><strong> 思路：</strong> 只需判断保存有效数字的字符串和指数位数是否相同即可保证一对数字的相同，根据不同情况的处理封装在方法中 </p>
<ul>
<li>
<p> 指数在 main 方法中定义，使用 <code>int&amp; e</code> 的方式处理同一变量，否则无法返回两个变量 </p>
</li>
<li>
<p> 在方法中首先去掉前导零，去掉后有三种情况，首字符为小数点为小数，否则为正数，若字符串长度为 0，为 0</p>
</li>
<li>
<p> 当为小数时，去掉小数点，小数点后面 0 的个数即为指数 e 的值 </p>
</li>
<li>
<p> 为正数时，向后寻找小数点或末尾，非 0 或末尾，指数 e++</p>
</li>
<li>
<p> 最后根据输入 N 的值每次放入一个有效字符，不足补 0，返回判断即可 </p>
</li>
</ul>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">string <span class="title">deal</span><span class="params">(string str, <span class="type">int</span> &amp;e)</span> <span class="comment">// 字符串处理方法，指数 e 为恒定地址变量 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str.<span class="built_in">length</span>() &gt; <span class="number">0</span> &amp;&amp; str[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="comment">// 将前导 0 去除 </span></span><br><span class="line">    &#123;</span><br><span class="line">        str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) <span class="comment">// 去掉 0 为小数点说明为小数 </span></span><br><span class="line">    &#123;</span><br><span class="line">        str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">while</span> (str.<span class="built_in">length</span>() &gt; <span class="number">0</span> &amp;&amp; str[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="comment">// 通过小数点后边 0 的个数获得指数的负数值 </span></span><br><span class="line">        &#123;</span><br><span class="line">            str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>());</span><br><span class="line">            e--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 不是小数点即为整数 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; str.<span class="built_in">length</span>() &amp;&amp; str[k] != <span class="string">&#x27;.&#x27;</span>) <span class="comment">// 小数点之前的位数为指数值 </span></span><br><span class="line">        &#123;</span><br><span class="line">            k++;</span><br><span class="line">            e++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; str.<span class="built_in">length</span>()) <span class="comment">// 最后 k 的值小于字符串长度说明有小数点，将其去掉 </span></span><br><span class="line">        &#123;</span><br><span class="line">            str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>() + k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">length</span>() == <span class="number">0</span>) <span class="comment">// 如果去掉 0，字符串长度为 0，说明指数也为 0</span></span><br><span class="line">    &#123;</span><br><span class="line">        e = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    string dealed;</span><br><span class="line">    <span class="keyword">while</span> (num &lt; n) <span class="comment">// 保存 n 个有效数字 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; str.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            dealed += str[k++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dealed += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dealed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1, s2, s3, s4;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="type">int</span> e1 = <span class="number">0</span>, e2 = <span class="number">0</span>;</span><br><span class="line">    s3 = <span class="built_in">deal</span>(s1, e1);</span><br><span class="line">    s4 = <span class="built_in">deal</span>(s2, e2);</span><br><span class="line">    <span class="keyword">if</span> (s3 == s4 &amp;&amp; e1 == e2) <span class="comment">// 通过有效数字和指数判断科学计数法是否相同 </span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES 0.&quot;</span> &lt;&lt; s3 &lt;&lt; <span class="string">&quot;*10^&quot;</span> &lt;&lt; e1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO 0.&quot;</span> &lt;&lt; s3 &lt;&lt; <span class="string">&quot;*10^&quot;</span> &lt;&lt; e1 &lt;&lt; <span class="string">&quot; 0.&quot;</span> &lt;&lt; s4 &lt;&lt; <span class="string">&quot;*10^&quot;</span> &lt;&lt; e2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h2>
<h4 id="1100"><a class="markdownIt-Anchor" href="#1100"></a> 1100</h4>
<p><strong> 题目：Mars Numbers</strong></p>
<p>People on Mars count their numbers with base 13:</p>
<ul>
<li>
<p>Zero on Earth is called “tret” on Mars.</p>
</li>
<li>
<p>The numbers 1 to 12 on Earth is called “jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec” on Mars, respectively.</p>
</li>
<li>
<p>For the next higher digit, Mars people name the 12 numbers as “tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou”, respectively.</p>
</li>
</ul>
<p>For examples, the number 29 on Earth is called “hel mar” on Mars; and “elo nov” on Mars corresponds to 115 on Earth. In order to help communication between people from these two planets, you are supposed to write a program for mutual translation between Earth and Mars number systems.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;100). Then N lines follow, each contains a number in [0, 169), given either in the form of an Earth number, or that of Mars.</p>
<p><em>Output Specification:</em></p>
<p>For each number, print in a line the corresponding number in the other language.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>4<br />
29<br />
5<br />
elo nov<br />
tam</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>hel mar<br />
may<br />
115<br />
13</p>
</blockquote>
<p><strong> 思路：</strong> 因为数据不会超过 169，直接采用打表的方式将每个数字与其“火星文”形式对应起来 </p>
<ul>
<li>
<p> 字符串数组对应数字转“火星文”，map&lt;string, int&gt; 对应“火星文”转数字 </p>
</li>
<li>
<p> 打表将个位和整十位分为一种情况，其他分为一种情况，进行运算赋值即可 </p>
</li>
</ul>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line">string unitDigit[<span class="number">13</span>] = &#123;<span class="string">&quot;tret&quot;</span>, <span class="string">&quot;jan&quot;</span>, <span class="string">&quot;feb&quot;</span>, <span class="string">&quot;mar&quot;</span>, <span class="string">&quot;apr&quot;</span>, <span class="string">&quot;may&quot;</span>, <span class="string">&quot;jun&quot;</span>, <span class="string">&quot;jly&quot;</span>, <span class="string">&quot;aug&quot;</span>, <span class="string">&quot;sep&quot;</span>, <span class="string">&quot;oct&quot;</span>, <span class="string">&quot;nov&quot;</span>, <span class="string">&quot;dec&quot;</span>&#125;; </span><br><span class="line">string tenDigit[<span class="number">13</span>] = &#123;<span class="string">&quot;tret&quot;</span>, <span class="string">&quot;tam&quot;</span>, <span class="string">&quot;hel&quot;</span>, <span class="string">&quot;maa&quot;</span>, <span class="string">&quot;huh&quot;</span>, <span class="string">&quot;tou&quot;</span>, <span class="string">&quot;kes&quot;</span>, <span class="string">&quot;hei&quot;</span>, <span class="string">&quot;elo&quot;</span>, <span class="string">&quot;syy&quot;</span>, <span class="string">&quot;lok&quot;</span>, <span class="string">&quot;mer&quot;</span>, <span class="string">&quot;jou&quot;</span>&#125;; </span><br><span class="line"><span class="comment">// 将个位十位保存 </span></span><br><span class="line">string numToStr[<span class="number">170</span>]; <span class="comment">// 通过数字作为下标输出字符串 </span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; strToNum; <span class="comment">// 通过字符串映射到数字 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        numToStr[i] = unitDigit[i];</span><br><span class="line">        strToNum[unitDigit[i]] = i; <span class="comment">// 存储个位的互相对应 </span></span><br><span class="line">        numToStr[i * <span class="number">13</span>] = tenDigit[i];</span><br><span class="line">        strToNum[tenDigit[i]] = i * <span class="number">13</span>; <span class="comment">// 存储整十位的互相对应 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">13</span>; i++)</span><br><span class="line">    &#123; <span class="comment">// 每位的对应 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">13</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            string str = tenDigit[i] + <span class="string">&quot; &quot;</span> + unitDigit[j];</span><br><span class="line">            numToStr[i * <span class="number">13</span> + j] = str;</span><br><span class="line">            strToNum[str] = i * <span class="number">13</span> + j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(); <span class="comment">// 调用打表 </span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string query;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin, query);</span><br><span class="line">        <span class="keyword">if</span> (query[<span class="number">0</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; query[<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = <span class="built_in">stoi</span>(query); <span class="comment">// 将属于数字的转换为 int 型 </span></span><br><span class="line">            cout &lt;&lt; numToStr[num] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; strToNum[query] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1054"><a class="markdownIt-Anchor" href="#1054"></a> 1054</h4>
<p><strong> 题目：The Dominant Color</strong></p>
<p>Behind the scenes in the computer’s memory, color is always talked about as a series of 24 bits of information for each pixel. In an image, the color with the largest proportional area is called the dominant color. A <strong>strictly</strong> dominant color takes more than half of the total area. Now given an image of resolution M by N (for example, 800×600), you are supposed to point out the strictly dominant color.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains 2 positive numbers: M (≤800) and N (≤600) which are the resolutions of the image. Then N lines follow, each contains M digital colors in the range [0,224). It is guaranteed that the strictly dominant color exists for each input image. All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, simply print the dominant color in a line.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>5 3<br />
0 0 255 16777215 24<br />
24 24 0 0 24<br />
24 0 24 24 24</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>24</p>
</blockquote>
<p><strong> 思路：</strong> map&lt;int,int&gt; 集合映射颜色与出现次数，当次数超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>∗</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">M*N/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 时输出 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; arr;</span><br><span class="line">    <span class="type">int</span> half = m * n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp);</span><br><span class="line">            arr[temp]++;</span><br><span class="line">            <span class="keyword">if</span> (arr[temp] &gt; half)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, temp);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1071"><a class="markdownIt-Anchor" href="#1071"></a> 1071</h4>
<p><strong> 题目：Speech Patterns</strong></p>
<p>People often have a preference among synonyms of the same word. For example, some may prefer “the police”, while others may prefer “the cops”. Analyzing such patterns can help to narrow down a speaker’s identity, which is useful when validating, for example, whether it’s still the same person behind an online avatar.</p>
<p>Now given a paragraph of text sampled from someone’s speech, can you find the person’s most commonly used word?</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, there is one line of text no more than 1048576 characters in length, terminated by a carriage return <code>\n</code> . The input contains at least one alphanumerical character, i.e., one character from the set [<code>0-9 A-Z a-z</code> ].</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print in one line the most commonly occurring word in the input text, followed by a space and the number of times it has occurred in the input. If there are more than one such words, print the lexicographically smallest one. The word should be printed in all lower case. Here a “word” is defined as a continuous sequence of alphanumerical characters separated by non-alphanumerical characters or the line beginning/end.</p>
<p>Note that words are case <strong>insensitive</strong>.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>Can1: “Can a can can a can?  It can!”</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>can 5</p>
</blockquote>
<p><strong> 思路：</strong> 判断是否属于有效字符，遇到非法字符便截取之前有效的字符放到 map 集合中，注意：最后一位时，即便属于非法字符也要放入 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string str, temp;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; mcount;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalnum</span>(str[i])) <span class="comment">// 属于数字和字母 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isupper</span>(str[i]))</span><br><span class="line">            &#123; <span class="comment">// 大写转换为小写 </span></span><br><span class="line">                str[i] = <span class="built_in">tolower</span>(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            temp += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(str[i]) || i == str.<span class="built_in">length</span>() - <span class="number">1</span>) <span class="comment">// 非法字符或最后一位 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.<span class="built_in">length</span>() != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mcount[temp]++; <span class="comment">// 不为空便自增 </span></span><br><span class="line">            &#125;</span><br><span class="line">            temp.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mcount.<span class="built_in">begin</span>(); it != mcount.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = it-&gt;second;</span><br><span class="line">            ans = it-&gt;first; <span class="comment">// 遍历求次数最大，记录输出 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; max &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1022"><a class="markdownIt-Anchor" href="#1022"></a> 1022</h4>
<p><strong> 题目：Digital Library</strong></p>
<p>A Digital Library contains millions of books, stored according to their titles, authors, key words of their abstracts, publishers, and published years. Each book is assigned an unique 7-digit number as its ID. Given any query from a reader, you are supposed to output the resulting books, sorted in increasing order of their ID’s.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤104) which is the total number of books. Then N blocks follow, each contains the information of a book in 6 lines:</p>
<ul>
<li>
<p>Line #1: the 7-digit ID number;</p>
</li>
<li>
<p>Line #2: the book title – a string of no more than 80 characters;</p>
</li>
<li>
<p>Line #3: the author – a string of no more than 80 characters;</p>
</li>
<li>
<p>Line #4: the key words – each word is a string of no more than 10 characters without any white space, and the keywords are separated by exactly one space;</p>
</li>
<li>
<p>Line #5: the publisher – a string of no more than 80 characters;</p>
</li>
<li>
<p>Line #6: the published year – a 4-digit number which is in the range [1000, 3000].</p>
</li>
</ul>
<p>It is assumed that each book belongs to one author only, and contains no more than 5 key words; there are no more than 1000 distinct key words in total; and there are no more than 1000 distinct publishers.</p>
<p>After the book information, there is a line containing a positive integer M (≤1000) which is the number of user’s search queries. Then M lines follow, each in one of the formats shown below:</p>
<ul>
<li>
<p>1: a book title</p>
</li>
<li>
<p>2: name of an author</p>
</li>
<li>
<p>3: a key word</p>
</li>
<li>
<p>4: name of a publisher</p>
</li>
<li>
<p>5: a 4-digit number representing the year</p>
</li>
</ul>
<p><em>Output Specification:</em></p>
<p>For each query, first print the original query in a line, then output the resulting book ID’s in increasing order, each occupying a line. If no book is found, print <code>Not Found</code> instead.</p>
<p><em>Sample Input:</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1111111</span><br><span class="line">The Testing Book</span><br><span class="line">Yue Chen</span><br><span class="line">test code debug sort keywords</span><br><span class="line">ZUCS Print</span><br><span class="line">2011</span><br><span class="line">3333333</span><br><span class="line">Another Testing Book</span><br><span class="line">Yue Chen</span><br><span class="line">test code sort keywords</span><br><span class="line">ZUCS Print2</span><br><span class="line">2012</span><br><span class="line">2222222</span><br><span class="line">The Testing Book</span><br><span class="line">CYLL</span><br><span class="line">keywords debug book</span><br><span class="line">ZUCS Print2</span><br><span class="line">2011</span><br><span class="line">6</span><br><span class="line">1: The Testing Book</span><br><span class="line">2: Yue Chen</span><br><span class="line">3: keywords</span><br><span class="line">4: ZUCS Print</span><br><span class="line">5: 2011</span><br><span class="line">3: blablabla</span><br></pre></td></tr></table></figure>
<p><em>Sample Output:</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1: The Testing Book</span><br><span class="line">1111111</span><br><span class="line">2222222</span><br><span class="line">2: Yue Chen</span><br><span class="line">1111111</span><br><span class="line">3333333</span><br><span class="line">3: keywords</span><br><span class="line">1111111</span><br><span class="line">2222222</span><br><span class="line">3333333</span><br><span class="line">4: ZUCS Print</span><br><span class="line">1111111</span><br><span class="line">5: 2011</span><br><span class="line">1111111</span><br><span class="line">2222222</span><br><span class="line">3: blablabla</span><br><span class="line">Not Found</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong> 思路：</strong></p>
<ul>
<li>
<p> 对除了 id 之外的其他信息都建立一个 map&lt;string, set&gt;，把相应的 id 插入对应搜索词的 map 的集合里面，形成一个信息对应一个集合，集合里面是复合条件的书的 id</p>
</li>
<li>
<p> 因为对于输入的关键词（可以重复，算是书本对应的 tag 标签）没有给定关键词的个数，可以使用 while(cin &gt;&gt; s) 并且判断 c = getchar()，c 是否等于、n，如果是再退出循环 </p>
</li>
<li>
<p> 建立 query，通过传参的形式可以将不同的 map 名称统一化，先要判断 map.find() 和 m.end() 是否相等，如果不等再去遍历整个 map，输出所有满足条件的 id，如果相等就说明不存在这个搜索词对应的 id，那么就要输出 Not Found</p>
</li>
<li>
<p> 传参一定要用引用，否则最后一组数据可能会超时 </p>
</li>
</ul>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;string, set&lt;<span class="type">int</span>&gt;&gt; title, author, key, pub, year; <span class="comment">// 每类信息建立一个 map 集合映射 ID</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(map&lt;string, set&lt;<span class="type">int</span>&gt;&gt; &amp;m, string &amp;str)</span> <span class="comment">// 查询方法使用引用的形式，防止大数据超市 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m.<span class="built_in">find</span>(str) != m.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = m[str].<span class="built_in">begin</span>(); it != m[str].<span class="built_in">end</span>(); it++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%07d\n&quot;</span>, *it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Not Found\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, id, num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    string ttitle, tauthor, tkey, tpub, tyear;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;id);</span><br><span class="line">        <span class="built_in">getline</span>(cin, ttitle);</span><br><span class="line">        title[ttitle].<span class="built_in">insert</span>(id);</span><br><span class="line">        <span class="built_in">getline</span>(cin, tauthor);</span><br><span class="line">        author[tauthor].<span class="built_in">insert</span>(id);</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; tkey) <span class="comment">// 关键字使用分隔输入的形式 </span></span><br><span class="line">        &#123;</span><br><span class="line">            key[tkey].<span class="built_in">insert</span>(id);</span><br><span class="line">            <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">getline</span>(cin, tpub);</span><br><span class="line">        pub[tpub].<span class="built_in">insert</span>(id);</span><br><span class="line">        <span class="built_in">getline</span>(cin, tyear);</span><br><span class="line">        year[tyear].<span class="built_in">insert</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d: &quot;</span>, &amp;num);</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="built_in">getline</span>(cin, temp);</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; temp &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) <span class="comment">// 根据查询类型判断方法引用的集合 </span></span><br><span class="line">            <span class="built_in">query</span>(title, temp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">query</span>(author, temp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">query</span>(key, temp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">4</span>)</span><br><span class="line">            <span class="built_in">query</span>(pub, temp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">query</span>(year, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stack"><a class="markdownIt-Anchor" href="#stack"></a> stack</h2>
<h4 id="1051"><a class="markdownIt-Anchor" href="#1051"></a> 1051</h4>
<p><strong> 题目：Pop Sequence</strong></p>
<p>Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>5 7 5<br />
1 2 3 4 5 6 7<br />
3 2 1 7 5 6 4<br />
7 6 5 4 3 2 1<br />
5 6 4 3 7 2 1<br />
1 7 6 5 4 3 2</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>YES<br />
NO<br />
YES<br />
NO</p>
</blockquote>
<p><strong> 思路：</strong> 使用 stack 模板模拟入栈，每放入一个元素后判断其与输出序列要输出的元素是否相同，相同后出栈，位数后移；<br />
有两种情况表示出栈顺序不对：1、当前入栈的元素超过栈的容量；2、模拟完成后栈不为空 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m, n, k, arr[<span class="number">1001</span>]; <span class="comment">// 保存序列 </span></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span> (k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) <span class="comment">// 将栈清空 </span></span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; arr[i]; <span class="comment">// 保存序列 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> current = <span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">size</span>() &gt; m) <span class="comment">// 当前个数超过容量 </span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == arr[current]) <span class="comment">// 每放入一个元素判断出栈 </span></span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                current++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">empty</span>() &amp;&amp; flag) <span class="comment">// 模拟完成后栈空和容量未超表示正确 </span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> queue</h2>
<h4 id="1056"><a class="markdownIt-Anchor" href="#1056"></a> 1056</h4>
<p><strong> 题目：Mice and Rice</strong></p>
<p><strong>Mice and Rice</strong> is the name of a programming contest in which each programmer must write a piece of code to control the movements of a mouse in a given map. The goal of each mouse is to eat as much rice as possible in order to become a FatMouse.</p>
<p>First the playing order is randomly decided for NP programmers. Then every NG programmers are grouped in a match. The fattest mouse in a group wins and enters the next turn. All the losers in this turn are ranked the same. Every NG winners are then grouped in the next match until a final winner is determined.</p>
<p>For the sake of simplicity, assume that the weight of each mouse is fixed once the programmer submits his/her code. Given the weights of all the mice and the initial playing order, you are supposed to output the ranks for the programmers.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains 2 positive integers: NP and NG (≤1000), the number of programmers and the maximum number of mice in a group, respectively. If there are less than NG mice at the end of the player’s list, then all the mice left will be put into the last group. The second line contains NP distinct non-negative numbers Wi (i=0,⋯,NP−1) where each Wi is the weight of the i-th mouse respectively. The third line gives the initial playing order which is a permutation of 0,⋯,NP−1 (assume that the programmers are numbered from 0 to NP−1). All the numbers in a line are separated by a space.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, print the final ranks in a line. The i-th number is the rank of the i-th programmer, and all the numbers must be separated by a space, with no extra space at the end of the line.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>11 3<br />
25 18 0 46 37 3 19 22 57 56 10<br />
6 0 8 7 10 5 9 1 4 2 3</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>5 5 5 2 5 5 5 3 1 3 5</p>
</blockquote>
<p><strong> 思路：</strong> 根据输入重量时的顺序作为编号，保存到结构体的 weight 中，并将排列规则放入队列中，分组进行比较之后将每组的获胜者放入队列最后，判断一个便出队一个，当进行一轮的比较之后，队列后的就是下一轮的排列顺序，继续分组重复操作；每轮中个人的排名就是当前轮的组数 +1，进入下一轮的人员继续更新排名直到只剩一人时退出循环 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mouse</span> <span class="comment">// 建立老鼠结构体 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> weight, rank;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mouse mouse[<span class="number">1001</span>];</span><br><span class="line">    <span class="type">int</span> Np, Ng;</span><br><span class="line">    cin &gt;&gt; Np &gt;&gt; Ng;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Np; i++) <span class="comment">// 按输入顺序为其编号 </span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; mouse[i].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line">    <span class="type">int</span> order;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Np; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; order;</span><br><span class="line">        qu.<span class="built_in">push</span>(order); <span class="comment">// 将排列顺序放入队列中 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp = Np, group;  <span class="comment">//temp 表示此轮的人员，group 表示分成几组 </span></span><br><span class="line">    <span class="keyword">while</span> (qu.<span class="built_in">size</span>() != <span class="number">1</span>) <span class="comment">// 角逐到只剩一个 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp % Ng == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            group = temp / Ng;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            group = temp / Ng + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; group; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = qu.<span class="built_in">front</span>(); <span class="comment">//k 表示小组的胜出者 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Ng; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i * Ng + j &gt;= temp) <span class="comment">// 存在最后一组数量不够的情况 </span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> front = qu.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span> (mouse[front].weight &gt; mouse[k].weight)</span><br><span class="line">                &#123;</span><br><span class="line">                    k = front;</span><br><span class="line">                &#125;</span><br><span class="line">                mouse[front].rank = group + <span class="number">1</span>; <span class="comment">// 每次都更新排名 </span></span><br><span class="line">                qu.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            qu.<span class="built_in">push</span>(k); <span class="comment">// 每组最大的放到队列中进入下一轮 </span></span><br><span class="line">        &#125;</span><br><span class="line">        temp = group; <span class="comment">// 新一轮的成员数就是上一轮的组数 </span></span><br><span class="line">    &#125;</span><br><span class="line">    mouse[qu.<span class="built_in">front</span>()].rank = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Np; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; mouse[i].rank;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; Np - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="linklist"><a class="markdownIt-Anchor" href="#linklist"></a> linklist</h2>
<h4 id="1074"><a class="markdownIt-Anchor" href="#1074"></a> 1074</h4>
<p><strong> 题目：Reversing Linked List</strong></p>
<p>Given a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K=3, then you must output 3→2→1→6→5→4; if K=4, you must output 4→3→2→1→5→6.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N (≤105) which is the total number of nodes, and a positive K (≤N) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>
<p>Then N lines follow, each describes a node in the format:</p>
<blockquote>
<p>Address Data Next</p>
</blockquote>
<p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p>
<p><em>Output Specification:</em></p>
<p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>00100 6 4<br />
00000 4 99999<br />
00100 1 12309<br />
68237 6 -1<br />
33218 3 00000<br />
99999 5 68237<br />
12309 2 33218</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>00000 4 33218<br />
33218 3 12309<br />
12309 2 00100<br />
00100 1 99999<br />
99999 5 68237<br />
68237 6 -1</p>
</blockquote>
<p><strong> 思路：</strong> 建立链表的节点结构体，根据 next 的数据为其排序规则从小到大赋值，根据规则排序，就可以模拟链表的连接；处理完链表后根据分组的单组容量构建输出规则进行输出 </p>
<p>**tips：** 整数型不管前导零有多少，始终存储有效数组，如：输入 00100，存储为 100</p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> edge = <span class="number">100010</span>; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> <span class="comment">// 定义链表的结点结构体 </span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> address, data, next;</span><br><span class="line">    <span class="type">int</span> order; <span class="comment">// 定义位置，后续排序 </span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> <span class="comment">// 排序规则 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.order &lt; b.order;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Node node[edge];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edge; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        node[i].order = edge; <span class="comment">// 将所有的规则定义为一个较大值 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> begin, n, k;</span><br><span class="line">    cin &gt;&gt; begin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> address;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 读入数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; address;</span><br><span class="line">        cin &gt;&gt; node[address].data &gt;&gt; node[address].next;</span><br><span class="line">        node[address].address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (begin != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node[begin].order = count++; <span class="comment">// 将规则的先后顺序定义 </span></span><br><span class="line">        begin = node[begin].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(node, node + edge, cmp);       <span class="comment">// 排序连接起来 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count / k; i++) <span class="comment">// 分块进行输出 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = (i + <span class="number">1</span>) * k - <span class="number">1</span>; j &gt; i * k; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>, node[j].address, node[j].data, node[j - <span class="number">1</span>].address);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一组的最后一个数据进行判断输出 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%05d %d &quot;</span>, node[i * k].address, node[i * k].data); <span class="comment">// 输出数据 </span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; count / k - <span class="number">1</span>)                                     <span class="comment">// 如果不是最后一组 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%05d\n&quot;</span>, node[(i + <span class="number">2</span>) * k - <span class="number">1</span>].address); <span class="comment">// 输出越组后的最后一个（倒序的第一个）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (count % k == <span class="number">0</span>) <span class="comment">// 如果能整分组，输出 -1</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 不能整分 </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%05d\n&quot;</span>, node[(i + <span class="number">1</span>) * k].address); <span class="comment">// 不能分组的第一个的地址 </span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = count / k * k; l &lt; count; l++)  <span class="comment">// 将其照常输出即可 </span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%05d %d &quot;</span>, node[l].address, node[l].data);</span><br><span class="line">                    <span class="keyword">if</span> (l &lt; count - <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%05d\n&quot;</span>, node[l + <span class="number">1</span>].address);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1032"><a class="markdownIt-Anchor" href="#1032"></a> 1032</h4>
<p>** 题目：Sharing **</p>
<p>To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example, <code>loading</code> and <code>being</code> are stored as showed in Figure 1.</p>
<p>You are supposed to find the starting position of the common suffix (e.g. the position of <code>i</code> in Figure 1).</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains two addresses of nodes and a positive <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, where the two addresses are the addresses of the first nodes of the two words, and N is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented by −1.</p>
<p>Then N lines follow, each describes a node in the format:</p>
<p>Address Data Next</p>
<p>where<code>Address</code> is the position of the node, <code>Data</code> is the letter contained by this node which is an English letter chosen from {a-z, A-Z}, and <code>Next</code> is the position of the next node.</p>
<p><em>Output Specification:</em></p>
<p>For each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, output <code>-1</code> instead.</p>
<p><em>Sample Input 1:</em></p>
<blockquote>
<p>11111 22222 9<br />
67890 i 00002<br />
00010 a 12345<br />
00003 g -1<br />
12345 D 67890<br />
00002 n 00003<br />
22222 B 23456<br />
11111 L 00001<br />
23456 e 67890<br />
00001 o 00010</p>
</blockquote>
<p><em>Sample Output 1:</em></p>
<blockquote>
<p>67890</p>
</blockquote>
<p><strong> 思路：</strong> 建立一个范围足够的静态链表，遍历第一条链表，将出现过的节点标记，在遍历第二条时出现标记过的节点则输出下标 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> edge = <span class="number">100001</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> <span class="comment">// 定义结构体 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">    <span class="type">bool</span> flag; <span class="comment">// 对第一条链表的出现的节点赋予正值 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node node[edge];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edge; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        node[i].flag = <span class="literal">false</span>; <span class="comment">// 将每一个节点初始设置为未出现 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> begin1, begin2, total;</span><br><span class="line">    cin &gt;&gt; begin1 &gt;&gt; begin2 &gt;&gt; total;</span><br><span class="line">    <span class="type">int</span> address, next;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; total; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; address &gt;&gt; data &gt;&gt; next;</span><br><span class="line">        node[address].data = data;</span><br><span class="line">        node[address].next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (begin1 != <span class="number">-1</span>) <span class="comment">// 遍历第一条，对每一个节点做标记 </span></span><br><span class="line">    &#123;</span><br><span class="line">        node[begin1].flag = <span class="literal">true</span>;</span><br><span class="line">        begin1 = node[begin1].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (begin2 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node[begin2].flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 在第二条中出现被标记的节点跳出 </span></span><br><span class="line">        &#125;</span><br><span class="line">        begin2 = node[begin2].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (begin2 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%05d&quot;</span>, begin2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1052"><a class="markdownIt-Anchor" href="#1052"></a> 1052</h4>
<p><strong> 题目：Linked List Sorting</strong></p>
<p>A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer <code>key</code> and a <code>Next</code> pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains a positive N (&lt;105) and an address of the head node, where N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by −1.</p>
<p>Then N lines follow, each describes a node in the format:</p>
<p>Address Key Next</p>
<p>where <code>Address</code> is the address of the node in memory, <code>Key</code> is an integer in [−105, 105], and <code>Next</code> is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node.</p>
<p><em>Output Specification:</em></p>
<p>For each test case, the output format is the same as that of the input, where N is the total number of nodes in the list and all the nodes must be sorted order.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>5 00001<br />
11111 100 -1<br />
00001 0 22222<br />
33333 100000 11111<br />
12345 -1 33333<br />
22222 1000 12345</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>5 12345<br />
12345 -1 00001<br />
00001 0 11111<br />
11111 100 22222<br />
22222 1000 33333<br />
33333 100000 -1</p>
</blockquote>
<p><strong> 思路：</strong> 题目要求只输出能够连接的节点，所以对节点结构体定义同一个标记变量，将有效的节点根据 data 的大小进行升序排序 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> edge = <span class="number">100001</span>; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> address, data, next;</span><br><span class="line">    <span class="type">bool</span> flag; <span class="comment">// 存在无法连接的节点，创建标记属性 </span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> <span class="comment">// 根据数据大小进行排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.flag == <span class="literal">false</span> || b.flag == <span class="literal">false</span>) <span class="comment">// 只要 a 或 b 有一个不符合条件，就将其放置到最后 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.flag &gt; b.flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.data &lt; b.data; <span class="comment">// 其他根据数据大小进行排序 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Node node[edge];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edge; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        node[i].flag = <span class="literal">false</span>; <span class="comment">// 先将所有节点的标记置为 false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> N, begin;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; begin;</span><br><span class="line">    <span class="type">int</span> address;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; address;</span><br><span class="line">        cin &gt;&gt; node[address].data &gt;&gt; node[address].next;</span><br><span class="line">        node[address].address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (begin != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node[begin].flag = <span class="literal">true</span>; <span class="comment">// 将能够连接的节点标记为 true</span></span><br><span class="line">        count++;                 <span class="comment">// 记录有效节点的个数 </span></span><br><span class="line">        begin = node[begin].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="comment">// 没有有效节点直接进行输出 </span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0 -1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(node, node + edge, cmp);                <span class="comment">// 进行排序 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %05d\n&quot;</span>, count, node[<span class="number">0</span>].address); <span class="comment">// 输出有效节点的个数和起始位置 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; count - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>, node[i].address, node[i].data, node[i + <span class="number">1</span>].address);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1\n&quot;</span>, node[i].address, node[i].data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1097"><a class="markdownIt-Anchor" href="#1097"></a> 1097</h4>
<p><strong> 题目：Deduplication on a Linked List</strong></p>
<p>Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K, only the first node of which the value or absolute value of its key equals K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L being 21→-15→-15→-7→15, you must output 21→-15→-7, and the removed list -15→15.</p>
<p><em>Input Specification:</em></p>
<p>Each input file contains one test case. For each case, the first line contains the address of the first node, and a positive N (≤105) which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1.</p>
<p>Then N lines follow, each describes a node in the format:</p>
<p>Address Key Next</p>
<p>where <code>Address</code> is the position of the node, <code>Key</code> is an integer of which absolute value is no more than 104, and <code>Next</code> is the position of the next node.</p>
<p><em>Output Specification:</em></p>
<p>For each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input.</p>
<p><em>Sample Input:</em></p>
<blockquote>
<p>00100 5<br />
99999 -7 87654<br />
23854 -15 00000<br />
87654 15 -1<br />
00000 -15 99999<br />
00100 21 23854</p>
</blockquote>
<p><em>Sample Output:</em></p>
<blockquote>
<p>00100 21 23854<br />
23854 -15 99999<br />
99999 -7 -1<br />
00000 -15 87654<br />
87654 15 -1</p>
</blockquote>
<p><strong> 思路：</strong> 将数据绝对值相同的节点按照输入顺序放置到最后分别控制有效位和无效位单独输出，排序的标记变量初始置为数据规模的两倍放置中间存放无效位时溢出，输出时注意两类的最后一个节点的 next 为 -1</p>
<p><strong> 代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NODE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> address, key, next, num = <span class="number">2</span> * maxn; <span class="comment">//num 让其数时数据规模的两倍，中间留出充足的空间进行分类放置 </span></span><br><span class="line">&#125; node[maxn];</span><br><span class="line"><span class="type">bool</span> exist[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(NODE a, NODE b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num &lt; b.num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> begin, n, cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>, a; <span class="comment">//cnt1 表示有效的，cnt2 表示被删除的 </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;begin, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;node[a].key, &amp;node[a].next);</span><br><span class="line">        node[a].address = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = begin; i != <span class="number">-1</span>; i = node[i].next) <span class="comment">// 遍历 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (exist[<span class="built_in">abs</span>(node[i].key)] == <span class="literal">false</span>) <span class="comment">// 如果这个数的绝对值没有出现过 </span></span><br><span class="line">        &#123;</span><br><span class="line">            exist[<span class="built_in">abs</span>(node[i].key)] = <span class="literal">true</span>; <span class="comment">// 表示出现 </span></span><br><span class="line">            node[i].num = cnt1++;           <span class="comment">// 为其赋予第几个有效位 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node[i].num = maxn + cnt2++; <span class="comment">// 为其赋予第几个无效位 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(node, node + maxn, cmp);</span><br><span class="line">    <span class="type">int</span> cnt = cnt1 + cnt2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != cnt1 - <span class="number">1</span> &amp;&amp; i != cnt - <span class="number">1</span>) <span class="comment">// 不是两类的最后一个节点 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>, node[i].address, node[i].key, node[i + <span class="number">1</span>].address);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1\n&quot;</span>, node[i].address, node[i].key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 刷题实用方法总结</title>
    <url>/summarize-java_utility/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p>Java 刷算法时的常用 API 以及一些奇技淫巧，当时参加蓝桥杯总结的，隔一段时间再刷题的时候总会拿出来看看</p>
<span id="more"></span>
<h2 id="java 语法操作"><a class="markdownIt-Anchor" href="#java 语法操作"></a> Java 语法操作</h2>
<h3 id="输入 - 输出"><a class="markdownIt-Anchor" href="# 输入 - 输出"></a> 输入 输出</h3>
<p>对字符串的获取可以采用 <code>next()</code> 和 <code>nextline()</code> ，用 <code>hasNext()</code> 或 <code>hasNextline()</code> 判断是否还有数据输入<br />
<code>hasNext()</code> 或 <code>hasNextline()</code> 在 while 循环中可能没啥区别，但 <code>next()</code> 和 <code>nextline()</code> 却大有不同<br />
<code>next()</code> 不能读取空格，换言之，读取到有效字符之后遇到空格就会停止，但 <code>nextline()</code> 以 Enter 结束，能存储对应格式的任何字符</p>
<h4 id="多行输入"><a class="markdownIt-Anchor" href="# 多行输入"></a> 多行输入</h4>
<p>存在输入多行，且每行输入的字符或数字个数不定的情况，这就需要将 <code>hasnext()</code> 和 <code>nextline()</code> 搭配使用<br />
具体方法是实例化两个 <code>Scanner</code> 对象 former 和 latter，其中 latter 的参数是 former 的 <code>nextline()</code> ，然后使用 <code>hasnext()</code> 判断获取到的行是否存在下一个输入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">scanner.nextLine();<span class="comment">// 抵消 N 后面的换行符</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(scanner.nextLine());<span class="comment">// 获取每行</span></span><br><span class="line">    <span class="keyword">while</span> (input.hasNext()) &#123;<span class="comment">// 遍历每行数据</span></span><br><span class="line">        arr[count++] = input.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="输入字符"><a class="markdownIt-Anchor" href="# 输入字符"></a> 输入字符</h4>
<p>Java 中不提供 <code>nextChar()</code> 的方法，但可以使用<code>next().charAt(0)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">char c= sc.next().charAt(0);</span><br><span class="line">// 将不空格的一串字符按数组存储：`sc.next().toCharArray();`</span><br><span class="line"></span><br><span class="line">int n = sc.nextInt();</span><br><span class="line">int m = sc.nextInt();</span><br><span class="line">char[][] arr = new char[n][m];</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    arr[i] = sc.next().toCharArray();// 读入字符串拆分成字符数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式化输出"><a class="markdownIt-Anchor" href="# 格式化输出"></a> 格式化输出</h4>
<p><code>String.format()</code> 和 <code>System.out.printf()</code> 可以进行格式化的输出效果<br />
<code>%4d</code> 和 <code>%-4d</code> 的区别： <code>%4d</code> 是靠右输出四位，不足用空格补齐； <code>%-4d</code> 是靠左输出</p>
<p>输出 N 位小数，可以使用 <code>DecimalFormat</code> 对格式进行定义；或者使用 <code>String.format(格式, 浮点变量)</code> 直接打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">float</span> f= (<span class="type">float</span>) <span class="number">3.234567</span>;</span><br><span class="line">    <span class="comment">// 正常输出</span></span><br><span class="line">    System.out.println(f);</span><br><span class="line">    <span class="comment">// 采用类</span></span><br><span class="line">    DecimalFormat df=<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#0.00&quot;</span>);</span><br><span class="line">    System.out.println(df.format(f));</span><br><span class="line">    <span class="comment">// 模仿 C 语言</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;%.2f\n&quot;</span>,f);<span class="comment">//printf 支持和 C 语言相似的格式化输出</span></span><br><span class="line">    <span class="comment">// 转换格式</span></span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;%.2f&quot;</span>,f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：2.35  2.35</p>
</blockquote>
<h3 id="循环的注意"><a class="markdownIt-Anchor" href="# 循环的注意"></a> 循环的注意</h3>
<h4 id="判断引用型"><a class="markdownIt-Anchor" href="# 判断引用型"></a> 判断引用型</h4>
<p>引用型在循环中的判断不能直接使用 <code>==</code> , 因为即便内容相等的两个数也有可能被引用的地址不相同，而 <code>==</code> 比较的就是引用的地址如下面这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line"><span class="comment">// 此时的 str1 和 str2 在内容是是相等的但进行等值判断是却会进行不等的运算</span></span><br></pre></td></tr></table></figure>
<p>对引用型的数据统一使用 <code>equals()</code> 的方式进行判断： <code>if(s1.equals(s2))&#123;···&#125;</code> 但注意如果 <code>s1</code> 的值是空的时候也会报错<br />
所以可以使用 <code>if(s1!=null &amp;&amp; s1.equals(s2))&#123;···&#125;</code> 进行判断</p>
<h4 id="switch 的用法"><a class="markdownIt-Anchor" href="#switch 的用法"></a> switch 的用法</h4>
<p>Java 中的 switch 循环支持字符串的匹配，但不要忘记每个语句后面加 <code>break; </code></p>
<p>Java12 之后的 switch 语句中支持使用 <code>-&gt;</code> 符号取代 <code>:</code> 进行自动跳出的 case 语句，如果一个 case 中要运行多个语句可以用 <code>&#123;&#125;</code> 括起来</p>
<h3 id="数组的操作"><a class="markdownIt-Anchor" href="# 数组的操作"></a> 数组的操作</h3>
<p>初始化数组可以使用 <code>Arrays.fill()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span>[] arrPrimer = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">10000</span>];</span><br><span class="line">Arrays.fill(arrPrimer, Boolean.TRUE);</span><br></pre></td></tr></table></figure>
<h4 id="遍历数组"><a class="markdownIt-Anchor" href="# 遍历数组"></a> 遍历数组</h4>
<p>数组的遍历有三种方式： <code>for()</code> 循环搭配索引、 <code>for each</code> 迭代每个元素(但无法获取索引)、转换成字符串输出<br />
Java 标准库提供的 <code>Arrays.toString()</code> 方法进行将整个数组转换为字符串直接打印输出，二维数组使用： <code>Arrays.deepToString()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：[1, 2, 3, 4, 5, 6, 7]</p>
</blockquote>
<h4 id="数组排序"><a class="markdownIt-Anchor" href="# 数组排序"></a> 数组排序</h4>
<p>使用 Arrays 中的 sort 方法可以对数组进行快速排序；若要实现降序排序可以使用 <code>Collections.reverseOrder()</code> 方法(仅对类起作用)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">Arrays.sort(arr, Collections.reverseOrder());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m : arr)</span><br><span class="line">    System.out.print(m + <span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="拷贝数组"><a class="markdownIt-Anchor" href="# 拷贝数组"></a> 拷贝数组</h4>
<p>可以直接使用数组自身的 <code>.clone()</code> 方法，因为数组是引用型，将数组放入方法或者类中很容易导致内外部操作互相影响，所以 <code>.clone()</code> 方法在这种场景下常用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">99</span>, <span class="number">345</span>, <span class="number">234</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] copy = arr.clone();</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">System.out.println(Arrays.toString(copy));</span><br></pre></td></tr></table></figure>
<p>系统提供的数组拷贝方法： <code>System.arraycopy(Object a, int begin_a, Object b, int begin_b, int length); </code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    System.arraycopy(a,<span class="number">0</span>,b,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n:b)</span><br><span class="line">        System.out.print(n+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;<span class="comment">// 这种方法可以进行自定义长度的拷贝</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：1 2 3 0 0 0 0 0 0 0</p>
</blockquote>
<p>将一个数组的一部分拷贝到另一数组中可以使用 <code>Arrays.copyOf(object, length); </code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[]= Arrays.copyOf(a,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n:b)</span><br><span class="line">        System.out.print(n+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：1 2 3</p>
</blockquote>
<h3 id="arrays 类"><a class="markdownIt-Anchor" href="#arrays 类"></a> Arrays 类</h3>
<p>Arrays 类提供很多使用的方法，常见的如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.asList(Object[] a) <span class="comment">// 数组转换成 List </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(Object[] a, Object key)</span> <span class="comment">// 二分查找 (仅支持有序)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object[] a, Object[] a2)</span>  <span class="comment">// 判断两数组内容是否一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(Object[] a, Object val)</span>   <span class="comment">// 在 a 中所有位置填充 val</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(Object[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, Object val)</span></span><br><span class="line"><span class="comment">// 在[fromIndex,toIndex) 中填充 val</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其提供了三种排序比较方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Object[] a)</span> <span class="comment">// 改进的快速排序（升序）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Object[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> <span class="comment">// 对 [fromIndex,toIndex) 升序排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> <span class="comment">// 自定义比较器排序</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a class="markdownIt-Anchor" href="# 字符串"></a> 字符串</h3>
<h4 id="character 类"><a class="markdownIt-Anchor" href="#character 类"></a> Character 类</h4>
<p>主要应用其中的字符类型判断函数，可以节约时间</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Character.isDigit(char c)</code></td>
<td style="text-align:center">判断字符 c 是否是数字字符</td>
</tr>
<tr>
<td style="text-align:center"><code>Character.isLowerCase(char c)</code></td>
<td style="text-align:center">判断 c 是否是小写字母字符</td>
</tr>
<tr>
<td style="text-align:center"><code>Character.isUpperCase(char c)</code></td>
<td style="text-align:center">判断 c 是否是大写字母字符</td>
</tr>
<tr>
<td style="text-align:center"><code>Character.isLetterOrDigit(char c)</code></td>
<td style="text-align:center">判断 c 是否是字母或数字字符</td>
</tr>
</tbody>
</table>
<h4 id="string 类"><a class="markdownIt-Anchor" href="#string 类"></a> String 类</h4>
<p>存入两个字符相同的 string 型时，两者的地址也相同(将后创建的地址指向前者，节约内存)；但是 new String 的两个不同对象的内容即便相同地址也不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String a=<span class="string">&quot;asd&quot;</span>;</span><br><span class="line">    String b=<span class="string">&quot;asd&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span> t=a==b;</span><br><span class="line">    String c=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;iop&quot;</span>);</span><br><span class="line">    String d=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;iop&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> y=c==d;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">    System.out.println(y);</span><br><span class="line">&#125;<span class="comment">//== 和！= 是用来判断 string 对象地址是否相同的</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：<br />
true<br />
false</p>
</blockquote>
<p>判断 string 对象是否相同用自带的 <code>.equals()</code> 方法，同时还提供一种忽略大小写的判断方法 <code>.equalsIgnoreCase()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;asd&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;asd&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.equals(b)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;!=&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(a.equalsIgnoreCase(b.toUpperCase()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：==<br />
true</p>
</blockquote>
<p>要想遍历 string 的字符内容，需要将其转换为字符数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;asd&quot;</span>;</span><br><span class="line">    <span class="type">char</span> arr[] = a.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> n : arr)</span><br><span class="line">        System.out.print(n + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：a s d</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>contains()</code></td>
<td>是否包含相应的字符或子串</td>
</tr>
<tr>
<td><code>trim()</code></td>
<td>移除首位空白字符(\t, \r, \n)</td>
</tr>
<tr>
<td><code>isEmpty()</code></td>
<td>是否为空</td>
</tr>
<tr>
<td><code>isBlank()</code></td>
<td>是否为空白字符串</td>
</tr>
<tr>
<td><code>replace()</code></td>
<td>替换字符(串)</td>
</tr>
<tr>
<td><code>join(&quot;?&quot;,arr)</code></td>
<td>用指定字符连接字符或字符串</td>
</tr>
<tr>
<td><code>split(&quot;?&quot;)</code></td>
<td>分割字符串</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;asdeGHAasDeFg&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);<span class="comment">// 字符串转换为字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指定字符的查找</span></span><br><span class="line">    s.indexOf(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">    s.indexOf(<span class="string">&#x27;s&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">    s.lastIndexOf(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">    s.lastIndexOf(<span class="string">&#x27;s&#x27;</span>, <span class="number">6</span>);</span><br><span class="line">    String[] ss = s.split(<span class="string">&quot;s&quot;</span>);<span class="comment">// 将字符串按指定字符分割</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> s.substring(<span class="number">2</span>, <span class="number">5</span>);<span class="comment">// 截取 start 到 end 的子串，左闭右开</span></span><br><span class="line">    <span class="type">char</span>[] cs = s.toCharArray();<span class="comment">// 字符串转换为字符数组</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> s.toLowerCase();<span class="comment">// 将字符串转换为小写</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sToL</span> <span class="operator">=</span> s.toUpperCase();<span class="comment">// 将字符串转换为大写</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sToU</span> <span class="operator">=</span> String.valueOf(<span class="number">123</span>);</span><br><span class="line">    <span class="comment">// 将指定数据转换为字符串，也可加参数 radio 将其转换为 radio 进制的字符串</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="stringbuilder"><a class="markdownIt-Anchor" href="#stringbuilder"></a> StringBuilder</h4>
<p>StringBuilder 对象被当作是一个包含字符序列的变长数组，在需要频繁更改字符串的场景下常用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;123&quot;</span>);<span class="comment">// 每次返回添加后的自身，因此可以进行链式操作</span></span><br><span class="line">    sb.append(<span class="string">&quot;456&quot;</span>).append(<span class="string">&quot;789&quot;</span>);</span><br><span class="line">    sb.reverse();<span class="comment">// 反转</span></span><br><span class="line">    sb.delete(<span class="number">3</span>, <span class="number">7</span>);<span class="comment">// 删除索引从 a 开始到 b 的所有字符（左闭右开）</span></span><br><span class="line">    sb.deleteCharAt(<span class="number">3</span>);<span class="comment">// 删除索引为 a 的字符；</span></span><br><span class="line">    sb.insert(<span class="number">4</span>, <span class="string">&quot;string&quot;</span>);<span class="comment">// 参数字符插入到指定位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="stringjoiner"><a class="markdownIt-Anchor" href="#stringjoiner"></a> StringJoiner</h4>
<p>在 String 中有 <code>join</code> 方法进行使用特定字符连接字符串，但如果数据太多就不实用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot; +++ &quot;</span>, <span class="string">&quot;Hello: &quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化时参数默认是连接符，多个参数格式为(连接符，开头，结束)</span></span><br><span class="line">    String[] strArr = &#123;<span class="string">&quot;Aidan&quot;</span>, <span class="string">&quot;Amy&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Jhon&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (String each : strArr) &#123;</span><br><span class="line">        sj.add(each);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：Hello: Aidan +++ Amy +++ Bob +++ Jack +++ Jhon!</p>
</blockquote>
<h3 id="边界处理"><a class="markdownIt-Anchor" href="# 边界处理"></a> 边界处理</h3>
<p>数组判空： <code>if(arr == null|| arr.length == 0)</code></p>
<p>二维数组判空： <code>if(arr == null || arr.length == 0 || arr[0].length == 0)</code></p>
<p>字符串判空： <code>if(str == null || str.equals(&quot;&quot;))</code></p>
<p>所有封装类的最大最小值都有其存在的方法： <code>Integer n=Integer. MAX_VALUE; </code></p>
<p>浮点数的判断条件，因为浮点数的值往往没法准确进行显示，所以对数据较为精确的题目的判断条件要使用差的绝对值小于某个临界值的形式： <code>Math.abs(x-0.1)&lt;0.00001</code></p>
<p>有些数据的处理还要使用扩大 1000(甚至更大)倍转换成 <code>Long Long</code> 形式，然后在输出的时候除以之前扩大的倍数</p>
<h3 id="格式转换"><a class="markdownIt-Anchor" href="# 格式转换"></a> 格式转换</h3>
<p>程序运算时会进行自动转型，但这是由下向上转型，所有有些时候需要进行强制转型<br />
最简单直接的是在变量前加(目标类型)，此方法只用于基本的数据类型，不支持 String 类型</p>
<p>String 和其他基本数据类型的转换<br />
可以使用 <code>toString</code> 将其他数据类型转换为 String 类，但这种方法只对包装类起作用(如：Integer)<br />
使用 String 自带的 valueOf()方法，支持将基本的数据类型转换<br />
而将 String 转换为其他，可以用自带类的.parseXXX(string)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a=<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line">String s1=a.toString();<span class="comment">// 类自带的 toString()方法 </span></span><br><span class="line"><span class="type">int</span> i=<span class="number">99</span>;</span><br><span class="line">String s2=String.valueOf(i);<span class="comment">//String 自带的 valueOf() 方法 </span></span><br><span class="line">Integer b=Integer.parseInt(s2);<span class="comment">// 每个封装类类都有.parseXXX(String s) 方法</span></span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a class="markdownIt-Anchor" href="# 快速排序"></a> 快速排序</h3>
<p>实用 Arrays 中的 sort 方法可以对数组进行快速排序<br />
若要实现降序排序可以使用 <code>Collections.reverseOrder()</code> 方法(数组必须为 Integer 类)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">99</span>, <span class="number">345</span>, <span class="number">234</span>, <span class="number">6</span>&#125;;</span><br><span class="line">Arrays.sort(arr);<span class="comment">// 默认排序</span></span><br><span class="line">Arrays.sort(arr, Collections.reverseOrder());<span class="comment">// 反转</span></span><br></pre></td></tr></table></figure>
<h4 id="比较器"><a class="markdownIt-Anchor" href="# 比较器"></a> 比较器</h4>
<p>使用 Comparator 类定义的比较器可以实现自定义排序<br />
排序自定义类 (结构体) 时也可以使用 comparable 接口在类中直接覆写方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util. Arrays; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 比较器排序</span></span><br><span class="line"><span class="comment">        Arrays.sort(arr, new Comparator&lt;Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public int compare(Integer o1, Integer o2) &#123;</span></span><br><span class="line"><span class="comment">                return o2-o1;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        Person[] arr = <span class="keyword">new</span> <span class="title class_">Person</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">12</span>, <span class="string">&quot;Aidan&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">6</span>, <span class="string">&quot;John&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">12</span>, <span class="string">&quot;Bob&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">17</span>, <span class="string">&quot;Amy&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">15</span>, <span class="string">&quot;Dave&quot;</span>),&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 比较器自定义排序类</span></span><br><span class="line"><span class="comment">        Arrays.sort(arr, new Comparator&lt;Person&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public int compare(Person o1, Person o2) &#123;</span></span><br><span class="line"><span class="comment">                if (o1.age != o2.age) &#123;</span></span><br><span class="line"><span class="comment">                    return o1.age - o2.age;</span></span><br><span class="line"><span class="comment">                &#125; else &#123;</span></span><br><span class="line"><span class="comment">                    return o1.name.compareTo(o2.name);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line">        Arrays.sort(arr, (o1, o2) -&gt; &#123;<span class="comment">// 比较器的简单写法</span></span><br><span class="line">            <span class="keyword">if</span> (o1.age != o2.age) &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.age - o2.age;<span class="comment">// 升序</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.name.compareTo(o2.name);<span class="comment">// 降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Person each : arr) &#123;</span><br><span class="line">            System.out.println(each.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; 姓名：&quot;</span> + name + <span class="string">&quot;，年龄：&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="大数类"><a class="markdownIt-Anchor" href="# 大数类"></a> 大数类</h3>
<p>大数类分为整型 <code>BigInteger</code> 和浮点型<code>BigDecimal</code></p>
<p>定义 BigInteger 类型可以使用实例化类的方法，也可以使用 BigInteger 中的 valueOf(数字 / 变量)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">b</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">788</span>;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">c</span> <span class="operator">=</span> BigInteger.valueOf(i);</span><br></pre></td></tr></table></figure>
<p>大数的类是在 java.math.* 包里的，所以继承了 math 的所有方法，而运算也是使用方法来进行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">b</span> <span class="operator">=</span> BigInteger.valueOf(-<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">788</span>;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">c</span> <span class="operator">=</span> BigInteger.valueOf(i);</span><br><span class="line">BigInteger ad=a.add(c);</span><br><span class="line">BigInteger sub=a.subtract(b);</span><br><span class="line">BigInteger mul=a.multiply(b);</span><br><span class="line">BigInteger div=c.divide(a);</span><br><span class="line">BigInteger re=c.remainder(a);</span><br><span class="line">BigInteger ab=b.abs();</span><br><span class="line">System.out.println(ad);</span><br><span class="line">System.out.println(sub);</span><br><span class="line">System.out.println(mul);</span><br><span class="line">System.out.println(div);</span><br><span class="line">System.out.println(re);</span><br><span class="line">System.out.println(ab);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：791 6 -9 262 2 3</p>
</blockquote>
<p>BigDecimal 使用 <code>.scale()</code> 表示小数位数<br />
具体计算方法与整型差不读，但浮点型进行除法的时候可能会存在除不尽的情况，这样就可以对其进行精度上的取余<br />
判断相等时可能小数位后面存在多个 0 这样虽然不影响大小但在操作的时候会导致大小不同，可以使用 <code>compareTo()</code> 方法</p>
<h3 id="math 类"><a class="markdownIt-Anchor" href="#math 类"></a> Math 类</h3>
<p>可以求 sqrt(平方根)、abs(绝对值)、max、min、pow(幂)、取整 (ceil、floor、round) 具体查阅 API</p>
<p>输出一个随机数用 random()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> Math.random();</span><br><span class="line">    System.out.println(c);<span class="comment">// 输出一个 0-1 之间的随机数（double 类型）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * b + <span class="number">1</span>);<span class="comment">// 输出一个 1-b 之间的随机数 </span></span><br><span class="line">    System.out.println(d);</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * (b - a + <span class="number">1</span>) + a);<span class="comment">// 输出一个 a-b 的随机数</span></span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;<span class="comment">//+ 1 是因为 random() 最大取不到 1, 所以上限取整后就会少 1</span></span><br></pre></td></tr></table></figure>
<h2 id="模板"><a class="markdownIt-Anchor" href="# 模板"></a> 模板</h2>
<h3 id="公约公倍数"><a class="markdownIt-Anchor" href="# 公约公倍数"></a> 公约公倍数</h3>
<p>求最大公约数可以采用辗转相除法，就是两数的最大公约数就是较小数和两数余数的最大公约数<br />
最小公倍数等于两数的乘积除最大公约数<br />
BigInteger 提供 <code>.gcd(x, y)</code> 方法自动判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);<span class="comment">// 辗转相除法，两数的最大公约数等于较小数与两数余数的最大公约数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lcm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*b/gcd(a,b);<span class="comment">// 最小公倍数等于两数相乘除最大公约数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(gcd(<span class="number">12</span>,<span class="number">5</span>));</span><br><span class="line">        System.out.println(lcm(<span class="number">12</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">y</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">123</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">x</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">12345</span>);</span><br><span class="line">        System.out.println(x.gcd(y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断闰年"><a class="markdownIt-Anchor" href="# 判断闰年"></a> 判断闰年</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">400</span> == <span class="number">0</span> || (n % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; n % <span class="number">100</span> != <span class="number">0</span>))</span><br><span class="line">        System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断质数"><a class="markdownIt-Anchor" href="# 判断质数"></a> 判断质数</h3>
<p>质数的判断一般有三种方式：定义方法、遍历因子、打表<br />
一二种的理念相同：遍历因子看能否取余，因子最大不会超过 X 的 <code>sqrt</code></p>
<p>打表的复杂度最低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种：</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= Math.sqrt(x); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种：</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; N) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打表：判断 0~9999 中是否为素数</span></span><br><span class="line"><span class="type">boolean</span>[] arrPrimer = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">10000</span>];</span><br><span class="line">Arrays.fill(arrPrimer, Boolean.TRUE);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j * j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">        arrPrimer[i * j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进制转换"><a class="markdownIt-Anchor" href="# 进制转换"></a> 进制转换</h3>
<p>在 Integer 对象中，常用的进制转换</p>
<table>
<thead>
<tr>
<th>十进制的转换对象</th>
<th>对应的方法和参数</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>数字转换字符串</td>
<td>Integer.toBinaryString(n);</td>
<td>二进制字符串</td>
</tr>
<tr>
<td>数字转换字符串</td>
<td>Integer.toOctalString(n);</td>
<td>八进制字符串</td>
</tr>
<tr>
<td>数字转换字符串</td>
<td>Integer.toHexString(n);</td>
<td>十六进制字符串</td>
</tr>
<tr>
<td>数字转换字符串</td>
<td>Integer.toString(n, r);</td>
<td>r 进制字符串</td>
</tr>
<tr>
<td>字符串转换数字</td>
<td>Integer.parseInt(str, r);</td>
<td>r 进制整数</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> n=<span class="number">18</span>;</span><br><span class="line">      System.out.println(Integer.toBinaryString(n));<span class="comment">// 转换二进制</span></span><br><span class="line">      System.out.println(Integer.toOctalString(n));<span class="comment">// 转换成八进制</span></span><br><span class="line">      System.out.println(Integer.toHexString(n));<span class="comment">// 转换成十六进制</span></span><br><span class="line">      System.out.println(Integer.toString(n,<span class="number">2</span>));</span><br><span class="line">      <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;10101&quot;</span>;</span><br><span class="line">      System.out.println(Integer.parseInt(s,<span class="number">2</span>));<span class="comment">// 回转为十进制</span></span><br><span class="line">      <span class="comment">// 判断十进制整数转换成二进制后“1”的个数</span></span><br><span class="line">      System.out.println(Integer.bitCount(<span class="number">21</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="全排列"><a class="markdownIt-Anchor" href="# 全排列"></a> 全排列</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= <span class="number">9</span>) &#123;<span class="comment">// 递归出口</span></span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[k];</span><br><span class="line">        arr[k] = arr[i];</span><br><span class="line">        arr[i] = t;<span class="comment">// 将相邻的两位数互换</span></span><br><span class="line">        dfs(k + <span class="number">1</span>);<span class="comment">// 互换下一个</span></span><br><span class="line">        t = arr[k];</span><br><span class="line">        arr[k] = arr[i];</span><br><span class="line">        arr[i] = t;<span class="comment">// 回溯时更换回来，不影响下一次排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    System.out.println(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="走迷宫"><a class="markdownIt-Anchor" href="# 走迷宫"></a> 走迷宫</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util. Scanner; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MazeDfs</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS 算法解决走迷宫问题</span></span><br><span class="line"><span class="comment">     * 0: 表示通路</span></span><br><span class="line"><span class="comment">     * 1: 表示死路</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">shortestPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化一个迷宫地图</span></span><br><span class="line">        <span class="comment">// 0: 表示通路</span></span><br><span class="line">        <span class="comment">// 1: 表示死路</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); </span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> sc.nextInt(); </span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> sc.nextInt(); </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[x][y]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; y; j++)</span><br><span class="line">                map[i][j] = sc.nextInt(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 从矩阵的左上角位置开始搜索</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, map);</span><br><span class="line">        <span class="keyword">if</span> (shortestPath.length() != <span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">&quot; 最短路线为：&quot;</span> + shortestPath);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot; 没有找到路线！&quot;</span>);</span><br><span class="line">        <span class="type">char</span>[] s = shortestPath.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>[][] map)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获得矩阵的大小</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> map.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> map[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 设置结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果坐标越界，或者 maze[x][y]==1 表示遇到障碍</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt; m - <span class="number">1</span> || y &gt; n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 表示遇到障碍</span></span><br><span class="line">        <span class="keyword">if</span> (map[x][y] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 判断是否通路和越界</span></span><br><span class="line">        <span class="keyword">if</span> (x == m - <span class="number">1</span> &amp;&amp; y == n - <span class="number">1</span>) &#123; <span class="comment">// 判断是否抵达出口</span></span><br><span class="line">            path = path + <span class="string">&quot;(&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (shortestPath.length() == <span class="number">0</span> || shortestPath.length() &gt; path.length())</span><br><span class="line">                shortestPath = path;</span><br><span class="line">            System.out.println(<span class="string">&quot; 找到路线:&quot;</span> + path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> path;</span><br><span class="line">        path = path + <span class="string">&quot;(&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;)&quot;</span> + <span class="string">&quot;-&quot;</span>; <span class="comment">// 记录路线</span></span><br><span class="line">        map[x][y] = <span class="number">1</span>; <span class="comment">// 将走过的路标记</span></span><br><span class="line">        <span class="comment">// 向四个方向搜索</span></span><br><span class="line">        dfs(x + <span class="number">1</span>, y, map);  <span class="comment">// 向右搜索</span></span><br><span class="line">        dfs(x, y + <span class="number">1</span>, map);  <span class="comment">// 向下搜索</span></span><br><span class="line">        dfs(x, y - <span class="number">1</span>, map);  <span class="comment">// 向上搜索</span></span><br><span class="line">        dfs(x - <span class="number">1</span>, y, map);  <span class="comment">// 向左搜索</span></span><br><span class="line">        <span class="comment">// 将路线和标记恢复成上一次的状态</span></span><br><span class="line">        map[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 清除</span></span><br><span class="line">        path = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="背包"><a class="markdownIt-Anchor" href="# 背包"></a> 背包</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackPack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] v = <span class="keyword">new</span> <span class="title class_">int</span>[N];<span class="comment">// 记录体积</span></span><br><span class="line">        <span class="type">int</span>[] w = <span class="keyword">new</span> <span class="title class_">int</span>[N];<span class="comment">// 记录价值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            v[i] = sc.nextInt();</span><br><span class="line">            w[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[V + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="comment">// 从大到小遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> V; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= v[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[j] = Math.max(dp[j], dp[j - v[i - <span class="number">1</span>]] + w[i - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; V + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            System.out.println(dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 NumPy 实现无框架版本全连接神经网络</title>
    <url>/native_code-fcnn/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p> 最近又扎进了深度学习的大坑里边，开始了一段新的学习过程。深度学习的东西相较于之前做后端研发而言代码较为简单，重在理解其中的算法逻辑和公式推导，因为有几个深度学习框架的存在，使得做出一个可用的算法模型变得异常简单，所以想着尝试用原生的方式实现目前比较主流的一些算法，第一个就从最初的全连接开始 </p>
<span id="more"></span>
<p> 因为工作相关，我这里以图像分类为例，用的是 mnist 手写数字识别的数据，至于数据的获取这里就不写了，只介绍算法相关 </p>
<h2 id="实现神经网络"><a class="markdownIt-Anchor" href="# 实现神经网络"></a> 实现神经网络 </h2>
<h3 id="引入权重"><a class="markdownIt-Anchor" href="# 引入权重"></a> 引入权重 </h3>
<p> 神经网络的本质就是将无法进行明确逻辑梳理的功能实现出来，实现的过程就是用大量符合目标结果的数据喂给机器学习，从而让程序拟合出解决这一类问题的能力 </p>
<p> 既然是学习，那个我们让输入的数据怎么计算，最后才能符合最终的结果呢，这就涉及到了权重，权重与神经元是从生物学的角度换算得来的，对于一张图片（这里以图像为例，实际包含任何可输入的东西）人看到之后会对其主体作出判断，然后是色彩，细节，这些不同的判断与人们对这张图片最后形成的印象所产生的影响是不同的，由此就有了权重的划分，至于哪些判断是重要的，重要和不重要的权重又应该设置为多少那就是机器需要学习的了 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoLayerNet</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_size, hidden_size, output_size, weight_init_std=<span class="number">0.01</span></span>):</span><br><span class="line">        self.params = &#123;&#125;</span><br><span class="line">        self.params[<span class="string">&quot;W1&quot;</span>] = weight_init_std * np.random.randn(input_size, hidden_size)</span><br><span class="line">        self.params[<span class="string">&quot;b1&quot;</span>] = np.zeros(hidden_size)</span><br><span class="line">        self.params[<span class="string">&quot;W2&quot;</span>] = weight_init_std * np.random.randn(hidden_size, output_size)</span><br><span class="line">        self.params[<span class="string">&quot;b2&quot;</span>] = np.zeros(output_size)</span><br></pre></td></tr></table></figure>
<p> 依照代码逐行分析为什么要这么写 </p>
<ol>
<li> 首先看参数，<code>input_size</code> 对应图片输入量，任何图片都可以根据其像素，色域等分成一个多维的数据，为了方便处理，可以将数据压缩成一维，而这个一维数组的长度就是该张图片所有的信息量，也就是这里的 size<br />
<code>hidden_size</code> 是第二层的大小，对输入的信息进行的运算之后会将其传递给下一层的神经元 <br />
<code>output_size</code> 是最终输入层的大小，因为这里是对数字的识别，那么输出的结果就可以看作数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∽</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">0\backsim9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">∽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span> 的集合 </li>
<li><code>params</code> 代表所有的权重信息，当结合权重运算的结果大于某个值时才有其发挥的意义，这个值姑且称为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>，也就是下方的公式 </li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo stretchy="false">(</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>⪕</mo><mi>θ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo stretchy="false">(</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>&gt;</mo><mi>θ</mi></mrow></mstyle></mtd></mtr></mtable></mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>y</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>⪕</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>&gt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">y = \begin{cases}
  0 (w_{1}x_{1} + w_{2}x_{2}) \eqslantless \theta \\
  1 (w_{1}x_{1} + w_{2}x_{2}) &gt; \theta
\end{cases}    \implies    y = \begin{cases}
  0 (b + w_{1}x_{1} + w_{2}x_{2}) \eqslantless 0 \\
  1 (b + w_{1}x_{1} + w_{2}x_{2}) &gt; 0
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⪕</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⪕</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h3 id="激活函数"><a class="markdownIt-Anchor" href="# 激活函数"></a> 激活函数 </h3>
<p> 我们上方的公式已经可以支撑两层神经网络的训练了，但是对于其输出只有 0, 1 这显然无法起到对数据进行信息量传递的效果，或者说有效果，但是很少，所以需要对其进行其他处理，使其输出一些有价值且信息跳跃不会过大的值，这就引入了激活函数的概念，这里我是用最常见的 <code>sigmoid()</code>，同样输出层函数选用分类场景下最常见的 <code>softmax()</code>，其对应公式如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Sigmoid</mtext><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow></mfrac><mspace width="2em"/><mtext>Softmax</mtext><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><msup><mi>e</mi><msub><mi>x</mi><mi>i</mi></msub></msup><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mi>e</mi><msub><mi>x</mi><mi>j</mi></msub></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{Sigmoid}(x) = \sigma(x) = \frac{1}{1 + e^{-x}}
\qquad
\text{Softmax}(x_i) = \frac{e^{x_i}}{\sum_{j=1}^n e^{x_j}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Sigmoid</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.697331em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:2em;"></span><span class="mord text"><span class="mord">Softmax</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.471502em;vertical-align:-1.1301100000000002em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.341392em;"><span style="top:-2.305708em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6064620000000001em;"><span style="top:-3.0050700000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1301100000000002em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p> 有了公式，代码就实现起来简单多了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">x</span>):</span><br><span class="line">    x = x - np.<span class="built_in">max</span>(x)</span><br><span class="line">    <span class="keyword">return</span> np.exp(x) / np.<span class="built_in">sum</span>(np.exp(x))</span><br></pre></td></tr></table></figure>
<p> 上边的 <code>softmax()</code> 函数中有一行在公式之前的计算，用数组 <code>x</code> 的每个元素减去了数组中的最大值，这其实是为了方式数组中各元素过大导致进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">e^{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span></span> 运算时结果超过计算机有效位数（4 或 8 字节）</p>
<p> 同时考虑到实际学习中会进行批量数据的导入，下方把批量计算的代码也实现出来，批量无非就是对每一行单独进行计算 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x.ndim == <span class="number">2</span>:</span><br><span class="line">        x = x.T</span><br><span class="line">        x = x - np.<span class="built_in">max</span>(x, axis=<span class="number">0</span>)</span><br><span class="line">        y = np.exp(x) / np.<span class="built_in">sum</span>(np.exp(x), axis=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> y.T</span><br><span class="line"></span><br><span class="line">    <span class="comment"># if x.ndim == 2:</span></span><br><span class="line">    <span class="comment"># x = x - np.max(x, axis=1, keepdims=True)</span></span><br><span class="line">    <span class="comment"># return np.exp(x) / np.sum(np.exp(x), axis=1, keepdims=True)</span></span><br><span class="line"></span><br><span class="line">    x = x - np.<span class="built_in">max</span>(x)</span><br><span class="line">    <span class="keyword">return</span> np.exp(x) / np.<span class="built_in">sum</span>(np.exp(x))</span><br></pre></td></tr></table></figure>
<p> 将损失函数与权重计算结合起来，代码如下 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">perdict</span>(<span class="params">self, x</span>):</span><br><span class="line">    w1, w2 = self.params[<span class="string">&quot;W1&quot;</span>], self.params[<span class="string">&quot;W2&quot;</span>]</span><br><span class="line">    b1, b2 = self.params[<span class="string">&quot;b1&quot;</span>], self.params[<span class="string">&quot;b2&quot;</span>]</span><br><span class="line">    a1 = np.dot(x, w1) + b1</span><br><span class="line">    z1 = sigmoid(a1)</span><br><span class="line">    a2 = np.dot(z1, w2) + b2</span><br><span class="line">    y = softmax(a2)</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure>
<p> 至此一个简单的神经网络就实现完成了，为了便于直观感受，我们可以对总量的一个准确度进行输出 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">self, x, t</span>):</span><br><span class="line">    y = self.perdict(x)</span><br><span class="line">    y = np.argmax(y, axis=<span class="number">1</span>)</span><br><span class="line">    t = np.argmax(t, axis=<span class="number">1</span>)</span><br><span class="line">    accuracy = np.<span class="built_in">sum</span>(y == t) / <span class="built_in">float</span>(x.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> accuracy</span><br></pre></td></tr></table></figure>
<h3 id="损失函数"><a class="markdownIt-Anchor" href="# 损失函数"></a> 损失函数 </h3>
<p> 以上只是一个神经网络的实现过程，好像并没有引入自我学习的概念，所谓学习也就是对权重和偏置的一个修改，使其处在一个合适的值，既可以拟合解决所有的学习数据，又具备相当的泛化能力 </p>
<p> 那么应该对该权重值怎么进行改变呢，改变的首要条件就是得确定什么样的结果是好的，以这个结果为判断依据才有改变的意义，否则随意调整参数没有任何意思，由此又引入了损失函数的概念 </p>
<p> 相较于准确度，损失函数有几个优点：</p>
<ol>
<li> 损失函数是连续的，每个结果的输出都可以用损失函数给出一个明确的差异，而准确度只能说明该结果是否正确，对权重变化不敏感 </li>
<li> 同样损失函数表达当前结果与正确结果有多大的差异，准确度只能粗暴的将结果都认定为 100%，对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0.9</mn><mo separator="true">,</mo><mn>0.1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>0.51</mn><mo separator="true">,</mo><mn>0.49</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0.9, 0.1], [0.51, 0.49]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mord">.</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">4</span><span class="mord">9</span><span class="mclose">]</span></span></span></span> 这两组数据，表现的信息和可信度就有明确的差异 </li>
<li> 可微分，能够指明参数优化的方向 </li>
</ol>
<p> 这里选用交叉熵误差的作为计算本次的损失函数，公式如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Cross-Entropy</mtext><mo>=</mo><mo>−</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>C</mi></munderover><msub><mi>y</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mover accent="true"><mi>y</mi><mo>^</mo></mover><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{Cross-Entropy} = -\frac{1}{N} \sum_{i=1}^N \sum_{k=1}^C y_{i,k} \log(\hat{y}_{i,k})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">Cross-Entropy</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1304490000000005em;vertical-align:-1.302113em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p> 直接看代码实现，便于理解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy_error</span>(<span class="params">y, t</span>):</span><br><span class="line">    <span class="keyword">if</span> y.ndim == <span class="number">1</span>:</span><br><span class="line">        t = t.reshape(<span class="number">1</span>, t.size)</span><br><span class="line">        y = y.reshape(<span class="number">1</span>, y.size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> t.size == y.size:</span><br><span class="line">        t = t.argmax(axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    batch_size = y.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> -np.<span class="built_in">sum</span>(np.log(y[np.arange(batch_size), t] + <span class="number">1e-7</span>)) / batch_size</span><br></pre></td></tr></table></figure>
<p> 几个注意点：</p>
<ul>
<li> 不是批量训练时转换为个数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的二维数组 </li>
<li> 如果是 <code>one-hot</code> 形式，转换为类别索引（也叫做稀疏标签）</li>
<li> 计算时对结果加一个极小值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>e</mi><mo>−</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">1e-7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 防止除数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
</ul>
<h3 id="梯度计算"><a class="markdownIt-Anchor" href="# 梯度计算"></a> 梯度计算 </h3>
<p> 目前已经有了损失函数的概念，但是损失函数只是告诉当前训练是好是坏，作为学习依据进行使用，那么有了依据，应该怎么调整权重值，这自然而然就引入了导数的概念 </p>
<p> 对函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f(x)=y=x^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 进行求导，得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mn>2</mn><mi>x</mi></mrow><annotation encoding="application/x-tex">f&#x27;(x)=\frac{dy}{dx}=2x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal">x</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">x=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 时的值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 这里的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 不仅是看作为结果更是还能看作当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">x=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 时其沿着 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 坐标增大时（导数值为正数为增大，负数为减少）对应的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 值变大 </p>
<p> 想象一下这一个巨简单的神经网络损失函数，其只有一个权重值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，那么是否就可以根据导数进行数值的更新，只是对于损失函数而言取负数，这里对导数添加负号即可，每次移动的量尽量小，以免错过最低点，当到达最低点时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 的值最小，也就是损失为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 达到一个绝对高的准确率（这是最简单的实现理解，并不严谨）</p>
<p> 将以上函数规模扩大，那么这时计算的所有偏导数值也就是梯度就指明了学习的方向，其导数与梯度公式如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></munder><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mi>h</mi></mfrac><mspace width="2em"/><msub><mi mathvariant="normal">∇</mi><mi>W</mi></msub><mi>L</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>W</mi></mrow></mfrac><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>W</mi><mn>11</mn></msub></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>W</mi><mn>12</mn></msub></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>W</mi><mrow><mn>1</mn><mi>n</mi></mrow></msub></mrow></mfrac></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>W</mi><mn>21</mn></msub></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>W</mi><mn>22</mn></msub></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>W</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub></mrow></mfrac></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋱</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>W</mi><mrow><mi>m</mi><mn>1</mn></mrow></msub></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>W</mi><mrow><mi>m</mi><mn>2</mn></mrow></msub></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>W</mi><mrow><mi>m</mi><mi>n</mi></mrow></msub></mrow></mfrac></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">f&#x27;(x) = \lim_{h \to 0} \frac{f(x + h) - f(x)}{h}
\qquad
\nabla_W L = \frac{\partial L}{\partial W} = 
\begin{bmatrix}
\frac{\partial L}{\partial W_{11}} &amp; \frac{\partial L}{\partial W_{12}} &amp; \cdots &amp; \frac{\partial L}{\partial W_{1n}} \\ 
\frac{\partial L}{\partial W_{21}} &amp; \frac{\partial L}{\partial W_{22}} &amp; \cdots &amp; \frac{\partial L}{\partial W_{2n}} \\ 
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 
\frac{\partial L}{\partial W_{m1}} &amp; \frac{\partial L}{\partial W_{m2}} &amp; \cdots &amp; \frac{\partial L}{\partial W_{mn}}
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.179108em;vertical-align:-0.7521079999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-2.347892em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mrel mtight">→</span><span class="mord mtight">0</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">lim</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7521079999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">h</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:2em;"></span><span class="mord"><span class="mord">∇</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:5.835624000000001em;vertical-align:-2.6678120000000005em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.167812em;"><span style="top:-5.975204em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-4.649996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.7048959999999997em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.4647879999999995em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6678120000000005em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.167812em;"><span style="top:-5.975204em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-4.649996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.7048959999999997em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.4647879999999995em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6678120000000005em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.167812em;"><span style="top:-5.787704em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-4.462496em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-2.5173959999999997em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋱</span></span></span><span style="top:-1.2772879999999995em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6678120000000005em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.167812em;"><span style="top:-5.975204em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-4.649996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.7048959999999997em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.4647879999999995em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6678120000000005em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p> 当然我们的权重不可能只有一个，所以这里直接使用梯度：</p>
<h3 id="反向传播"><a class="markdownIt-Anchor" href="# 反向传播"></a> 反向传播 </h3>
<h4 id="验证反向传播"><a class="markdownIt-Anchor" href="# 验证反向传播"></a> 验证反向传播 </h4>
<h2 id="训练神经网络"><a class="markdownIt-Anchor" href="# 训练神经网络"></a> 训练神经网络 </h2>
<h2 id="面向对象的神经网络"><a class="markdownIt-Anchor" href="# 面向对象的神经网络"></a> 面向对象的神经网络 </h2>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 实现 LRU 缓存模型</title>
    <url>/data_structure-LRU_cache_model/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p>LRC 缓存模型其实是很常见的，像 InnoDB 的缓存池，虚拟内存的调度算法，重点是数据结构的实现，值得单独记录一下，对理解也有很大的帮助 </p>
<span id="more"></span>
<p><a class="link"   href="https://leetcode-cn.com/problems/lru-cache/">LeetCode 地址 <i class="fas fa-external-link-alt"></i></a></p>
<p> 这道题其实更多的是考察数据结构和集合的使用，所以也放到了实现题这里 </p>
<p><strong> 思路：</strong><br />
LRU 直译为最近最少未使用，要想实现首先要搞清它的特点 </p>
<ul>
<li> 新进来的缓存结点放在最近被使用位 </li>
<li> 每被使用一次的结点放在最近被使用位 </li>
</ul>
<p> 根据这两个特点我们可以使用链表存储每一个缓存结点，新放入或者被使用的结点直接放在链表头，当需要淘汰最近最少未使用的结点时直接去掉尾结点就可以，为了存取方便这里使用双向链表 </p>
<p> 接下来再分析题目需要我们实现的方法 </p>
<blockquote>
<p>Your LRUCache object will be instantiated and called as such:<br />
LRUCache obj = new LRUCache(capacity);<br />
int param_1 = obj.get(key);<br />
obj.put(key, value);</p>
</blockquote>
<p> 根据存取特点，我们需要使用 Map 存储对应关系；根据构造方法，我们在 put 时还应根据 capacity 的值动态决定是否移除尾结点 </p>
<p><strong> 代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="comment">// 结点结构 </span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> key;    <span class="comment">// 此处的 key 方便在链表和 Map 同时移除 </span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;</span><br><span class="line">            key = _key;</span><br><span class="line">            value = _value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;   <span class="comment">// 当前存储大小 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;   <span class="comment">// 指定容量 </span></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造器 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="comment">// 先判断是否存在，存在更改值，不存在放入 </span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line"></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 放入后置于链表头 </span></span><br><span class="line">            addHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="comment">// 超过最大容量清除 </span></span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">reTail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                cache.remove(reTail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">result</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>案例</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 原生实现 HTTP 服务</title>
    <url>/native_code-http_service/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p> 不依赖任何第三方库或框架（只使用 jdk 里面包含的公开可用的类库），tomcat 属于第三方框架所以不要用，<code>com.sun</code> 下的也不要用，开发一个 http 服务 </p>
<span id="more"></span>
<blockquote>
<p> 做加法运算：计算参数 a 和参数 b 的算术和，在浏览器地址栏里输入 <code>http://localhost:port/add?a=4&amp;b=7</code> ，浏览器窗口中显示 11<br />
做乘法运算：计算参数 a 和参数 b 的算术乘积，在浏览器地址栏里输入 <code>http://localhost:port/mult?a=4&amp;b=7</code> ，浏览器窗口中显示 28</p>
</blockquote>
<p>Java 开发文档中已经提供完整的方式，<a class="link"   href="https://docs.oracle.com/javase/tutorial/networking/sockets/definition.html"> 英文教程 <i class="fas fa-external-link-alt"></i></a></p>
<p> 具体流程：</p>
<ol>
<li> 使用 ServerSocket 对客户端进行监听 </li>
<li> 接收 http，解析数据 </li>
<li> 提供服务并响应 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Aidan on 2021/8/31 21:24</span></span><br><span class="line"><span class="comment"> * GitHub: github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * Blog: aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听端口号，只要是 8888 就能接收到 </span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 实例化客户端，固定套路，通过服务端接受的对象，生成相应的客户端实例 </span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            <span class="comment">// 获取客户端输入流，就是请求过来的基本信息：请求头，换行符，请求体 </span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 接受 HTTP 请求，并解析数据 </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String requestHeader;</span><br><span class="line">            <span class="keyword">if</span> ((requestHeader = bd.readLine()) != <span class="literal">null</span> &amp;&amp; !requestHeader.isEmpty()) &#123;</span><br><span class="line">                System.out.println(requestHeader);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 方法处理代码 </span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> requestHeader.indexOf(<span class="string">&quot;?&quot;</span>) + <span class="number">3</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">terminal</span> <span class="operator">=</span> requestHeader.indexOf(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">num1</span> <span class="operator">=</span> requestHeader.substring(start, terminal);</span><br><span class="line">                <span class="type">int</span> <span class="variable">space</span> <span class="operator">=</span> requestHeader.indexOf(<span class="string">&quot;HTTP&quot;</span>) - <span class="number">1</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">num2</span> <span class="operator">=</span> requestHeader.substring(terminal + <span class="number">3</span>, space);</span><br><span class="line">                System.out.println(num1 + num2);</span><br><span class="line">                <span class="comment">// 加法 </span></span><br><span class="line">                <span class="keyword">if</span> (requestHeader.contains(<span class="string">&quot;add&quot;</span>)) &#123;    <span class="comment">// 重在实现没有做 URL 检查 </span></span><br><span class="line">                    result = Integer.parseInt(num1) + Integer.parseInt(num2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 乘法 </span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (requestHeader.contains(<span class="string">&quot;mult&quot;</span>)) &#123;  <span class="comment">// 重在实现没有做 URL 检查 </span></span><br><span class="line">                    result = Integer.parseInt(num1) * Integer.parseInt(num2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发送回执 </span></span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">            pw.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;Content-type:text/html&quot;</span>);</span><br><span class="line">            pw.println();</span><br><span class="line">            pw.println(<span class="string">&quot;&lt;h1&gt;&quot;</span> + result + <span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            pw.flush();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>案例</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 怎么重写 Hash 和 equals</title>
    <url>/native_code-overrid_and_equals/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p>Java 的 <code>euqals()</code> 和 <code>hashCode()</code> 可以说是最常用的两个 Object 方法，那具体怎么重写这两个方法才能做到真正的实用和有效呢？</p>
<p> 其实大致思路都是相同的，不过是判断地址和转型后判断属性，但转型和判断属性的方式还要考虑到子类继承的情况，下面是阅读《Java 修炼指南》后的总结写法 </p>
<span id="more"></span>
<p> 首先贴一下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Aidan on 2021/11/8 20:05</span></span><br><span class="line"><span class="comment"> * GitHub: github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * Blog: aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 判断引用是否相等 </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断传入的对象是否为空 </span></span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 判断类型是否相等，考虑到子类继承后重写的情况所以不使用 `instanceof`</span></span><br><span class="line">        <span class="comment">// if (!(o instanceof Person)) return false;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 进行类型转换 </span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 进行属性的判断（应该使用 `getXXX()` 的方式，这里为了简便）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id == person.id &amp;&amp; Objects.equals(<span class="built_in">this</span>.name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// return Objects.hash(this.id, this.name);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其实大部分的使用都是相同的，只是在判断类型时有些不同，这里主要是考虑到类继承后重写父类（自定义）的 <code>euqals()</code> 方法，导致判断方式各异的情况，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Women</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String favor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Women</span> <span class="variable">women</span> <span class="operator">=</span> (Women) obj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id == women.id &amp;&amp; <span class="built_in">this</span>.name.equals(women.name) &amp;&amp; <span class="built_in">this</span>.favor.equals(women.favor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>案例</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中遍历集合的最佳解决方案</title>
    <url>/native_code-traversal_collection/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p> 进行集合的遍历无非就是 for(forEach), Iterator 两种方式，其实迭代器被设计出来就是为了方便集合的遍历，但为什么要这么使用，以及一些骚操作在这里做一个总结 </p>
<span id="more"></span>
<h2 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> ArrayList</h2>
<p> 直接看综合的测试代码 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Aidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2021/11/16 16:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@GitHub</span> github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraversalList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构建初始 ArrayList</span></span><br><span class="line">        List&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_SIZE; i++) &#123;</span><br><span class="line">            arrayList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for 循环测试 </span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_SIZE; i++) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> arrayList.get(i);</span><br><span class="line">            System.out.print(integer.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">resultFor</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// forEach 遍历测试 </span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : arrayList) &#123;</span><br><span class="line">            System.out.print(integer + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">resultForEach</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterator 遍历测试 </span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = arrayList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">resultIterator</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n\n=============== Result ================\n&quot;</span>);</span><br><span class="line">        System.out.println(resultFor);</span><br><span class="line">        System.out.println(resultForEach);</span><br><span class="line">        System.out.println(resultIterator);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 测试结果几次都不同，但时间花费基本上大差不差，看起来用哪个无所谓，不过 forEach 也是基于 Iterator 来实现，相较于 for 和 Iterator 来说，其语法更加简洁，使用时不用考虑下标，所以如果只是单纯的进行遍历元素，<strong> 推荐使用 forEach</strong>，如果有遍历修改的需求一般会使用 for 循环来实现，但如果添加或是向前遍历可以使用 ListIterator 进行操作 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListIterator&lt;Integer&gt; integerListIterator = arrayList.listIterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (integerListIterator.hasNext()) &#123;</span><br><span class="line">    <span class="comment">// 为集合中的每个元素后添加一个 -1</span></span><br><span class="line">    integerListIterator.add(-<span class="number">1</span>);</span><br><span class="line">    integerListIterator.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时迭代器游标处于最后 </span></span><br><span class="line"><span class="keyword">while</span> (integerListIterator.hasPrevious()) &#123;</span><br><span class="line">    System.out.println(integerListIterator.previous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="linkedlist"><a class="markdownIt-Anchor" href="#linkedlist"></a> LinkedList</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; linked = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_SIZE; i++) &#123;</span><br><span class="line">        linked.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; linked.size(); i++) &#123;</span><br><span class="line">        System.out.print(linked.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">resultFor</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line"></span><br><span class="line">    start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : linked) &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">resultForEach</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line"></span><br><span class="line">    start = System.currentTimeMillis();</span><br><span class="line">    Iterator&lt;Integer&gt; iterator = linked.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">resultIterator</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\n\n========== Result =========\n&quot;</span>);</span><br><span class="line">    System.out.println(resultFor);</span><br><span class="line">    System.out.println(resultForEach);</span><br><span class="line">    System.out.println(resultIterator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这时花费的时间就优点意思了，for 使用的时间比其他两种方式加起来都多，至于 forEach 和 Iterator 大致相同 </p>
<p> 原因就是 LinkedList 不支持随机存储，大量的 <code>get()</code> 不过是每次的遍历到指定的位置，也就是说数据规模越大，花费的时间越长 </p>
<h2 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h2>
<p> 遍历 HashMap 有三种方式，使用 keySet 或者 valueSet 进行遍历，适合只遍历一种类型的情况下进行使用，其次就是使用 entrySet 进行所有的遍历，还有就是使用 EntrySet 的 Iterator 进行遍历，还有不常使用的一种就是先使用 KeySet 获取所有的键，然后使用键去获取对应的 Value，实际使用性能太低，所以不做考虑，<strong> 推荐使用 entrySet 的方式进行遍历 </strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Aidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2021/11/16 20:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@GitHub</span> github.com/huaxin0304</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> aidanblog.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraversalMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            map.put(String.valueOf(i), String.valueOf(Math.random()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 KeySet 或者 ValSet 进行遍历 </span></span><br><span class="line">        <span class="keyword">for</span> (String s : map.keySet()) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String value : map.values()) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 EntrySet 进行遍历 </span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;:entry:&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Iterator 进行遍历 </span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next().getKey() + <span class="string">&quot;:iterator:&quot;</span> + iterator.next().getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="# 总结"></a> 总结 </h2>
<ul>
<li>ArrayList 为了简洁方便使用 forEach</li>
<li>LinkedList 因为链式存储的原因使用迭代器进行访问 </li>
<li>HshMap 使用 EntrySet 的方式进行遍历性能最佳同时适用于大多数情况 </li>
</ul>
]]></content>
      <categories>
        <category>案例</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 查询连续（递增）ID</title>
    <url>/sql-continuous_id/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p> 查询一个表中连续出现的 ID 或者是查询连续递增的 ID 其实是很常见的场景，这里记录一下我使用的方法 </p>
<span id="more"></span>
<h3 id="查询连续重复的 -id"><a class="markdownIt-Anchor" href="# 查询连续重复的 -id"></a> 查询连续重复的 ID</h3>
<p><a class="link"   href="https://leetcode-cn.com/problems/consecutive-numbers/submissions/">LeetCode 地址 <i class="fas fa-external-link-alt"></i></a></p>
<p> 直接进行连接通过连续的 ID 值保证元组的平行，然后约束相等条件即可 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> l1.Num <span class="keyword">as</span> ConsecutiveNums</span><br><span class="line"><span class="keyword">from</span> Logs l1</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> Logs l2 <span class="keyword">on</span> l1.id <span class="operator">=</span> l2.id <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> Logs l3 <span class="keyword">on</span> l1.id <span class="operator">=</span> l3.id <span class="operator">+</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">where</span> l1.num <span class="operator">=</span> l2.num</span><br><span class="line">  <span class="keyword">and</span> l1.num <span class="operator">=</span> l3.num;</span><br></pre></td></tr></table></figure>
<h3 id="查询连续递增的 -id"><a class="markdownIt-Anchor" href="# 查询连续递增的 -id"></a> 查询连续递增的 ID</h3>
<p><a class="link"   href="https://leetcode-cn.com/problems/human-traffic-of-stadium/">LeetCode 地址 <i class="fas fa-external-link-alt"></i></a></p>
<p> 先看结果要求：</p>
<blockquote>
<p> 找出每行的人数大于或等于 100 且 id 连续的三行或更多行记录 </p>
</blockquote>
<p> 人数大于 100 好说，重点是连续三行以上的 id 连续 </p>
<p> 这是我的测试数据：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>visit_date</th>
<th>people</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2021-09-01</td>
<td>999</td>
</tr>
<tr>
<td>2</td>
<td>2021-09-02</td>
<td>1000</td>
</tr>
<tr>
<td>3</td>
<td>2021-09-03</td>
<td>1001</td>
</tr>
<tr>
<td>4</td>
<td>2021-09-04</td>
<td>100</td>
</tr>
<tr>
<td>5</td>
<td>2021-09-05</td>
<td>1003</td>
</tr>
<tr>
<td>6</td>
<td>2021-09-06</td>
<td>1004</td>
</tr>
<tr>
<td>7</td>
<td>2021-09-07</td>
<td>1005</td>
</tr>
<tr>
<td>8</td>
<td>2021-09-08</td>
<td>1006</td>
</tr>
</tbody>
</table>
<p> 要找三行以上就将三个表进行一个左连接，当 <code>S1.id + 1 = S2.id &amp;&amp; S1.id + 2 = S3.id</code> 就表示连续三个以上了，但这时三个连续以上的数据并不是在一个表中，比如上表中符合条件的最后四行，只有 S1 中只有 5, 6 时 S2 才可以有 6, 7，S3 才可以有 7, 8，但这时的结果是这样的 </p>
<table>
<thead>
<tr>
<th><a class="link"   href="http://S1.id">S1.id<i class="fas fa-external-link-alt"></i></a></th>
<th><a class="link"   href="http://S2.id">S2.id<i class="fas fa-external-link-alt"></i></a></th>
<th><a class="link"   href="http://S3.id">S3.id<i class="fas fa-external-link-alt"></i></a></th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
</tbody>
</table>
<p> 所以将查询出来看作一个子表，使用内连接的方式对数据进行筛选， <code>S.id = SS.i or S.id = SS.ii or S.id = SS.iii</code> 其中 SS 作为结果子表，i, ii, iii 分别是每个连接表的 id，这时在表 S 中符合条件的 id 就是 <code>5, 6, 6, 7, 7, 8</code> ，使用 <code>distinct</code> 修饰一下即可，完整代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> S.<span class="operator">*</span>     # 进行结果去重 </span><br><span class="line"><span class="keyword">from</span> Stadium <span class="keyword">as</span> S</span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span>     # 将主表与连续 id 的结果进行内连接 </span><br><span class="line">     (</span><br><span class="line">         <span class="keyword">select</span> S1.id <span class="keyword">as</span> i, S2.id <span class="keyword">as</span> ii, S3.id <span class="keyword">as</span> iii</span><br><span class="line">         <span class="keyword">from</span> Stadium <span class="keyword">as</span> S1</span><br><span class="line">                  <span class="keyword">left</span> <span class="keyword">join</span> Stadium <span class="keyword">as</span> S2 <span class="keyword">on</span> S1.id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> S2.id</span><br><span class="line">                  <span class="keyword">left</span> <span class="keyword">join</span> Stadium <span class="keyword">as</span> S3 <span class="keyword">on</span> S1.id <span class="operator">+</span> <span class="number">2</span> <span class="operator">=</span> S3.id</span><br><span class="line">         <span class="keyword">where</span> S1.people <span class="operator">&gt;=</span> <span class="number">1000</span>        # 这里使用的测试数据为大于 <span class="number">1000</span> 的 </span><br><span class="line">           <span class="keyword">and</span> S2.people <span class="operator">&gt;=</span> <span class="number">1000</span></span><br><span class="line">           <span class="keyword">and</span> S3.people <span class="operator">&gt;=</span> <span class="number">1000</span></span><br><span class="line">     ) SS</span><br><span class="line"><span class="keyword">where</span> (S.id <span class="operator">=</span> SS.i <span class="keyword">or</span> S.id <span class="operator">=</span> SS.ii <span class="keyword">or</span> S.id <span class="operator">=</span> SS.iii)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> S.id</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>案例</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>删除多字段数据重复且只保留一条</title>
    <url>/sql-keep_one_piece/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p> 这工作中遇到这样一种情况，需要删除某一列内容相同的数据，但需要保留一行，这一行可能根据某一列的值进行判断 </p>
<span id="more"></span>
<p> 首先开始看表，目前的表结构和数据如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+----+-------+-----+</span><br><span class="line">| id | name  | pwd |</span><br><span class="line">+----+-------+-----+</span><br><span class="line">| 1  | aidan | 123 |</span><br><span class="line">| 2  | aidan | 124 |</span><br><span class="line">| 3  | jack  | 125 |</span><br><span class="line">| 4  | aidan | 125 |</span><br><span class="line">| 5  | aidan | 125 |</span><br><span class="line">| 6  | alisa | 125 |</span><br><span class="line">+----+-------+-----+</span><br></pre></td></tr></table></figure>
<p> 因为数据量不多，所以大家脑补一下，此时我们在有大量数据的情况下进行对 <code>name</code> , <code>pwd</code> 字段的去重是很麻烦的，而且在工作的实际情况中要复杂的多，这条代码是我的老师给我的，适应性很强，而且不同情况需要修改的代码量也不算多。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 删除重复数据只保留一条 </span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">where</span> (name, pwd) <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> name, pwd</span><br><span class="line">    <span class="keyword">from</span> (</span><br><span class="line">             <span class="keyword">select</span> name, pwd</span><br><span class="line">             <span class="keyword">from</span> `<span class="keyword">user</span>`</span><br><span class="line">             <span class="keyword">group</span> <span class="keyword">by</span> name, pwd</span><br><span class="line">             <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">         ) t</span><br><span class="line">)</span><br><span class="line">  <span class="keyword">and</span> id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> a.id</span><br><span class="line">    <span class="keyword">from</span> (</span><br><span class="line">             <span class="keyword">select</span> <span class="built_in">min</span>(id) <span class="keyword">as</span> id</span><br><span class="line">             <span class="keyword">from</span> `<span class="keyword">user</span>`</span><br><span class="line">             <span class="keyword">group</span> <span class="keyword">by</span> name, pwd</span><br><span class="line">             <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">         ) a</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p> 执行此段代码之后， <code>name</code> , <code>pwd</code> 同时相等的数据被删除，也就是行号为 4, 5 的两行，但这里选择保留 id 最小的一行，也就是第 4 行，执行之后的结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+----+-------+-----+</span><br><span class="line">| id | name  | pwd |</span><br><span class="line">+----+-------+-----+</span><br><span class="line">| 1  | aidan | 123 |</span><br><span class="line">| 2  | aidan | 124 |</span><br><span class="line">| 3  | jack  | 125 |</span><br><span class="line">| 4  | aidan | 125 |</span><br><span class="line">| 6  | alisa | 125 |</span><br><span class="line">+----+-------+-----+</span><br></pre></td></tr></table></figure>
<p> 最后放上 SQL 模板，想抄作业的话改改占位内容就能用 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">from</span> $tableName$</span><br><span class="line"><span class="keyword">where</span> ($fields$) <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> $fields$</span><br><span class="line">    <span class="keyword">from</span> (</span><br><span class="line">             <span class="keyword">select</span> $fields$</span><br><span class="line">             <span class="keyword">from</span> $tableName$</span><br><span class="line">             <span class="keyword">group</span> <span class="keyword">by</span> $fields$</span><br><span class="line">             <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">         ) t</span><br><span class="line">)</span><br><span class="line">  <span class="keyword">and</span> id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> a.id</span><br><span class="line">    <span class="keyword">from</span> (</span><br><span class="line">             <span class="keyword">select</span> <span class="built_in">min</span>(id) <span class="keyword">as</span> id</span><br><span class="line">             <span class="keyword">from</span> $tableName$</span><br><span class="line">             <span class="keyword">group</span> <span class="keyword">by</span> $fields$</span><br><span class="line">             <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">         ) a</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>案例</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Go 语言爬取豆瓣图书 Top250</title>
    <url>/web_crawler-douban_book_top/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p> 今天做核酸的时候在掘金看到一篇讲学 Go 语言的帖子，好家伙写的跟小说是的，不过里边有一个使用 goquery 爬取网页的操作我很感兴趣，自己尝试了一下 </p>
<p> 感悟就是 Go 确实很简单，但只要逻辑理明白了语言真的只是工具而已 </p>
<span id="more"></span>
<p> 具体实现可以看掘金的 <a class="link"   href="https://juejin.cn/post/6863074610800230408"> 原文 <i class="fas fa-external-link-alt"></i></a>，写的特别好，我这里直接贴一下代码 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/PuerkitoBio/goquery&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建我们要导出的 TXT 文件 </span></span><br><span class="line">	file, err := os.Create(<span class="string">&quot;Douban-Book-TOP250&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个客户端对象，用于发送请求 </span></span><br><span class="line">	<span class="keyword">var</span> client = http.Client&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">250</span>; i += <span class="number">25</span> &#123;</span><br><span class="line">		<span class="comment">// 发送一条新请求 </span></span><br><span class="line">		req, _ := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://book.douban.com/top250?start=&quot;</span>+strconv.Itoa(i), <span class="literal">nil</span>)</span><br><span class="line">		<span class="comment">// 设置 User-Agent（必须）</span></span><br><span class="line">		req.Header.Set(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送请求 </span></span><br><span class="line">		resp, err := client.Do(req)</span><br><span class="line">		<span class="comment">// 处理异常 </span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;http get error&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 关闭流 </span></span><br><span class="line">		<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 通过 goquery 将流中的内容构建成一棵 DOM 树 </span></span><br><span class="line">		doc, err := goquery.NewDocumentFromReader(resp.Body)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 拿到所有标记的节点集合进行 each 循环，i = 序号，s = 节点本身 </span></span><br><span class="line">		doc.Find(<span class="string">&quot;div.indent&gt;table&gt;tbody&gt;tr.item&quot;</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, s *goquery.Selection)</span></span> &#123;</span><br><span class="line">			<span class="comment">// 拿到节点集合中的 Items</span></span><br><span class="line">			item := s.Find(<span class="string">&quot;td[valign=top]&quot;</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 通过 Item 节点获取到我们所需要的数据 </span></span><br><span class="line">			<span class="comment">// 对数据进行去空格 去换行操作 </span></span><br><span class="line">			bookName := strings.Replace(strings.Replace(item.Find(<span class="string">&quot;div.pl2&gt;a&quot;</span>).Text(), <span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>), <span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">			author := strings.Split(s.Find(<span class="string">&quot;p.pl&quot;</span>).Text(), <span class="string">&quot;/&quot;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">			quote := strings.Replace(strings.Replace(s.Find(<span class="string">&quot;p.quote&quot;</span>).Text(), <span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>), <span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 拿到处理好的数据后填充文件即可 </span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//fmt.Print(&quot;TOP&quot; + fmt.Sprint(i) + &quot;-&quot; + bookName + &quot;-&quot; + author + &quot;-&quot; + quote)</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 处理字符直接的空格长度，尽量对齐 </span></span><br><span class="line">			bookName = bookName + strings.Repeat(<span class="string">&quot; &quot;</span>, (<span class="number">120</span>-<span class="built_in">len</span>(bookName)))</span><br><span class="line">			author = author + strings.Repeat(<span class="string">&quot; &quot;</span>, (<span class="number">50</span>-<span class="built_in">len</span>(author)))</span><br><span class="line"></span><br><span class="line">			content := <span class="string">&quot;TOP&quot;</span> + strconv.Itoa(i) + <span class="string">&quot;\t&quot;</span> + bookName + author + quote + <span class="string">&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line">			file.WriteString(content)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Print(<span class="string">&quot; 程序执行完毕，请查看结果。&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 几个需要注意的点：</p>
<ol>
<li>User-Agent 必须使用，可以在豆瓣中 F12 查看一下，这里使用的和我浏览器中的不一样，但也可以使用 </li>
<li> 写入到文件时如果处理对齐，需要考虑空格的重复次数不要出现负数的情况 </li>
<li> 编号受豆瓣分页的影响，如果按升序来需要单独处理 </li>
</ol>
]]></content>
      <categories>
        <category>案例</category>
      </categories>
      <tags>
        <tag>Crawler</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>具有父子关系的结构处理</title>
    <url>/work-three_level-labels/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p> 在工作过程中遇到一个实现三级标签的问题，是同事写的，单说实现其实算不上有难度，但这是我第一次见到算法的实际产出应用，因为公司的代码需要保密，所以将其实现场景做了改变，只保留核心逻辑 </p>
<span id="more"></span>
<h3 id="问题"><a class="markdownIt-Anchor" href="# 问题"></a> 问题 </h3>
<p> 有一个结构体数组，其中包含以下属性：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">id    当前标识 </span><br><span class="line">cotet 内容 </span><br><span class="line">parId 父标识 </span><br></pre></td></tr></table></figure>
<p> 根据其中连接关系对其进行排序输出，可能存在多组 </p>
<h3 id="解决"><a class="markdownIt-Anchor" href="# 解决"></a> 解决 </h3>
<ol>
<li> 将标签数组转换为二维 map，其格式为 map[parId]map[id]*lable</li>
<li> 将得到的 map 根据 parId 进行子内容的查询，对根据子内容的 id 作为 parId 递归查询，将所有的标签连接起来 </li>
<li> 处理输出即可 </li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> work</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> lable <span class="keyword">struct</span> &#123;</span><br><span class="line">	id       <span class="type">int</span></span><br><span class="line">	name     <span class="type">string</span></span><br><span class="line">	parentId <span class="type">int</span></span><br><span class="line">	son      []*lable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lables = [...]*lable&#123;&#123;</span><br><span class="line">	id:       <span class="number">1</span>,</span><br><span class="line">	name:     <span class="string">&quot; 爷爷 &quot;</span>,</span><br><span class="line">	parentId: <span class="number">0</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">	id:       <span class="number">2</span>,</span><br><span class="line">	name:     <span class="string">&quot; 姥姥 &quot;</span>,</span><br><span class="line">	parentId: <span class="number">0</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">	id:       <span class="number">3</span>,</span><br><span class="line">	name:     <span class="string">&quot; 父亲 &quot;</span>,</span><br><span class="line">	parentId: <span class="number">1</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">	id:       <span class="number">4</span>,</span><br><span class="line">	name:     <span class="string">&quot; 母亲 &quot;</span>,</span><br><span class="line">	parentId: <span class="number">2</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">	id:       <span class="number">5</span>,</span><br><span class="line">	name:     <span class="string">&quot; 大儿子 &quot;</span>,</span><br><span class="line">	parentId: <span class="number">3</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">	id:       <span class="number">6</span>,</span><br><span class="line">	name:     <span class="string">&quot; 二儿子 &quot;</span>,</span><br><span class="line">	parentId: <span class="number">4</span>,</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildLabelData</span><span class="params">(list []*lable)</span></span> <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">map</span>[<span class="type">int</span>]*lable &#123;</span><br><span class="line">	<span class="keyword">var</span> data = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">map</span>[<span class="type">int</span>]*lable)</span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> list &#123;</span><br><span class="line">		id := val.id</span><br><span class="line">		parentId := val.parentId</span><br><span class="line">		<span class="keyword">if</span> _, ok := data[parentId]; !ok &#123;</span><br><span class="line">			data[parentId] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*lable)</span><br><span class="line">		&#125;</span><br><span class="line">		data[parentId][id] = val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeTreeLabel</span><span class="params">(index <span class="type">int</span>, data <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">map</span>[<span class="type">int</span>]*lable)</span></span> []*lable &#123;</span><br><span class="line">	tmp := <span class="built_in">make</span>([]*lable, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> id, item := <span class="keyword">range</span> data[index] &#123;</span><br><span class="line">		<span class="keyword">if</span> data[id] != <span class="literal">nil</span> &#123;</span><br><span class="line">			item.son = makeTreeLabel(id, data)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			item.son = []*lable&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = <span class="built_in">append</span>(tmp, item)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastOperate</span><span class="params">(labs []*lable)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> lastData [][]<span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> labs &#123;</span><br><span class="line">		<span class="keyword">for</span> _, s := <span class="keyword">range</span> f.son &#123;</span><br><span class="line">			<span class="keyword">for</span> _, t := <span class="keyword">range</span> s.son &#123;</span><br><span class="line">				tmpData := []<span class="type">string</span>&#123;</span><br><span class="line">					f.name,</span><br><span class="line">					s.name,</span><br><span class="line">					t.name,</span><br><span class="line">				&#125;</span><br><span class="line">				lastData = <span class="built_in">append</span>(lastData, tmpData)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lastData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Entrance</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := buildLabelData(lables[:])</span><br><span class="line">	labs := makeTreeLabel(<span class="number">0</span>, data)</span><br><span class="line">	lastData := lastOperate(labs)</span><br><span class="line">	<span class="keyword">for</span> _, slices := <span class="keyword">range</span> lastData &#123;</span><br><span class="line">		<span class="keyword">for</span> _, dada := <span class="keyword">range</span> slices &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s\t&quot;</span>, dada)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>result<br />
爷爷    父亲    大儿子 <br />
姥姥    母亲    二儿子 </p>
</blockquote>
]]></content>
      <categories>
        <category>案例</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建</title>
    <url>/blog-setup/</url>
    <content><![CDATA[<p>之前一直在 CSDN 写点东西，今天心血来潮尝试了 GitHub Pages + Hexo 的方式，真香，跟着教程手把手来的，但还有一些没提到的小坑，这里做一个汇总</p>
<span id="more"></span>
<p>自己跟的两个教程是：</p>
<ol>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/60578464">知乎 -crystal<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.bilibili.com/video/BV1cW411A7Jx?from=search&amp;seid=4558624466408493237">B 站 -hojun_cn<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://hexo.bootcss.com/docs/">⭐官方文档⭐<i class="fas fa-external-link-alt"></i></a></li>
</ol>
<p>上面个两个教程比较精简直接不过年岁有点久了，在实际操作中我遇到的坑主要是</p>
<ol>
<li>安装时注意目录的选择，尤其是像我这种习惯只用一个盘的用户，看到安装就惯性选择 <code>Program Files</code>，结果在后面更改部署时控制台一直提示权限不够，不怕麻烦可以每次选择<strong> 以管理员身份打开 </strong> 终端，其实没有必要，只要环境配置正确，博客文件的根目录放哪都行</li>
<li>本地资源主要以图片为主，但大量的图片也会导致每次的部署缓慢，这里推荐一个图床 <a class="link"   href="https://picx.xpoet.cn/?#/upload">PicX<i class="fas fa-external-link-alt"></i></a></li>
<li>部署时实用的 SSH 默认为 22 的端口号，偶尔会遇到占用的情况，这时候可以在其目录：<code>C:\Users\userName\.ssh</code>创建一个 config 文件（没有后缀），在其中写入</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User # GitHub 的邮箱</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port # 更改端口</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>不翻墙的情况下，即便 SSH 端口号没有占用，也会出现部署连接失败的情况，这时候就需要开启全局代理</p>
<ol>
<li>
<p>“网络和 Internet 设置” =&gt; 代理，复制“脚本地址”到浏览器</p>
</li>
<li>
<p>会自动下载一个 pac 文件，找到其中的 <code>PROXY</code></p>
</li>
<li>
<p>执行 <code>git config --global https.proxy #PROXY_value</code></p>
</li>
</ol>
</li>
<li>
<p>下载主题模板时如果自定义需求较少，可以使用 npm 或 git clone 的方式下载，然后拷贝配置文件，如果修改项比较多，可以下载 release 版压缩文件手动添加</p>
</li>
</ol>
<p><strong>第一次更新：文件托管外链</strong></p>
<hr />
<p>使用过程中发现自己有文件下载的需求，放到目录部署的操作性太差，容量大了部署也吃不消，考虑到和图床使用的类似操作，我这边选择的是 <a class="link"   href="https://www.qiniu.com/">七牛云<i class="fas fa-external-link-alt"></i></a>，刚跟客服挂掉电话，也不用什么教程，操作界面很清晰，上传文件之后获取外链使用即可，如果没有自己的域名可以买一个（需要备案，阿里云最便宜有首年几块钱的），也可以使用 <code>files.userName.github.io</code> 使用海外域名，但后续使用可能不太方便，譬如出现限制访问的情况</p>
<p><strong>第二次更新：排版和渲染</strong></p>
<hr />
<p>中英文之间的添加空格，以提升阅读体验，其实我本身是有文档书写时手动添加空格的习惯，也尝试过一些本地使用的排版插件，如：pangu，但这些插件往往也会对语法符号（如：#、*）进行空格插入，造成排版与预期不符，但目前使用的 <a class="link"   href="https://github.com/hexojs/hexo-filter-auto-spacing">hexo-filter-auto-spacing<i class="fas fa-external-link-alt"></i></a> 插件，或者说这一系列插件都不会产生这样的问题，因为是将已渲染完成的 html 页面进行中英文空格插入</p>
<blockquote>
<p>有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
</blockquote>
<p>使用 Hexo 默认的渲染器 hexo-renderer-marked 是不支持注脚或者其他 Markdown 的非核心功能，当然这可以使用渲染插件来解决，<strong>但是 </strong> 没有必要，我这边直接换了底层渲染器，目前功能最强大的是：<a class="link"   href="https://github.com/upupming/hexo-renderer-markdown-it-plus">@upupming/hexo-renderer-markdown-it-plus<i class="fas fa-external-link-alt"></i></a> 跟着教程操作就好了</p>
<p>hexo-renderer-markdown-it-plus 是默认支持 Katex 数学公式的，但还需要在每篇文章前放入渲染引用，所以直接将其写入到 /scaffolds/post.md 的模板当中，这样每次创建时就无需手动添加</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">sticky:</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 摘要 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 正文 --&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>第三次更新：GitHub Actions 自动部署</strong></p>
<hr />
<blockquote>
<ul>
<li>可以直接在线编辑 md 文件，立即生效。假设你已发布一篇文章，过几天你在别的电脑上浏览发现有几个明显的错别字，这是完全不能容忍的。但此时你电脑上又没有 hexo + node.js + git 等完整的开发环境，重新配置开发环境明显不现实。如果使用 CI，你可以直接用浏览器访问 GitHub 上的项目仓库，直接编辑带错别字的 md 文章，改完，在线提交，稍等片刻，你的网站就自动更新了</li>
<li>如果手动部署，需要先执行 hexo g 编译生成静态文件， 然后推送 public 整个文件夹到 GitHub 上，当后期网站文章、图片较多时候，很多时候连接 GitHub 不是那么顺畅，经常要傻等很长的上传时间。使用 GitHub Actions 自动部署，你只需 push _post 文件里单独的 md 文件即可，其他不用管，效率瞬间高了许多，其中的好处，谁用谁知道</li>
<li>使用 GitHub Actions，你还可以一次性将这些静态博客页面部署到多个服务器上，例如：GitHub Pages、Gitee pages、七牛云、阿里云、腾讯云等等</li>
</ul>
</blockquote>
<p>用了之后发现确实不是大话，好用归好用，但是配置属实有些麻烦，而且还不懂 Workflow 语法，<a class="link"   href="https://tommy.net.cn/2020/08/06/deploy-hexo-with-github-actions/">自动部署教程<i class="fas fa-external-link-alt"></i></a><br />
注意自动部署的时候，根目录下的 <code>.deploy_git</code> 最好删掉</p>
<p><strong>第四次更新：http 图床与 https 协议不能混合</strong></p>
<hr />
<p>GitHub Pages 中是支持 https 协议的，也有自动续费的安全证书，但是大部分图床外链都是采用 http 协议，导致不能显示，这里提供三个解决方案：</p>
<ol>
<li>将协议指向去掉，链接直接使用 <code>//</code> 开头，让其自己尝试协议（我用这种方式没成功）</li>
<li>关闭 GitHub Pages 中的协议支持，并删除 DNS 中的相应记录</li>
<li>升级图床链接（大部分图床都是 https，不是的也大都支持更改）</li>
</ol>
<p><strong>第五次更新：URL 规范</strong></p>
<hr />
<p>在 <code>_config.yml</code> 中可以配置文件的链接形式，一般是日期加文件名的形式，但是也可以使用 <code>-s</code> 指定 URL，但是最实用的方式，还是将 URL 格式修改为文件名。至于创建的规范大致如下：</p>
<ul>
<li>(M) url 的单词使用全小写，避免驼峰的方式</li>
<li>(S) 如果有多个单词使用 <code>_</code> 进行连接（但是我使用的是 <code>-</code>）</li>
<li>(M) url 必须有其含义，避免使用序号和随机数字，使用数字的使用尽量替换为英文序数而不是基数</li>
</ul>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>盘古之白的说法和这句话来源于 GitHub 中一个自动添加空格的小工具。其真实性不详 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>实用操作</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 导出 csv 文件（非常规）</title>
    <url>/mysql-export-csv/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p> 公司最近在搞安全，把数据库的导出都给限制了，所以这里使用外部查询 + sed 的方式，理论上只要能连接上数据库都能导出 </p>
<span id="more"></span>
<p> 直接上命令，一看就懂：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -h xxx.xxx.xxx.xxx -u[user] -p[pwd] --default-character-set=utf8 -e &quot;SET NAMES utf8;</span><br><span class="line">/*</span><br><span class="line"> 实际查询语句 </span><br><span class="line">*/</span><br><span class="line">| sed -e  &quot;s/\t/,/g&quot; -e &quot;s/NULL/  /g&quot; -e &quot;s/\n/\r\n/g&quot; &gt; /[path]/fileName.csv</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>实用操作</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2 的备份与清理</title>
    <url>/wsl2-backup_and_clean/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p> 毕竟 WSL2 只是一个子系统，所以可以大胆折腾，搞坏了重置 Ubuntu 即可，但是每次弄坏了可能还要去重新配置环境，MySQL, Redis, Docker 啥乱七八糟的装一遍也很麻烦，后来发现可以使用导入导出的方式做一个快照和回滚 </p>
<p> 其次我这种强迫症人选对磁盘清理真是谜之依赖，所以又找到了对 WSL 虚拟磁盘的压缩方式 </p>
<span id="more"></span>
<h2 id="wsl- 的快照和回滚"><a class="markdownIt-Anchor" href="#wsl- 的快照和回滚"></a> WSL 的快照和回滚 </h2>
<blockquote>
<p> 其实就是把阿里云的备份方式做一个套用，结果完全能用 </p>
</blockquote>
<p> 这里首先要去关闭当前运行的子系统 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS C:\&gt;wsl --shutdown</span><br><span class="line">PS C:\&gt; wsl -l -v</span><br><span class="line">  NAME            STATE           VERSION</span><br><span class="line">* Ubuntu-20.04    Stopped         2</span><br></pre></td></tr></table></figure>
<p> 然后直接执行导出命令即可 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">export</span> Ubuntu-20.04 c:\wsl-ubuntu20-04.tar</span><br></pre></td></tr></table></figure>
<p> 之后系统数据会打包成一个 <code>.tar</code> 文件，然后放到 U 盘云端都可以 </p>
<p> 如果需要回滚首先进行系统的注销，然后将 <code>.tar</code> 包进行导入 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注销当前系统 </span></span><br><span class="line">wsl --unregister Ubuntu-20.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行数据的导入 </span></span><br><span class="line">wsl --import Ubuntu-20.04 c:\wsl c:\wsl-ubuntu20-04.tar --version 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新设置默认用户名 </span></span><br><span class="line">ubuntu2004 config --default-user userName</span><br></pre></td></tr></table></figure>
<h2 id="wsl2- 宿主机磁盘清理"><a class="markdownIt-Anchor" href="#wsl2- 宿主机磁盘清理"></a> WSL2 宿主机磁盘清理 </h2>
<p>WSL2 使用虚拟磁盘，如果往 WSL2 中放了大量的数据，然后就删掉，会发现 WSL2 的磁盘占用并没有降下来，这时强迫症如我就需要手动去压缩磁盘 </p>
<p> 第一步还是关闭运行状态的子系统，然后使用 <code>diskpart</code> 命令打开磁盘工具窗口，然后找到自己 WSL 版本对应的磁盘位置，例如我的 Ubuntu-20.04 是 <code>C:\Users\aidan\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc\LocalState\ext4.vhdx</code></p>
<p> 执行磁盘选择命令后压缩 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择磁盘 </span></span><br><span class="line"><span class="keyword">select</span> vdisk file=<span class="string">&quot;&#123;vhdx 文件名 &#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩磁盘 </span></span><br><span class="line">compact vdisk</span><br></pre></td></tr></table></figure>
<p> 如果执行压缩命令时报错不要慌，因为当前磁盘是一个只读的状态，只需要执行 <code>detach vdisk</code> 命令即可，然后压缩，完成后不要忘了把权限换回来： <code>attach vdisk readonly</code></p>
<h2 id="debian- 存储清理"><a class="markdownIt-Anchor" href="#debian- 存储清理"></a> Debian 存储清理 </h2>
<h3 id="旧内核清理"><a class="markdownIt-Anchor" href="# 旧内核清理"></a> 旧内核清理 </h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt purge $(dpkg -l <span class="string">&#x27;linux-*&#x27;</span> | awk <span class="string">&#x27;/^ii/&#123;print $2&#125;&#x27;</span> | grep -P <span class="string">&#x27;^(?!linux-(?:generic|raspi|aws)).*&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="旧软件清理"><a class="markdownIt-Anchor" href="# 旧软件清理"></a> 旧软件清理 </h3>
<ol>
<li> 清理旧版本的软件缓存：<code>sudo apt-get autoclean</code></li>
<li> 清理所有软件缓存：<code>sudo apt-get clean</code></li>
<li> 清理系统中不再使用的孤立文件：<code>sudo apt-get autoremove</code><br />
可以使用 <code>sudo du -sh /var/cache/apt</code> 命令查看缓存大小 </li>
<li> 清理软件的残余配置：<code>sudo apt-get autoremove -purge</code></li>
<li> 卸载软件：<code>sudo apt --purge remove xxx</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt autoclean &amp;&amp; sudo apt clean &amp;&amp; sudo apt autoremove &amp;&amp; sudo apt remove &amp;&amp; sudo apt autoremove --purge</span><br></pre></td></tr></table></figure>
<h3 id="删除残余配置文件"><a class="markdownIt-Anchor" href="# 删除残余配置文件"></a> 删除残余配置文件 </h3>
<p><code>remove</code> 但没有 <code>purge</code> 的软件会残留一部分配置文件，这里做一个清除操作 </p>
<ol>
<li> 找出系统上哪些软件包留下了残余的配置文件：<code>dpkg --list | grep &quot;^rc&quot;</code></li>
<li> 提取软件名：<code>dpkg --list | grep &quot;^rc&quot; | cut -d &quot; &quot; -f 3</code></li>
<li> 删除软件包：<code>dpkg --list | grep &quot;^rc&quot; | cut -d &quot; &quot; -f 3 | xargs sudo dpkg --purge</code></li>
</ol>
<h3 id="清除无用依赖包"><a class="markdownIt-Anchor" href="# 清除无用依赖包"></a> 清除无用依赖包 </h3>
<ol>
<li> 安装查看工具 <code>deborphan</code>，执行软件名列出所有无用依赖：<code>sudo apt install deborphan</code></li>
<li> 删除软件：<code>deborphan | xargs sudo apt purge -y</code></li>
</ol>
<h3 id="清楚过时软件"><a class="markdownIt-Anchor" href="# 清楚过时软件"></a> 清楚过时软件 </h3>
<p> 所谓过时（obsolete）的软件包是指 /etc/apt/sources.list 源文件中没有任何一个软件源提供这个软件的 deb 安装包 <br />
也就是说这个软件包在软件源里找不到了，不被支持了．这可能是因为下面几个原因：</p>
<ul>
<li> 上游开发者不维护这个软件，又没有人来接管这个软件的开发．所以 Debian/Ubuntu 的软件包维护人员决定将这个软件从软件源中删除 </li>
<li> 这个软件成了孤儿，同时用户很少．所以它就从软件源里消失了 </li>
<li> 这个软件有了一个新的名字，维护人员给它起了一个新的名字并保留旧软件包 </li>
</ul>
<ol>
<li> 查找所有过时软件：<code>sudo aptitude search ?obsolete</code></li>
<li> 可以手动删除，也可以清除所有：<code>sudo aptitude purge ~o</code></li>
</ol>
<h3 id="清理日志文件"><a class="markdownIt-Anchor" href="# 清理日志文件"></a> 清理日志文件 </h3>
<p>ncdu 工具可以查看文件大小 </p>
<ol>
<li> 安装后执行：<code>sudo ncdu /var/log</code></li>
<li> 删除可以使用：<code>sudo dd if=/dev/null of=/var/log/xxx.log</code></li>
</ol>
<h3 id="查看大软件"><a class="markdownIt-Anchor" href="# 查看大软件"></a> 查看大软件 </h3>
<p>debian-goodies 工具可以查看软件大小，可以执行 <code>dpigs -H</code> 查看大容量软件，默认展示前十条结果，可以指定展示行数 <code>dpigs -H --lines=20</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.1GiB elasticsearch</span><br><span class="line">315MiB golang-1.18-go</span><br><span class="line">228MiB openjdk-17-jdk-headless</span><br><span class="line">183MiB openjdk-17-jre-headless</span><br><span class="line">140MiB docker.io</span><br><span class="line">105MiB libllvm14</span><br><span class="line">102MiB golang-1.18-src</span><br><span class="line">96MiB containerd</span><br><span class="line">67MiB gcc-12</span><br><span class="line">52MiB guile-3.0-libs</span><br><span class="line">.............</span><br></pre></td></tr></table></figure>
<hr />
<blockquote>
<p> 参考文章：<br />
<a class="link"   href="https://www.linuxdashen.com/debianubuntu%E6%B8%85%E7%90%86%E7%A1%AC%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9A%848%E4%B8%AA%E6%8A%80%E5%B7%A7">https://www.linuxdashen.com/debianubuntu 清理硬盘空间的 8 个技巧 <i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>实用操作</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL2</tag>
      </tags>
  </entry>
  <entry>
    <title>在 vscode 中搭建 C/C++ 开发环境</title>
    <url>/wsl2-build_c_dev/</url>
    <content><![CDATA[<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"></script>
<p> 之前写 C/C++ 一直在 CLion 上，但现在工作了，主要写的语言就只有 Golang 了，但其实工作中还要看一些 PHP，帮同事改改跑跑 Python 脚本啥的，所以现在统一开始使用 vscode 进行开发了，有时候心血来潮也用用 Neovim</p>
<p> 这里分享一下 C/C++ 的运行配置，系统用的是 wsl2-Debian</p>
<span id="more"></span>
<h3 id="软件安装"><a class="markdownIt-Anchor" href="# 软件安装"></a> 软件安装 </h3>
<p> 首先是安装必备的软件 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install gdb gcc build-essential</span><br><span class="line">// 可选 </span><br><span class="line">sudo apt install glibc-source</span><br></pre></td></tr></table></figure>
<h3 id="tasksjson"><a class="markdownIt-Anchor" href="#tasksjson"></a> tasks.json</h3>
<p> 接下来就是创建一个项目目录，执行 <code>Ctrl+Shift+P</code> 输入 <code>Configure Default Build Task</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++ build active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">				<span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;$&#123;workspaceFolder&#125;/exe/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">			<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">				<span class="string">&quot;$gcc&quot;</span></span><br><span class="line">			<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;compiler: /usr/bin/g++&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p> 需要重点看的配置项有 <code>command</code> , <code>args</code> , <code>isDefault</code></p>
<p><code>args</code> 的多个项中有如下含义：</p>
<ul>
<li><code>-g</code> 用来指定编译的文件 </li>
<li><code>$file</code> 当前文件，同时编译多个只能指定类型，如：<code>$&#123;workspaceFolder&#125;/*.cpp</code></li>
<li><code>-o</code> 指定生成的可执行文件的地址 </li>
</ul>
<h3 id="launchjson"><a class="markdownIt-Anchor" href="#launchjson"></a> launch.json</h3>
<p> 第二步是添加运行配置： <code>Run-&gt;Add Configuration</code> 生成 launch.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++ - 生成和调试活动文件 &quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/bin/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 为 gdb 启用整齐打印 &quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 将反汇编风格设置为 Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++ build active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;sourceFileMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;/build/glibc-eX1tMB&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/src/glibc&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p> 这里的 <code>stopAtEntry</code> 必须设置为 true 才能打断点， <code>sourceFileMap</code> 如果有报错可以进行安装设置（最开始的可选安装）</p>
<h3 id="声明路径"><a class="markdownIt-Anchor" href="# 声明路径"></a> 声明路径 </h3>
<p> 调试会需要获取获取相关路径，因为设置过 glibc 的原因可以不进行声明，但是要忍受红红的报错，也可以关掉报错，但是最好不要掩耳盗铃 </p>
<p> 获取相关路径的方式也很简单，只需要执行 <code>g++ -v -E -x c++ -</code> 然后添加到配置即可 </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/include/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/include/c++/11/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/include/x86_64-linux-gnu/c++/11/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/include/c++/11/backward/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/11/include/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/local/include/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/include/x86_64-linux-gnu/**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gnu17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gnu++14&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux-gcc-x64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;browse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;limitSymbolsToIncludedHeaders&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>END</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>VsCode</tag>
      </tags>
  </entry>
</search>
